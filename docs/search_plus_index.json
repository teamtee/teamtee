{"./":{"url":"./","title":"Introduction","keywords":"","body":"欢迎👏 这是我的一份云笔记库，欢迎参观！ "},"课程记录/":{"url":"课程记录/","title":"课程记录","keywords":"","body":"笔记系列 计算机 系统基础 《计算机系统基础》 名称:《计算机系统基础》 类型:课程 作者:袁春风 说明:在MOOC和B站可以直接搜操作系统 操作系统:三个简单的部分（OSTEP） 名称:操作系统:三个简单的部分（OSTEP） 类型:书籍 资源:操作系统:三个简单的部分（OSTEP、课后作业链接、课后答案 作者: 说明:简单易懂，适合入门南京大学计算机系统基础习题课 名称: 类型:课程 资源:课程主页、视频链接 作者:蒋炎炎 说明:较难，建议掌握更多的技能后解锁编译原理 Compilers and Computer Architecture (G5035) 名称:Compilers and Computer Architecture (G5035) 类型:课程 资源:课程主页资料 作者: 说明:编译器课程编程语言 C Unix环境高级编程（APUE） 名称:Unix环境高级编程（APUE） 类型:书籍 资源:MeiK2333的答案、我的笔记 作者: 说明:讲解详细，资料推荐嵌入式C语言自我修养 名称:嵌入式C语言自我修养 类型:网站 资源:嵌入式C语言自我修养 作者: 说明:讲解C语言的高级部分Python 零基础入门Python 名称:零基础入门Python 类型:书籍、视频 资源:B站视频视频 作者:小甲鱼 说明:通熟易懂官方文档 名称:官方文档 类型:网页 资源:网站 作者: 说明: "},"课程记录/DeepLearning/":{"url":"课程记录/DeepLearning/","title":"DeepLeaning","keywords":"","body":"优化器Optim 优化即为寻找最小loss的过程，通常采用梯度下降的算法，关于移动的方向在深度学习里基本上是沿着梯度的方向，但是对于移动的距离，会有不同的解法，朝着所有样本的梯度方向移动是数学里梯度下降法的做法，但是不适合深度学习。 SGD：朝着当前批次的梯度方向移动 θt=θt−1−ηgt−1 \\theta_t = \\theta_{t-1} - \\eta g_{t-1} θ​t​​=θ​t−1​​−ηg​t−1​​ SGDM：朝着当前批次批次和上一次批次的联合梯度方向移动 v=−ηgt−1 v = - \\eta g_{t-1} v=−ηg​t−1​​ θt=θt−1+vt+mvt−1 \\theta_t = \\theta_{t-1} + v_t + m v_{t-1} θ​t​​=θ​t−1​​+v​t​​+mv​t−1​​ Adagrad：朝着当前批次的梯度方向移动，但是大小要考虑过去的梯度均方值 θt=θt−1−η∑i=0t−1gi2gt−1 \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t-1} g_i^2 }} g_{t-1} θ​t​​=θ​t−1​​−​√​∑​i=0​t−1​​g​i​2​​​​​​​η​​g​t−1​​ RMSPro：朝着当前批次的梯度方向移动，但是大小要考虑过去的梯度均方值递减 v1=g0 v_1 = g_0 v​1​​=g​0​​ vt=αvt−1+(1−α)gt−12 v_t =\\alpha v_{t-1} + (1- \\alpha) g_{t-1}^2 v​t​​=αv​t−1​​+(1−α)g​t−1​2​​ θt=θt−1−ηvtgt−1 \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{v_t}} g_{t-1} θ​t​​=θ​t−1​​−​√​v​t​​​​​​​η​​g​t−1​​ （和Adagrad比较更好，因为过去的梯度会累积到很大，会导致后面梯度非常小） Adam：SGDM + RMSPro Tacotron\\Bert\\Transformer\\Big-gan\\MEMO：Adam YOLO\\Mask RNN\\Resnet\\Mask RNN：SGDM 比较：Adam和SGDM Adam：训练较快，但是泛化性不好 SGDM：训练较慢，但是泛化性好 SWATS：Adam->SGDM 解决Adam问题： （1）小的梯度累积会影响突然出现的大梯度：很有可能只有少部分批次会提供大的梯度，但是大的梯度在小的梯度累积下只会走很小的距离 AMSGrad AdaBound 提升SGDM： CNN 卷积神经网络的成功之处在与卷积和池化 卷积可以认为是简化了的全连接层 （1）没有偏差 （2）参数共享 多个输出的卷积可以认为是识别不同特征的通道 池化在于可以通过全局的视角搜寻特征 卷积 首先你明白卷积多基本含义，然后理解卷积不仅仅是在通道内卷积，而且是是跨越多通道的 池化 池化只是在通道内池化，并不跨越不同通道 最大池化、平均池化、注意力池化 RNN 标准神经网络中的所有输入和输出都是相互独立的，但是在某些情况下，例如在预测短语的下一个单词时，前面的单词是必要的，因此必须记住前面的单词。结果，RNN 应运而生，它使用隐藏层来克服这个问题。RNN 最重要的组成部分是隐藏状态，它记住有关序列的特定信息。 RNN 有一个内存，用于存储有关计算的所有信息。它对每个输入采用相同的设置，因为它通过在所有输入或隐藏层上执行相同的任务来产生相同的结果。 RNN通常会用来一对多、多对多、多对一对任务。 Simple RNN 本节点的输出同时取决于当前的输入和隐藏状态。 ElmanRNN将上一次的隐藏层状态作为下一次的隐藏状态，JordanRNN将上一次的输出作为下一次的隐藏状态,下面以Elman为例说明隐藏状态如何起作用 这样的RNN会面临两个问题： （1）梯度消失：LSTM可以解决梯度消失的问题（记忆不会因为一次输出为0就被洗掉） （2）梯度爆炸：因为某一个状态可能累计在隐藏状态中导致不断累积，可以通过Clipping解决 LSTM LSTM的核心就是记忆单元和输入门、输出门、遗忘门，主要步骤如下： （1）记忆单元遗忘： （2）记忆如何更新： （3）记忆如何输出： GRU GRU只有重置门、更新门，没有隐藏记忆单元，会生成隐藏状态 （1）产生候选隐藏状态： （2）输出当前隐藏状态 Bidrectional RNN 拓展 Sequence to Sequence AutoDecoder Pytorch 关于RNN的函数 Pytorch中关于RNN的函数有下面四个，其中nn.RNNBase只是三者共同的祖先，没有forward函数 nn.RNNBase nn.RNN nn.LSTM nn.GRU Transformer Transformer完全是基于Attention和Seq to Seq的模型,论文原文如下Attention Is All You Need,有关Transformer的讲解我不再重复造轮子，请参考Transformer精讲，The Illustrated Transformer Pytorch中关于Transformer的函数 nn.Transformer nn.TransformerEncoder nn.TransformerDecoder nn.TransformerEncoderLayer nn.TransformerDecoderLayer 参考资料 动手学深度学习v2 李宏毅ML2023 "},"课程记录/Python/":{"url":"课程记录/Python/","title":"Python","keywords":"","body":"类与对象 Python中类和对象的所有属性可以通过dir函数查看，dir() 函数用于列出对象的所有属性和方法。当你调用 dir(obj) 时，它会返回对象 obj 所有可以访问的属性、方法和特殊属性的列表，包括类属性 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__'] 值得一提的是 · dict 用于管理 slot属性 slot = [ 'a'] 类方法和静态方法 @classmethod def func(cls): print(cls) 类的表示 str repr str的代偿是repr，反之不是切片、索引、迭代 切片、索引迭代实际上是调用slice函数，slice函数最终调用getitem和setitem函数a = [1,2,3,4,5,6,7,8] a[1:4] = a[slice(1,4,None)]或者a[slice(1,4)] a[1:6:2] = a[slice(1,6,2)] 当你定义了下面的函数后就支持索引了 getitem(self,index) setitem(self,index,value) 类的属性访问 getattribute(self,name) getattr(self,name) setattr(self,name,value) delattr(self,name) 访问属性调用的首先调用getattribute,grattr是getattribute的代偿 类的对象访问 get(self,instance,owner) set(self,instance,value) delete(self,instance) [info] 注意 get和__getattrbute的区别是，前者访问整个对象或者类，后者访问对象或者类的属性 描述符 定义了getattr、setattr、delattr三个函数之一的类被称为描述符，描述符的作用是拦截类的属性的访问、修改、删除，但是对实例对象的访问无效 property描述符 一个简单的property的定义如下 class MyProperty: def __init__(self,fget=None,fset=None,fdel=None): self.fget = fget self.fset = fset self.fdel = fdel def __get__(self,instance,owner): return self.fget(instance) def __set__(self,instance,value): return self.fset(instance,value) def __delete__(self,instance): return self.fdel(instance) def __setter(self,fset): self.fset = fset def __deleter(self,fdel): self.fdel = fdel 用法如下 class c: def __init__(self): self._x = 1 def fget(self): return self._x def fset(self,value): self._x = value def fdel(slef): del self._x x = MyProperty(fget,fset,fdel) class c: def __init__(self): self._x = 1 @MyProperty def x(self): return self._x @x.setter def x(self,value): self._x = value @x.deleter def x(self): del self._x 其中 @MyProperty def x(self): return self._x 等同于 def fget(self): return self._x x = MyProperty(fget) 数据描述符与非数据描述符 当访问一个的属性时，访问的顺序是:数据描述符、对象属性(dict)、非数据描述符、类属性(MRO原则查找继承关系属性) 只定义getattr被称为，非数据描述符 定义了getattr与后两者的其中至少一个被称为数据描述符 class A: def __get__(self,instance,owner): print(\"get\") class B: b = A() B.b get B.b = 1 B.b 1 class A: def __get__(self,instance,owner): print(\"get\") def __set__(self,instance,value): print(\"set) class B: b = A() B.b get B.b = 1 B.b set set_name(self,owner,name):可以解决绑定属性名的传递问题,比如下面的函数中x=c(),执行init后会自动执行set_name并且将x作为name，d作为owner传递进去，实现类和实例名字的绑定 class c: def __set_name__(self,owner,name): self.name = name self.owner = owner class d: x = c() "},"博客日志/":{"url":"博客日志/","title":"博客日志","keywords":"","body":" Windows系列 SSH "},"博客日志/Gitbook/":{"url":"博客日志/Gitbook/","title":"Gitbook","keywords":"","body":""},"博客日志/Gitbook/Gitbook Explore in Mac/":{"url":"博客日志/Gitbook/Gitbook Explore in Mac/","title":"Gitbook Explore in Mac","keywords":"","body":"[Mac] Gitbook in Mac 最近一直在思考如何学习 ，其中很重要的一环是输出。我曾经使用过语雀、思云等等，尽管它们功能丰富并且支持云端，但是对于像一本书一样阅读，这样的要求是达不到的，因此我选择了Gitbook + Githubpages 一、简单使用 Gitbook有网页版和本地版两种，网页版的功能感觉和语雀等类似，因此我选择本地版。你可以将本地版Gitbook（以下简称Gitbook）认为是一个工具链，这个工具链依赖于Node.js和npm。在mac的教程如下，windos还未尝试 1.安装 brew 在mac下需要先安装开发者工具brew,brew是一个类似apt、yum的包管理工具 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 安装完后命令行输入brew检查是否成功安装 npm 安装完brew后利用brew安装npm，npm是一个Node.js的包管理工具。我们需要用它来安装gitbook。 brew install npm 输入npm -v检查是否安装成功 nvm nvm也是Node.js的版本管理工具，类似Python里面的conda。我们需要用它来管理Node.js的版本。 brew install nvm 输入nvm -v检查是否安装成功 gitbook 使用brew安装gitbook.-g选项的意思安装在全局，否则默认为安装在用户下。 brew install gitbook-cli -g 2.使用 初始化 选择一个你希望的空文件夹，初始化工作目录 # 初始化工作目录会生成 README.md 和 SUMMARY.md gitbook init # 构建工作会默认在 _book 下生成文件 gitbook build # 服务器会构建本地端口映射 gitbook serve 执行gitbook init可能会出现的报错，如下 Installing GitBook 3.2.3 /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:200:5) Node.js v21.0.0 这是因为 Node.js 的版本不符合 gitbook 的依赖，下面有三个可能的解决方法（推荐三） 注释polyfills.js文件中的这三行 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 升级graceful-fs # 下面的路径换成你的，--save 的意思是安装在当前的本地，即为更新当前的 graceful-fs cd /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/ npm install graceful-fs@latest --save 通过nvm来暂时降低Node.js版本 nvm -v 可能输出如下,箭头为当前的使用版本 $:nvm ls v21.0.0 -> system default -> node (-> v21.0.0) iojs -> N/A (default) unstable -> N/A (default) node -> stable (-> v21.0.0) (default) stable -> 21.0 (-> v21.0.0) (default) lts/* -> lts/hydrogen (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.17.0 (-> N/A) lts/dubnium -> v10.24.1 lts/erbium -> v12.22.12 (-> N/A) lts/fermium -> v14.21.3 (-> N/A) lts/gallium -> v16.20.2 (-> N/A) lts/hydrogen -> v18.18.2 (-> N/A) 我们需要安装10.24.1的版本,注意该段命令会只是会将当前的shell下的Node.js切换成10.24.1。 #Install a specific version number nvm install 10.24.1 #Use the latest available 8.0.x nvm use 10.21.1 二、入门进阶 1.配置文件 SUMMERY.md 一份参考文件如下，这个文件的内容会被用来生成大纲。 []()的超链接用来表示标题， ----会生成分隔符 # Summary的不是必要的，也不会被显示 ## Chapter1会被显示，但是不如超链接好用，一般只用超链接 # Summary ## Chapter1 * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) ---- * [Last part without title](part3/title.md) book.json 你可以新建一个book.json的配置文件，参考内容如下 { \"title\": \"title\", \"description\": \"description\", \"isbn\": \"isbn\", \"author\": \"author\", \"lang\": \"zh-cn\", \"plugins\": [], \"variables\": { } } 你可以修改plugins来加入插件,search插件支持中文搜索，code插件支持复制,-的意思是不使用该插件，需要使用可以去掉前面的- plugins\": ['code','-seacrh'] 然后利用gitbook install来安装上面的插件 gitbook install 插件可以配置属性 pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } 2.插件推荐 菜单折叠插件 { plugins: ['expandable-chapters']; } 返回顶部插件 { plugins: ['back-to-top-button']; } 引用插件 这里有个教程 { plugins: ['flexible-alerts']; pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } } 引用插件语法 > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. （这个似乎无效） > [!IMPORTANT] > Essential information required for user success. （这个似乎无效） > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. [!NOTE] Information the user should notice even if skimming. 分隔符 [!TIP] Optional information to help a user be more successful. 分隔符 [!WARNING] Dangerous certain consequences of an action. 拓展玩法：自定义引用 有关图标可以在这里寻找 //自定义类型，className可能有info,warning,tip,note pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } } } [!Comment] Dangerous certain consequences of an action. [引用插件] { plugins: ['alerts']; } 效果如下，支持info，waring，danger，successs > **[info] For info** > > Use this for infomation messages. [info] For info Use this for infomation messages. > **[warning] For warning** > > Use this for warning messages. [warning] For warning Use this for warning messages. > **[danger] For danger** > > Use this for danger messages. [danger] For danger Use this for infomation messages > **[success] For success** > > Use this for success messages. [success] For success Use this for success messages. 数学插件 mathjax有问题，总是安装不了，无意间发现了katex可以直接安装 { \"plugins\": [\"katex\"] } 三、深入探索 Github Pages 在github上新建一个仓库，新建个gh-page分支，在github设置支持静态网页的pages。然后我们可以将这个仓库克隆下来，初始化gitbook。不过值得注意的是github只是支持选择/和/docs这两个路径作为网页根目录。因此我们选择/docs，这样的话适合gitbook. 调整gitbook仓库的目录如下,根路径下的README.md作为仓库的说明，book下的README.md作为书籍首页的说明。book可以修改为你喜欢的名字。 . ├── README.md ├── book │ ├── README.md │ ├── SUMMARY.md │ ├── book.json └── docs 同时我们需要修改gitbook命令参数，可以尝试执行如下命令 # 安装book下book.json的插件 gitbook install book # gitbook build src dest gitbook build book docs # gitbook serve src dest gitbook serve book docs 执行后的示例目录 . ├── README.md ├── bash.sh ├── book │ ├── Gitbook Explore in Mac │ ├── How to write markdown elegantly │ ├── README.md │ ├── SUMMARY.md │ ├── book.json │ └── node_modules └── docs ├── Gitbook Explore in Mac ├── How to write markdown elegantly ├── gitbook ├── index.html ├── search_index.json └── search_plus_index.json 自动化脚本 我构建的一份自动更新上传脚本如下，前两行是为了在bash中使用nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # 加载 nvm nvm use 10 gitbook install book gitbook build book docs git add . git commit -m \"Update\" git push gitbook serve book docs 输出文档 问题合集 gitbook install 出问题 使用下面的替代 npm install gitbook-plugin-* gitbook install 参考链接 官方下载和安装文档 官方Github仓库 Gitbook操作指南 Gitbook详解 Gitbook攻略（推荐） 插件集合 GitBook CookBook(优秀) "},"博客日志/Gitbook/Markdown语法/":{"url":"博客日志/Gitbook/Markdown语法/","title":"Markdown语法","keywords":"","body":"how to write markdown elegantly 首先你必须明白mardown是有不同的解析器，不同的解析器对于基础的语法都同时支持，但是对于高级的语法就不一定兼容了。比如Github的README.md，Typora，NWeb这些不同的编译器的解析不同，但是本文主要讲解的是基于Gitbook的markdown语法。 基本入门 参考教程 文本样式 粗体：** ** 或者__ __,快捷键CTRL_b 斜线：* * 或者 _ _,快捷键CTRL_i 删除线：~ ~ 下标： 上标： 特殊块 引用文本： > 代码块：``` ``` [!TIP] 如果想在代码块中使用``` ,可以使用```` 代替``` 包裹） 花体：`` `` 行内代码：`` 无序列表：* + - 有序列表：1. (支持嵌套) 任务列表 - [ ] task1 - [x] task2 - [ ] task3 表格 | Heading 1 | Heading 2 | Heading 3 | | --------- | --------- | --------- | | cell 1 | cell 2 | cell 3 | | cell 4 | cell 5 | cell 6 | 折叠表格 My top languages | Rank | Languages | |-----:|-----------| | 1| Javascript| | 2| Python | | 3| SQL | mergaid关系图 graph TD; A-->B; A-->C; B-->D; C-->D; 数学 \\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right) 链接 超链接：[]() 图片：或者![](src) 视频： 网页： 转义符号 半方大的空白&ensp;或&#8194; 全方大的空白&emsp;或&#8195; 不断行的空白格&nbsp;或&#160; 如何优雅的插入视频 markdown语法 开始我只是想插入Bilibili的jyy的视频，找到了和markdwon相关的两种方法 视频嵌入 网页嵌入 第一方法markdown会识别有问题，markdown阅读器和gitbook都是 第二个markdown阅读器会整个跳转到Bililibi，不过gitbook还是可以正常编译显示 插件 插件有local、youtuber的，我都没试，但是video-player有问题 安装的时候下面这个不行，得用videoplayer,然后他的语法编译也不成功 { \"plugins\": [\"video-player\"] } 教程见此处， "},"博客日志/Tutorial/":{"url":"博客日志/Tutorial/","title":"Tutorial","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(vimtutor，在linux下安装了vim的话可以输入vimtutor来看教程) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "},"博客日志/Tutorial/Dian/Linux/":{"url":"博客日志/Tutorial/Dian/Linux/","title":"Linux/ssh","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(vimtutor，在linux下安装了vim的话可以输入vimtutor来看教程) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "},"博客日志/Tutorial/Dian/Git/":{"url":"博客日志/Tutorial/Dian/Git/","title":"Git","keywords":"","body":"Git 从版本控制开始说起 版本管理一直以来都是挺烦人的事情，比如看下面的图 这还只是一个文件，当涉及到网络和多人协作的大型项目时，那简直是恐怖的灾难。不过很显然，在计算机的世界，有需要就会有轮子，如果没有，那就造一个 版本管理的思想 中心化管理 SVN 版本库放在中心服务器，所有人必须获得最新的版本，在最新的版本上提交他们的修改 分布式管理 Git Git 基于差异和分支的管理 存储目录 文件状态： U、M、A 安装Git Linux sudo apt install git Windows:下载Git bash 开始实战 初始化 git init 配置 git config --global user.name \"John Doe\" git config --global user.email johndoe@example.com git config --list 使用 git clone git status git add . git commit -m \"\" git commit git commit -a -m git push git pull 远程 git remote git remote add pb https://github.com/paulboone/ticgit git push origin master 分支 git branch testing git checkout testing git merge hotfix 实践 本地的版本管理 工作区、暂存区、本地仓库 文件、分支、提交 git init git config --global git add . git commit git branch git branch 和别人联网使用 远程仓库 remote "},"博客日志/Windows/":{"url":"博客日志/Windows/","title":"Windows","keywords":"","body":""},"博客日志/Windows/SSH/":{"url":"博客日志/Windows/SSH/","title":"SSH","keywords":"","body":"在windows里面默认安装了openssh 为什么Powershell中的Git clone检测不到迷药文件 当你使用下面的命令时,GIT会使用ssh命令来登录Github网站，必须有ssh-agent管理的秘钥来验证 git clone git@github.com:teamtee/teamtee.git 但是Git-bash通常使用的是MINGW64的ssh，Powershell/CMD使用的是Windows自带的ssh,见(链接)[https://blog.brian.pub/blog/openssh-on-windows.html] 而windows默认启动的openssh里面的ssh-agent的服务,可以通过修改配置文件.gitconf git config --global core.sshCommand \"C:/Windows/System32/OpenSSH/ssh.exe "},"博客日志/Windows/WSL/":{"url":"博客日志/Windows/WSL/","title":"WSL","keywords":"","body":"配置文件%USERPROFILE%.wslconfig wsl: 检测到 localhost 代理配置，但未镜像到 WSL。NAT 模式下的 WSL 不支持 localhost 代理。 在配置文件中添加,参考(链接)[https://github.com/microsoft/WSL/releases/tag/2.0.0] [experimental] autoMemoryReclaim=gradual networkingMode=mirrored dnsTunneling=true firewall=true autoProxy=true "},"速查笔记/":{"url":"速查笔记/","title":"速查笔记","keywords":"","body":""},"速查笔记/Linux/":{"url":"速查笔记/Linux/","title":"Linux","keywords":"","body":"Linux 剪切板 基于X11的系统通常有两个剪切板 PRIMARY - 鼠标选择复制和粘贴(鼠标中键或右键菜单可复制） SECOND (几乎废弃） CLIPBOARD - CRTL-c/v 选择复制和粘贴 不过似乎我的电脑键盘和鼠标共用一个剪切板，当然你也可以编辑设置 你可以通过xclip或则Xsel和剪切板通信 xclip xclip的用法很简单，支持复制文件,支持选择剪切板,支持管道 xclip filename xclip -sel clipboard xclip -select primary echo \"fs\" | xclip "},"速查笔记/Linux/Vim/":{"url":"速查笔记/Linux/Vim/","title":"Vim","keywords":"","body":"Vim 在命令行中输入vimtutor可以进入教程(目前进度user_10) 模式 vim有下面几种模式 普通模式:默认的模式面板，可以使用一些快捷命令 命令模式:在普通模式输入:进入，按下Esc退出 编辑模式:在普通模式中输入i、o、c、a均可进入,按下Esc退出 块/列块模式:在普通模式输入v/CTRL-v进入块/列块模式,按下Esc退出 普通模式 普通模式下可以使用这些命令 编辑命令 d:删除命令，命令格式为d+位置（dw，de，dd，d2w) y:复制命令，命令格式为y+位置(yw,ye,yy) p:粘贴命令 u:撤销命令，撤销上次修改 C-R:恢复命令，恢复上次的撤销 x:字母剪切命令 r:字母替换命令 R:持续替换命令 位置跳转 w:单词头 e:单词尾 $:句子结尾 ^:句子开头 gg:文章开头 G:文章结尾 %:配对符号跳转 [[:按照C语言特性跳转到当前函数开头 ]]:按照C语言特性跳转到当前函数结尾 ]c/[c:跳转到上次修改的地方 :行内位置跳转 编辑模式: i:直接输入 c:纠删输入 o:下新行输入 O:上新行输入 a:前输入 A:后输入 查找命令 按下/全文查找，按下？下文查找，回车确认，n跳转到下一个查找，N跳转到上一个,下面是查找相关的配置 :set ic # 忽略大小写 :set noic # :set hls is # 设置high light search :nohlsearch :hls :set incsearch # 不知道有什么用 命令模式 文件命令 :edit:编辑命令 :edit *.txt:编辑命令 :write one.txt:写入命令 :file main.c:重命名命令 :saveas :编辑命令 :w保存命令 :q退出命令 :!执行外部命令 :read file.txt:读取文件 :0read file.txt:读取第一行 编辑命令 :substitute `:[位置]s/旧字符/新字符/[gc]`:g表示所有项，c表示询问每一项 :4,6s/old/new/g # 替换4-6行的内容 :%s/ld*c/ld/g #替换全文内容 :'s// #配合块模式使用 .表示当前光标位置 :.write file.txt :.,$s/yes/no/ :45s :4,5s :s+one/two+one or two+ 中，or :?^Chapter?,/^Chapter/s=grey=gray=g :.+3,$-5s :help :help vimrc-intro :help user-manual ctrl-d/TAB 提示补全 `:set nocp`设置补全功能 窗口命令 新建立 vim -o/O 1.txt 2.txt vimdiff main.c~ main.c CTLR-w:在窗口间跳转 4CTLR-w +/-:改变大小 CTRL-h/i/j/k: CTRL-t/b: :split :split two.c :vsplit :close :only :new :vertical new :qall :wall 列块模式 I列编辑 A列添加 ~切换大小写 U小写变大写 u大写变小写 >右移动 :set shiftwidth=4 多文件编辑 标记mark CTLR-i:跳转到新位置 CTLR-o:跳转到旧位置 :marks 查看所有mark 匿名mark 当你使用位置跳转时下面会自动记录你的位置 ':The cursor position before doing a jump \":The cursor position when last editing the file [:Start of the last change ]:End of the last change 记名mark ma:标记名为a的mark `a:跳转到名为a的mark 'a:跳转到名为a的mark 文件列表 vim one.c two.c three.c :args :args five.c six.c seven.h :argadd :argdel :next :previous :last :first :set autowrite :set noautowrite 配置文件 :edit ~/.vimrc 这是 Unix 系统所使用的命令 :edit ~/_vimrc 这是 MS-Windows 系统所使用的命令 :r $VIMRUNTIME/vimrc_example.vim :write 查看配置 :options :set nowarp :set sidescroll=10 :set list 查看tabs :syntax enable :syntax off :set background=dark :colorscheme evening 编辑配置 :set autowrite :set noautowrite :set backup :set backupext=.bak 包 mkdir -p ~/.vim/pack/fancy在.vimrc中加入 packadd! matchit 插件 插件位置 system plugin directory Unix ~/.vim/plugin/ PC $HOME/vimfiles/plugin or $VIM/vimfiles/plugin Amiga s:vimfiles/plugin Macintosh $VIM:vimfiles:plugin Mac OS X ~/.vim/plugin/ # ctags 寄存器 A会追加内容到寄存器a中，a表示覆盖,Y等于y$ \"aY \"AY 标签 参数列表 拓展 如何让Vim和Linux共用剪切板 实测安装vim-gtk3后vim匿名寄存器直接变为系统剪切板 +clipboard 参考教程 Vim 需要+clipboard功能标志才能使这些功能发挥作用,你可以通过在 Vim 中使用:echo has('clipboard')来检查你的 Vim 是否有这个功能，返回1表示有，如果没有，请安装 Debian 和 Ubuntu:安装vim-gtk3. Fedora:安装vim-X11并运行vimx（vim更多信息）。 Arch Linux:安装gvim（这也将+clipboard正常启用） 基于X11的系统通常有两个剪切板 PRIMARY - 鼠标选择复制和粘贴 CLIPBOARD - CRTL-c/v 选择复制和粘贴 Vim同样有两个特殊的寄存器和这两个剪切板相关联 * - PRIMARY + - CLIPBOARD 对于Windows和OS X系统而言只有一个剪切板,所以这两个没有区别 你可以直接使用这两个寄存器 \"*yy \"*p 你可以重新设置匿名寄存器set clipboard=unnamed set clipboard=unnamedplus 当然你也可以重新映射快捷键noremap y \"*y noremap p \"*p noremap Y \"+y noremap P \"+p vim -R 1.txtvim -M 1.txt :set modifiable :set write "},"速查笔记/Linux/Git/":{"url":"速查笔记/Linux/Git/","title":"Git","keywords":"","body":"Git 这里有一份官方教程 基本命令 git merge 配置 常用配置 git config --global core.editor emacs 基础 git status -s git rm --cached README git rm git mv file_from file_to git commit --amend # git remote add pb https://github.com/paulboone/ticgit git tag git tag -l \"v1.8.5*\" 查看 git log --oneline --decorate --graph --all 使用技巧 .gitignore .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反 glob 模式是指 shell 所使用的简化了的正则表达式。 支持*，？，[abc],[a-z]星号。 使用两个星号**表示匹配任意中间目录。 分支指代 -- HEAD～ reset和checkout 分支层面 git reset --soft HEAD (移动HEAD和分支） git reset HEAD （移动HEAD和分支，修改暂存区） git reset --hard HEAD （移动HEAD和分支，修改暂存区，工作区）（⚠️） git checkout HEAD （移动HEAD，修改暂存区，工作区） 文件层面 git reset HEAD file （修改暂存区） git checkout HEAD file （修改暂存区，工作区） （⚠️） resotre git restore --sourece --staged --worktree file 分支合并(TODO) --continue --abort 分支合并有merge和rebase方法,git pull时会自动调用git merge,git merge首次要求设定ff或者rebase的配置值。 git stash git pull git stash pop git checkout -b branchA git add . git commit -m \"\" git checkout main git reset --hard git pull git rebase main branchA 标签（TODO） 有趣命令 修改远程HEAD git remote set-head origin branchA git remote set-head origin -d 配置 配置文件 · system - /etc/gitconfig · global - ~/.gitconfig · local - .git/.gitconfig 配置代理 git config --global https.proxy https://localhost:7890 git config --global http.proxy http://localhost:7890 "},"速查笔记/Linux/Tmux/":{"url":"速查笔记/Linux/Tmux/","title":"Tmux","keywords":"","body":"Tmux 这里是一份教程,可以参考。 基本概念 从服务的角度：server - client tmux有一个server管理多个client，每个client和一个session连接,用户启动tmux的时候实际上是启动一个client连接到server。client是伪终端，进程实际由server管理,当用户断开连接后，运行在client中的进程不会被中断。 从显示的角度：session - windows - pane(terminal) 每个session可以与零个或者多个client相连接，每个session的命名必须唯一。每个session管理多个windos,windows的命名可以重复，可以连接一个或者多个session，windows内有多个pane,其中有一个为活跃的pane 当所有的session中的所有进程终止的时候server终止 命令模式 PREFIX 默认为CTRL-b,按下PREFIX b :进入命令模式，按下PREFIX b ?查看所有命令,按下PREFIX b /查看单个命令 Tree 模式 session Tmux有一个模式叫树模式，在Tmux中按下PREFIX b s或者PREFIX b w进入，前者显示当前附着的session的情况，后者显示所有session的情况，还可以通过:choose-tree进入。进入后屏幕分为上部分树和下部分预览。 树模式下可以按下t标记，T取消所有标记，x删除当前项，X删除所有标记项目，也可以用:使用命令对所有的标记项操作。r可以反向排序,v可以取消预览。 client Tmux也有关于client的树模式，按下PREFIX b D进入，可以看到当前活跃的client以及和哪一个session相连接。 基本使用 创建client tmux ls: 列出所有的session tmux: 默认会创建一个client和一个session,等同于tmux new tmux -t session_name: 创建一个client同时连接session 创建session tmux new：创建一个默认的名为index的session（即为名字就是序号) tmux new -syourname: 指定名字为yourname 创建windows :neww: 创建默认窗口，名字为通常为bash :neww -nyourname: 创建窗口同时命名 :neww -t999: 创建窗口同时指定序号为999 :neww top: 创建窗口同时命名和执行改命令top 切换windows PREFIX b [0-9]: 切换窗口为序号[0-9] PREFIX b ': 输入序号然后切换到序号窗口 PREFIX b p: 切换到前窗口 PREFIX b n: 切换到后窗口 创建panes PREFIX b %： 垂直分割 PREFIX b \": 水平分割 切换panes PREFIX b {: 当前pane和上边pane交换位置 PREFIX b }: 当前pane‵和下边pane`交换位置 PREFIX b up/down/right/left: 切换当前聚焦的pane 修改pane的大小 PREFIX b PREFIX up/down/right/left：上下左右微调 PREFIX b M-up/down/right/left： 上下左右大调 PREFIX b M-1/2/3/4/5: 调整布局格式 删除 PREFIX b &: 删除当前session PREFIX b x: 删除当前panes 复制和粘贴 PREFIX b [: 进入复制模式/滚轮模式，复制模式下会冻结输出   PREFIX space:开始选取复制   PREFIX w:结束复制   q: 退出复制 PREFIX b ]: 粘贴上一次复制的文本 PREFIX b =: 选择要粘贴的文本 其他 :set -g mouse on: 支持鼠标 Tmux配置文件（TODO） Tmux插件 可以安装tpm来管理和安装插件 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 在配置文件内写入~/.tmux.conf # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' # Other examples: # set -g @plugin 'github_username/plugin_name' # set -g @plugin 'github_username/plugin_name#branch' # set -g @plugin 'git@github.com:user/plugin' # set -g @plugin 'git@bitbucket.com:user/plugin' # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run '~/.tmux/plugins/tpm/tpm' 在tmux中使用PREFIX b I即可安装 tmux-resurrect 自动保存会话 教程 配置文件 set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-resurrect' set -g @plugin 'tmux-plugins/tmux-continuum' set -g @continuum-save-interval '15' set -g @continuum-restore 'on' set -g @resurrect-capture-pane-contents 'on' ​ # Other config ... ​ run -b '~/.tmux/plugins/tpm/tpm' 快捷键 PREFIX + CTRL s：保存会话 PREFIX + CTRL r：加载会话 tmux-yank 和系统剪切板共用 必须装有xsel或者xclip set -g @plugin 'tmux-plugins/tmux-yank' 普通模式： PREFIX-y复制当前光标后内容到剪切板 复制模式：按下PREFIX-[进入 PREFIX-space选中内容后，按下y复制,按下Y复制并且粘贴到当前命令行 当然你也可以在tmux.conf中设置默认交互的剪切板 # ~/.tmux.conf set -g @yank_selection 'primary' # or 'secondary' or 'clipboard' "},"速查笔记/Linux/Make/":{"url":"速查笔记/Linux/Make/","title":"Make","keywords":"","body":"Makefile 这里是一份教程 基本概念 Makefile主要由目标、依赖、命令构成 targets: prerequisites command command command 规则 隐式规则 当缺乏所需要的文件的编译规则或者链接规则时时会自动 $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 模式规则 %.o:%.c 静态模式规则 $(objects):%.o:%.c 变量 自动变量 $@:target $?:prerequisite newer than target $^: all prerequisite $变量赋值 := 直接赋值 = 间接赋值 ?= 判空赋值（便量不存在,变量存在为空也不会赋值） += 追加赋值 通配符 *在命令中表现为通配符 $(wildcard *.c) $(filter *.o,$(objects):%.o:%.c %在规则和变量赋值中表现为通配符 $(objects):%.o:%.c two := $(foo:%.o=%.c) 函数变量 函数 make有大量的内置函数 # subst （字符替换） $(subst old,new,str) # patsubst （正则表达式替换） $(patsubst pattern,replace,strs) two := $(foo:%.o=%.c) three := $(foo:.o=.c) # if （condition为空或者不存在为假） $(if condition,value1,value2) # call $(call func,arg1,arg2,...) # addprefix （当INC_PATH存在-I开头时不会重复添加） $(addprefix -I,INC_PATH) # fileter $(filter *.o,objects):%.o:*.c 指令 目标 .PHONY: .DEFAULT_GOAL: include|-include|sinclude make命令会在-I指定的目录和系统的include目录下查找include所包含的文件，当为查找到文件且没有构建该文件的规则时，如果是include，make会报错退出，-include忽视会继续执行，sinclude是GNU make下为了和其他make兼容的-inlcude Kconfig kconfig是一种帮助复杂工程配置相互关联的选项的配置文件，Linux内核和嵌入式操作系统zephyr就是用kconfig管理的 Kconfig解析 这里是一份教程 Kconfig可以用C语言相关的库解析，也可以通过Python的包解析，这里我演示如何使用Python的kconfiglib解析 from kconfiglib import Kconfig from menuconfig import menuconfig kconf = Kconfig(filename=\"./Kconfig\") menuconfig(Kconf) kconf.write_autoconf() Kconfig语法 这里是一份教程 通常一份配置文件如下 mainmenu \"Kconfig Demo\" menu \"Test Params setting\" config TEST_ENABLE bool \"Enable test work\" default n help Will print debug information if enable. ... endmenu Kconfig文件有以下内容 config menuconfig:设置标题 choice/endchoice：设置bool和tristate的值 comment：设置评论信息 menu/endmenu：设置菜单 if/endif：设置隐藏块 source：设置config 通常的配置项目如下，config name，然后下面是属性 config name ... 必须配置属性值：\"bool\"/\"tristate\"/\"string\"/\"hex\"/\"int\" bool \"Networking support\" (注：tristate为y/n/m三态，y表选择，n不是不选择，m表示编译到内核） 可以配置提示符: 最多一个 \"prompt\" [\"if\" ] bool promt \"Networking support\" 可以配置默认值： 不限数量，取第一个，如果有if，当if为真时该默认值才起作用 \"default\" [\"if\" ] 可以配置依赖项： 只有当依赖项为真的时候该配置项才可见 bool \"foo\" if BAR default y if BAR depends on BAR bool \"foo\" default y 可以配置关联项： 选中了BAR会导致FOO也变为选中(Y)，使得满足依赖关系 config FOO bool \"Foo Option\" config BAR bool \"Bar Option\" select FOO if BAR 可以配置弱依赖： 当FOO被选择后会自动配置BAZ为选中状态 （如果为int，设置为默认值，如果为bool，设置为y,如果为tristate，设置为y） config FOO tristate \"foo\" imply BAZ config BAZ tristate \"baz\" 可以设置范围： 数值类型可以设置范围 \"range\" [\"if\" ] 可以设置提示词： \"help\" menuconfig (1): menuconfig M if M config C1 config C2 endif (2): menuconfig M config C1 depends on M config C2 depends on M choice \"choice\" [symbol] \"endchoice\" choice prompt \"Fruit options\" config APPLE bool \"Apple\" help Select this option if you like apples. config ORANGE bool \"Orange\" help Select this option if you like oranges. config BANANA bool \"Banana\" help Select this option if you like bananas. endchoice "},"速查笔记/Python/":{"url":"速查笔记/Python/","title":"Python","keywords":"","body":""},"速查笔记/Python/DeepLearning/":{"url":"速查笔记/Python/DeepLearning/","title":"DeepLearning","keywords":"","body":""},"速查笔记/Python/DeepLearning/Pandas/":{"url":"速查笔记/Python/DeepLearning/Pandas/","title":"Pandas","keywords":"","body":"Pands库的使用 这里是一份官方教程 基本概念 Pandas的数据由series和DataFrame组成，通常这两个数据结构的值是可以改变的，但是大小不可改变 series是具有index和name的同类dtype的values数据序列,使用numpy.ndarray来存储数据，pandas只有三种数据类型int (int64)、float (float64)、str(object) ages = pd.Series(index=[0,1,2],value=[22, 35, 58],name=\"Age\",dtype=int) DataFrame是一系列series的集合,每个series具有相同的index和相同的长度，name在dataFrame中组成colunms,DataFrame的index和colunms属性实际上是Series,具有单个类型series的dataFrame同一类型，具备多种类型series的dataFrame为object类型。 df = pd.DataFrame(np.arange(9).reshape(3, 3), index = ['TJ', 'BJ', 'SH'], columns=['q', 'w', 'e']) 基本操作 读取与转化 可以通过字典创建dataFrame,通过列表创建series，也可以通过read_* 类函数和to_*函数进行读取和存储,支持csv、excel、json等等流行文件。 pd.read_excel(\"titanic.xlsx\", sheet_name=\"passengers\") df.to_excel(\"titanic.xlsx\", sheet_name=\"passengers\", index=False) pd.read_csv( \"data/air_quality_long.csv\", index_col=\"date.utc\", parse_dates=True ) 查看信息 df.tail df.head df.info df.dtypes df.shape 数据索引 注意你的到的数据通常和原数据是同一份，修改会改变两者 df[\"age\"] df[[\"age\",\"sex\"]] df[df[\"age\"]>35] df[\"age\"]>35 df[df[\"Pclass\"].isin([2, 3])] df[(df[\"Pclass\"] == 2) | (df[\"Pclass\"] == 3)] df[df[\"Age\"].notna()] df.loc[df[\"Age\"] > 35, \"Name\"] df.iloc[9:25, 2:5] df.iloc[0:3, 3] = \"anonymous\" 统计操作 对series可以求max、mean、median，对于dataFrame可以求corr,也可以通过describe查看多个统计值列表，还可以通过value_counts统计出现的次数 agg函数可以选择多个统计量聚类分析 In [7]: titanic.agg( ...: { ...: \"Age\": [\"min\", \"max\", \"median\", \"skew\"], ...: \"Fare\": [\"min\", \"max\", \"median\", \"mean\"], ...: } ...: ) ...: Out[7]: Age Fare min 0.420000 0.000000 max 80.000000 512.329200 median 28.000000 14.454200 skew 0.389108 NaN mean NaN 32.204208 groupby可以选择将某列值作为分类依据,将原数据分为多组,然后计算某个统计值 In [9]: titanic.groupby(\"Sex\").mean() Out[9]: Sex PassengerId Survived Pclass ... SibSp Parch Fare ... female 431.028662 0.742038 2.159236 ... 0.694268 0.649682 44.479818 male 454.147314 0.188908 2.389948 ... 0.429809 0.235702 25.523893 groupby也可以选择多个列,会对这多个列进行排列组合 In [11]: titanic.groupby([\"Sex\", \"Pclass\"])[\"Fare\"].mean() Out[11]: Sex Pclass female 1 106.125798 2 21.970121 3 16.118810 male 1 67.226127 2 19.741782 3 12.661633 Name: Fare, dtype: float64 value_counts可以统计每一种元素出现的次数 In [12]: titanic[\"Pclass\"].value_counts() Out[12]: Pclass 3 491 1 216 2 184 Name: count, dtype: int64 数据重组 sort_values可以按值排序，sort_index可以按照序列排序 In [7]: titanic.sort_values(by=['Pclass', 'Age'], ascending=False).head() Out[7]: PassengerId Survived Pclass ... Fare Cabin Embarked 851 852 0 3 ... 7.7750 NaN S 116 117 0 3 ... 7.7500 NaN Q 280 281 0 3 ... 7.7500 NaN Q 483 484 1 3 ... 9.5875 NaN S 326 327 0 3 ... 6.2375 NaN S [5 rows x 12 columns] pivot可以从原数据中抽取数据，有两种使用方式 pivot(columns=\"location\", values=\"value\") pivot_table同时可以指定index,但是需要指定聚合方法 air_quality.pivot_table( values=\"value\", index=\"location\", columns=\"parameter\", aggfunc=\"mean\" )_counts melt函数创建透视表 pd.melt(df, id_vars =['Name'], value_vars =['Course'],var_name = \"\",value_name = \"\") 合并表格 concat pd.concat([air_quality_pm25, air_quality_no2], axis=0) pd.concat([air_quality_pm25, air_quality_no2], keys=[\"PM25\", \"NO2\"]) merge 见这篇文章 import pandas as pd left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']}) right = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']}) result = pd.merge(left, right, on='key') # on参数传递的key作为连接键 result Out[4]: A B key C D 0 A0 B0 K0 C0 D0 1 A1 B1 K1 C1 D1 2 A2 B2 K2 C2 D2 3 A3 B3 K3 C3 D3 绘制 ['area', 'bar', 'barh', 'box', 'density', 'hexbin', 'hist', 'kde', 'line', 'pie', 'scatter'] df.plot() plt.show() 映射操作 参考这篇文章 series.map:支持字典，函数 series.apply:支持带参数的函数 dataFrame.apply:函数 dataFrame.applymap:函数 data[\"gender\"].map({\"男\":1, \"女\":0}) data[\"gender\"].map(lambda x:\"%.2f\" % x) addition = lambda x, y: x + y data[\"age\"].apply(addtion,args=(-3,)) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=0) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=1) df.applymap(lambda x:\"%.2f\" % x) 还可以对index和name进行映射，这个函数叫rename air_quality_renamed = air_quality.rename( columns={ \"station_antwerp\": \"BETR801\", \"station_paris\": \"FR04014\", \"station_london\": \"London Westminster\", } ) 时间序列处理和文本处理（TODO） 操作实例 "},"速查笔记/Python/DeepLearning/matplotlib/":{"url":"速查笔记/Python/DeepLearning/matplotlib/","title":"Matplotlib","keywords":"","body":"从零开始学Matplotlib绘图 Matplotlib是绘制图片的利器,支持多种类型的绘制样式,甚至还可以绘制动画,快和我一起来学习吧,本文参考,关于各种样例 你好世界 下面是第一个实例 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_axes(rect = [0,0,1,1]) ax.plot(x) ax.set_title(\"Hello world!\") plt.show() 这段实例的主要任务如下,后面所有绘制流程基本相似 创建一个画布Figure:plt.figure 添加一个画区Axes:fig.add_axes,[左,下,宽,高]=[0,0,1,1] 添加一个画件Artist-Line2D:ax.plot 添加一个画件Artist-Text:ax.set_title 展示绘制图形:plt.show 无限可分 使用figure画图的最重要的功能之一是绘制多个图形在一个画布上,即在一张画布上画多个图形 fig.subfigures() fig.subfigures的参数如下 nrows, ncols : int,指定划分子图的网格行列数 wspace, hspace : float, 指定子图的水平间距和垂直间距 width_ratios : array-like of length *ncols,指定子图的宽度比,数组长度等同与列数 height_ratios : array-like of length *nrows,指定子图的高度比,数组长度等同与行数 实例如下,你可以看到的确划分成功了,但是不同画区的显示好像重叠了诶？ import numpy as np import matplotlib.pyplot as plt fig = plt.figure() sub_figs = fig.subfigures(2,3,wspace=0.1,hspace=0.2,width_ratios=[0.1,0.6,0.1],height_ratios=[0.5,0.5]) for i in sub_figs: for j in i: j.add_axes([0,0,0.8,0.8,]) plt.show() 我们在划分子区的时候的确将不同子区对应到了不重叠的子画布上,但是子区默认的[左,下,宽,高]=[0,0,0.8,0.8],左和底的开始位置恰好位于边界,自动在当前添加的刻度会超出边界被下一个子图覆盖,修改为这样就好了 j.add_axes([0.2,0.2,0.8,0.8,]) 另一个方法是使用自动布局,layout支持constrained、compressed、tight三种布局,它会帮我们自动的调整被覆盖的位置 fig = plt.figure(layout = \"constrained\") fig.add_axes() fig.add_axes的参数如下,较为简单不做演示 rect:(left,bottom,width,height),表示新 Axes的尺寸。所有值都是相对于图形宽度和高度的分数。 projection:str,投影类型的名称,用于指定 Axes 的投影方式。可以是预定义的投影类型,如 'aitoff'、'hammer'、'lambert'、'mollweide'、'polar'、'rectilinear',也可以是自定义投影的名称。默认值为 None,表示使用默认的 'rectilinear' 投影。 polar:bool,表示是否使用极坐标投影。如果设置为True,则等效于 projection='polar'。 sharex、sharey:matplotlib.axes.Axes 对象,用于共享 x 轴或 y 轴。共享轴将具有与共享轴的原始轴相同的限制、刻度和刻度尺度。fig.add_subplot() fig.subplot具有的参数如下 projection,polar,sharex,sharey,label:见上 args:(row, col, index)或者 .SubplotSpec, 默认为 (1, 1, 1),按照指定的行列划分在指定序号的位置创建Axes,.SubplotSpec见下fig.add_gridspec()fig.subplots() fig.subplots具有的参数如下,实际上该函数就是调用的fig.add_subplot nrows, ncols,sharex,sharey width_ratios,height_ratios:list of array,长度和行列对齐,指定宽度和长度比 squeeze:bool控制返回的 Axes 对象的维度,指定后返回一个压缩一维数组(2,3)->(6) subplot_kw:dict,传递给 Figure.add_subplot 方法的关键字参数字典。 gridspec_kw:dict,传递给 gridspec.GridSpec 构造函数的关键字参数字典。 fig.subplot_mosaic() fig.subplot_mosaic的参数如下 sharex,sharey,width_ratios,height_ratios,subplot_kw,,gridspec_kw mosaic:str或者list,指定划分分区的方式,比较灵活,见下面的示例 per_subplot_kw:dict,传递给每个子区的参数 empty_sentinel : str,指定无效占位符,默认为. 当mosaic为str时,.表示无效占位符,两个AA表示名称为A的Axes占用两个位置, import numpy as np import matplotlib.pyplot as plt fig = plt.figure() sub_figs = fig.subplot_mosaic(\"AAC;.BC\") sub_figs['A'].plot(x) 当mosaic为list时 import numpy as np import matplotlib.pyplot as plt inner = [ [\"inner A\"], [\"inner B\"], ] outer_nested_mosaic = [ [\"main\", inner], [\"bottom\", \"bottom\"], ] axd = plt.figure(layout=\"constrained\").subplot_mosaic( outer_nested_mosaic ) plt.show() fig.add_gridspec() 实际上该函数是调用了GridSpec,GridSpec的参数如下 nrows, ncols,wspace,hspace,width_ratios,height_ratios left, bottom right, top : float,指定位置信息,默认为(0.125,0.1,0.9,0.9) 该函数生成的参数可以直接给fig.add_subplot使用 import numpy as np import matplotlib.pyplot as plt fig = plt.figure(layout, facecolor='lightblue') gs = fig.add_gridspec(nrows=3, ncols=3, left=0.05, right=1, hspace=0.5, wspace=0.5) ax0 = fig.add_subplot(gs[:-1, :]) ax1 = fig.add_subplot(gs[-1, :-1]) ax2 = fig.add_subplot(gs[-1, -1]) fig.suptitle('Manual gridspec with right=0.75') 也可以直接在该返回值上绘制subgridspec,然后使用subplots def squiggle_xy(a, b, c, d, i=np.arange(0.0, 2*np.pi, 0.05)): return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d) fig = plt.figure(figsize=(8, 8), layout='constrained') outer_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0) for a in range(4): for b in range(4): # gridspec inside gridspec inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0) axs = inner_grid.subplots() # Create all subplots for the inner grid. for (c, d), ax in np.ndenumerate(axs): ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1)) ax.set(xticks=[], yticks=[]) # show only the outside spines for ax in fig.get_axes(): ss = ax.get_subplotspec() ax.spines.top.set_visible(ss.is_first_row()) ax.spines.bottom.set_visible(ss.is_last_row()) ax.spines.left.set_visible(ss.is_first_col()) ax.spines.right.set_visible(ss.is_last_col()) plt.show() 设置样式 本文的一大特点就是通过类-对象的方式来学习Matplotlib,当你明白了各个类别和子类之间的属性关系后,你就会发现繁复的属性和函数其实有很多是共通的,你可以不用记忆,在使用中熟悉下面的类属关系。 Figure:matplotlib.figure.Figure画布 Axes:matplotlib.axes._axes.Axes画区 super-_AxesBae: dataLim : .Bbox数据范围 viewLim : .Bbox显示范围 xaxis/yaxis:XAxis/YAxis坐标轴 super-Axis:坐标轴基类 XTick/YTick:刻度 super-Tick 刻度基类 spines:list of matplotlib.spines.Spines封闭线 super-Patch:基本形状 transAxes: BboxTransformTo:坐标变换 transData: Transform:坐标变换 fmt_xdata: None | Formatter = ... fmt_ydata: None | Formatter = ... _AxesBase - 画布 _AxesBase具有的基本属性如下 _AxesBase facecolor:color属性,设置背景颜色 frameon:bool,设置边缘是否可见 label:str,设置添加的标题 xscale:str,表示 x 轴的缩放类型。可以是以下字符串之一:'linear'（线性缩放）、'log'（对数缩放）、'symlog'（对称对数缩放）或 'logit'（逻辑刻度缩放）。默认为 'linear' yscale:str,同yscale box_aspect:float,表示图形的盒子宽高比 fmt_xdata:Formatter fmt_ydata:Formatter 设置空白边缘,Axes有一个隐藏属性ax._xmargin,支持负数表示覆盖 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xmargin(-0.1) ax.plot(x) plt.show() spines - 封闭线 你注意到上文的实例中有这么一段话,实际上这是在修改Axes.spines属性,spines属性表示四周的封闭线,包含top,bottom,left,right。你可以采用ax.spines.top或者ax.spines['top']等方式来访问,下面的语句为设置可见性 ax.spines.top.set_visible() spines的父类是matplotlib.patches.Patch,它是 matplotlib 中所有二维可视元素的基类,是一个带有面部颜色和边缘颜色的二维可视元素。这个父类包含这些基本属性 edgecolor: color属性边缘颜色。 facecolor: color属性面部颜色。 color: color属性。该参数用于同时设置边缘颜色和面部颜色。如果同时指定了 color、edgecolor 和 facecolor,则 color 的优先级最高。 linewidth:float,线条宽度。 linestyle: linestyle属性。指定图形对象的边缘线条的样式, antialiased:bool 抗锯齿效果。 hatch:str 填充图案。指定图形对象的填充图案,可以是字符串(例如 '/'、'\\\\'、'x'、'+')。默认值为 None,表示不使用填充图案。 fill: bool填充。指定是否填充图形对象的面部。默认值为 True,表示填充面部。 capstyle: capstyle属性线条端点样式。 joinstyle: joinstyle属性,线条连接方式 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_title(\"Hello world!\") ax.spines['top'].set_color('C0') fig.set_frameon(False) plt.show() [info] linestle属性 指定线形的方式可以是'solod'或者`'-' '-' solid '--' dashed '-.' dash-dot ':' dotted xaxis/yaxis - 坐标轴 xaxis/yaxis是XAxis/YAxis的实例,XAxis/YAxis继承Axis类,同时还具有一个继承了Tick类的XTick/YTick的属性. Axis是 matplotlib 中用于表示坐标轴的类 Axis: major : matplotlib.axis.Ticker,表示主刻度 minor : matplotlib.axis.Ticker,表示副刻度 callbacks : matplotlib.cbook.CallbackRegistry label : .Text,坐标轴标签 labelpad : float,坐标轴标签和坐标轴的距离 offsetText : .Text majorTicks : list of .Tick,主刻度列表 minorTicks : list of .Tick,副刻度列表 你可以通过下面的函数修改坐标轴label和labelpad,实际上调用的函数均为ax.xaxis.label.set_text和ax.xaxis.label.update的封装 ax.set_xlabel(xlabel:str,fontdict=None:str,labelpad=None:float,*,loc=None:str, **kwargs) ax.xaxis.set_label_text(label:str,fontdict:dict,**kwargs) [info] loc loc =['center','left','right]' [info] fontdict import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xlabel(\"nihao\",labelpad=10,loc=\"right\") plt.show() Ticker 刻度 设置刻度线边界set_xbound实际上调用的就是`set_xlim ax.set_xlim ax.set_xbound left : float, right : float, emit : bool, default: True,是否通知observers界限的改变 auto : bool or None, default: False,是否打开axis的autoscaling xmin, xmax : float, optional,等同与left和right但是不能同时传递 示例 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xlim(1,2) ax.plot(x) plt.show() 设置主要刻度线的位置和显示文本 ax.set_xticks ax.set_xticklabels import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.plot(x) ax.xaxis.offsetText.set_text(\"Custom Text\") ax.set_xticks([1,2,3,4]) ax.set_xticklabels(['a','b','c','d']) plt.show() 设置刻度线的尺度,支持'log','linear','logit','symlog' ax.set_xscale('log') 设置刻度线 ax.set_tick_params() ax.xaxis.set_tick_params() axis:指定要设置的坐标轴,可以是 'x'、'y' 或 'both'(xaxis无）。 which:指定要设置的刻度线,可以是 'major'、'minor' 或 'both'。 direction:指定刻度线的方向,可以是 'in'、'out' 或 'inout'。 length:指定刻度线的长度。 width:指定刻度线的宽度。 color:指定刻度线的颜色。 pad:指定刻度标签与刻度线之间的间距。 labelsize:指定刻度标签的字体大小。 labelcolor:指定刻度标签的颜色。 bottom、top、left、right:指定是否显示底部、顶部、左侧、右侧的刻度线。 labelbottom、labeltop、labelleft、labelright import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.plot(x) ax.xaxis.set_tick_params(which='major', width=2, length=10) plt.show() Ticker有两个属性,当然通常情况下我们不需要操作底层的这两个属性,要详细的设置可以参考下面的例子 _locator : matplotlib.ticker.Locator 决定刻度的位置 _formatter : matplotlib.ticker.Formatter 决定刻度的格式 axis中包含两个Ticker,major和minor,分别表示主刻度和副刻度,你可以通过下面的函数获取这些属性 ax.xaxis.get_major_locator ax.xaxis.set_major_locator ax.xaxis.get_major_formatter ax.xaxis.set_major_locator ... 简单的使用formatter ax0.xaxis.set_major_formatter('{x} km') ax1.xaxis.set_major_formatter(lambda x, pos: str(x-5)) locator 坐标位置控制器 Locator 支持下面这些类（注:默认情况下小刻度处于关闭状态（使用NullLocator和NullFormatter）） FixedLocator:根据固定位置列表生成刻度。 AutoLocator:根据数据范围和轴长度自动计算刻度位置。 MultipleLocator:在指定基准刻度间隔的倍数上生成刻度。 MaxNLocator:根据指定的最大刻度数量自动计算刻度位置。 LogLocator:在对数刻度上生成刻度。 IndexLocator:根据指定的索引间隔生成刻度。 DateLocator:在日期轴上生成刻度。 比如下面的例子 def setup(ax, title): \"\"\"Set up common parameters for the Axes in the example.\"\"\" # only show the bottom spine ax.yaxis.set_major_locator(ticker.NullLocator()) ax.spines[['left', 'right', 'top']].set_visible(False) ax.xaxis.set_ticks_position('bottom') ax.tick_params(which='major', width=1.00, length=5) ax.tick_params(which='minor', width=0.75, length=2.5) ax.set_xlim(0, 5) ax.set_ylim(0, 1) ax.text(0.0, 0.2, title, transform=ax.transAxes, fontsize=14, fontname='Monospace', color='tab:blue') fig, axs = plt.subplots(8, 1, layout='constrained') # Null Locator setup(axs[0], title=\"NullLocator()\") axs[0].xaxis.set_major_locator(ticker.NullLocator()) axs[0].xaxis.set_minor_locator(ticker.NullLocator()) # Multiple Locator setup(axs[1], title=\"MultipleLocator(0.5)\") axs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5)) axs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1)) # Fixed Locator setup(axs[2], title=\"FixedLocator([0, 1, 5])\") axs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5])) axs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4))) # Linear Locator setup(axs[3], title=\"LinearLocator(numticks=3)\") axs[3].xaxis.set_major_locator(ticker.LinearLocator(3)) axs[3].xaxis.set_minor_locator(ticker.LinearLocator(31)) # Index Locator setup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\") axs[4].plot(range(0, 5), [0]*5, color='white') axs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25)) # Auto Locator setup(axs[5], title=\"AutoLocator()\") axs[5].xaxis.set_major_locator(ticker.AutoLocator()) axs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator()) # MaxN Locator setup(axs[6], title=\"MaxNLocator(n=4)\") axs[6].xaxis.set_major_locator(ticker.MaxNLocator(4)) axs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40)) # Log Locator setup(axs[7], title=\"LogLocator(base=10, numticks=15)\") axs[7].set_xlim(10**3, 10**10) axs[7].set_xscale('log') axs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15)) plt.show() formatter 坐标格式控制器 Formatter支持下面这些类 StrMethodFormatter:使用字符串的格式方法进行格式化,可以使用类似于 '{}'.format 的格式字符串。 FuncFormatter:使用用户定义的函数进行格式化,函数接受刻度值为参数,返回格式化后的字符串。 ScalarFormatter:对刻度值进行标量格式化,可以指定刻度值的精度、科学计数法等。 FormatStrFormatter:使用格式字符串进行格式化,可以使用类似于 '%.2f' 的格式字符串。 LogFormatter:对对数刻度的刻度标签进行格式化。 PercentFormatter:将刻度值转换为百分比格式。 def setup(ax, title): \"\"\"Set up common parameters for the Axes in the example.\"\"\" # only show the bottom spine ax.yaxis.set_major_locator(ticker.NullLocator()) ax.spines[['left', 'right', 'top']].set_visible(False) # define tick positions ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00)) ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25)) ax.xaxis.set_ticks_position('bottom') ax.tick_params(which='major', width=1.00, length=5) ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10) ax.set_xlim(0, 5) ax.set_ylim(0, 1) ax.text(0.0, 0.2, title, transform=ax.transAxes, fontsize=14, fontname='Monospace', color='tab:blue') fig = plt.figure(figsize=(8, 8), layout='constrained') fig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5]) fig0.suptitle('String Formatting', fontsize=16, x=0, ha='left') ax0 = fig0.subplots() setup(ax0, title=\"'{x} km'\") ax0.xaxis.set_major_formatter('{x} km') fig1.suptitle('Function Formatting', fontsize=16, x=0, ha='left') ax1 = fig1.subplots() setup(ax1, title=\"def(x, pos): return str(x-5)\") ax1.xaxis.set_major_formatter(lambda x, pos: str(x-5)) fig2.suptitle('Formatter Object Formatting', fontsize=16, x=0, ha='left') axs2 = fig2.subplots(7, 1) setup(axs2[0], title=\"NullFormatter()\") axs2[0].xaxis.set_major_formatter(ticker.NullFormatter()) setup(axs2[1], title=\"StrMethodFormatter('{x:.3f}')\") axs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:.3f}\")) setup(axs2[2], title=\"FormatStrFormatter('#%d')\") axs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter(\"#%d\")) def fmt_two_digits(x, pos): return f'[{x:.2f}]' setup(axs2[3], title='FuncFormatter(\"[{:.2f}]\".format)') axs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits)) setup(axs2[4], title=\"FixedFormatter(['A', 'B', 'C', 'D', 'E', 'F'])\") # FixedFormatter should only be used together with FixedLocator. # Otherwise, one cannot be sure where the labels will end up. positions = [0, 1, 2, 3, 4, 5] labels = ['A', 'B', 'C', 'D', 'E', 'F'] axs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions)) axs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels)) setup(axs2[5], title=\"ScalarFormatter()\") axs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True)) setup(axs2[6], title=\"PercentFormatter(xmax=5)\") axs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5)) 添加画件 正如前文所描述的那样,matplotlib通过画布-画区-画件的方式管理绘制内容,当你手动添加画区到画布上时,画区已经自带了Spines和Xaxis/Yaxis、Ticker这些基本画件,你还可以自由的添加其他的画件Artist,常见的添加函数见下方。(注:Artist是任意画件包括Figure、Axes的基类） add_artist() 可以添加任意类型的可绘制对象到图形容器中（Artist） add_patch() 用于添加基本的图形元素。(Pathc,Rectangle) add_line(): 向 Axes 对象添加线条对象 (Line2D)。 add_collection(): 向 Axes 对象添加集合对象 (Collection),如散点图 (Scatter)、柱状图 (Bar) 等。 add_table(): 向 Axes 对象添加表格对象 (Table)。 add_text(): 向 Axes 对象添加文本对象 (Text)。 add_image(): 向 Axes 对象添加图像对象 (AxesImage)。 add_axes(): 向 Figure 对象添加新的坐标系 (Axes)。 add_colorbar(): 向 Figure 或 Axes 对象添加颜色条 add_collection3d(): 向 Axes3D 对象添加集合对象 同时你也可以用getp函数获取任意画件可以设置的属性 import matplotlib.artist as martist line_properties = martist.getp(line) print(line_properties) 画件属性与基类 在详细的介绍画件之前,我想先介绍一下通用的属性的设定方式和基本类别属性。 color - 颜色色 属性 [info] color属性 指定颜色的方式有三种 str:g或者green或者C0 'b'/C0 blue 'g'/C1 green 'r'/C2 red 'c'/C3 cyan 'm'/C4 magenta 'y'/C5 yellow 'k'/C6 black 'w'/C7 white tuple: (R,G,B)/(R,G,B,A)元祖,比如(2,34,44),(2,34,44,0.5) str:十六进制字符串,'#008000' marker - 点形 属性 [info]Markers ============= =============================== character description ============= =============================== ``'.'`` point marker ``','`` pixel marker ``'o'`` circle marker ``'v'`` triangle_down marker ``'^'`` triangle_up marker ``''`` triangle_right marker ``'1'`` tri_down marker ``'2'`` tri_up marker ``'3'`` tri_left marker ``'4'`` tri_right marker ``'8'`` octagon marker ``'s'`` square marker ``'p'`` pentagon marker ``'P'`` plus (filled) marker ``'*'`` star marker ``'h'`` hexagon1 marker ``'H'`` hexagon2 marker ``'+'`` plus marker ``'x'`` x marker ``'X'`` x (filled) marker ``'D'`` diamond marker ``'d'`` thin_diamond marker ``'|'`` vline marker ``'_'`` hline marker ============= =============================== linestyle - 线形 属性 Line Styles ============= =============================== character description ============= =============================== ``None``. 关闭绘制线 ``'-'`` solid line style ``'--'`` dashed line style ``'-.'`` dash-dot line style ``':'`` dotted line style ============= =============================== Hatch - 填充 属性 hatch属性接受以下常见的填充样式： '/'：斜线填充 '\\'：反斜线填充 '|'：垂直线填充 '-'：水平线填充 '+'：十字线填充 'x'：X字线填充 'o'：圆圈填充 'O'：大圆圈填充 '.'：点填充 import matplotlib.pyplot as plt # 创建一个简单的条形图 x = ['A', 'B', 'C', 'D'] y = [3, 7, 2, 5] plt.bar(x, y, hatch='///') # 显示图形 plt.show() .Text - 文本 基类 .Text 对象的属性 fontfamily/family/fontname:str,字体,内置有{'serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'} fontvariant/variant :{'normal', 'small-caps'} fontstretch/stretch: 宽度，0-1000/{'ultra-condensed'：超窄，'extra-condensed'：非常窄，'condensed'：窄，'semi-condensed'：半窄，'normal'：正常，'semi-expanded'：半宽，'expanded'：宽，'extra-expanded'：非常宽，'ultra-expanded'：超宽} fontstyle :正常（normal）、斜体（italic）、粗体（bold） fontweight/weight：字体粗细，0-1000/{'ultralight', 'light','normal','regular','book','medium','roman', 'semibold','demibold','demi','bold','heavy','extra 'bold', 'black'} fontsize or size:float or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'} backgroundcolor:背景色 color:颜色 verticalalignment/va:str垂直对齐方式,可选值包括 'top'、'bottom'、'center'、'baseline' 等。 horizontalalignment/ha:str水平对齐方式,可选值包括 'left'、'right'、'center' 等。 multialignment:str多行文本的对齐方式,可选值包括 'left'、'right'、'center' 等。 wrap:bool,是否在文本过长时自动换行。 linespacing:float,多行文本的行距。 usetex:bool,是否使用 TeX 渲染文本。 rotation:float,文本的旋转角度。 rotation_mode:str,旋转模式,可选值包括 'default'、'anchor'。 transform_rotates_text:bool,是否根据坐标轴的变换来旋转文本。 parse_math:bool是否解析数学表达式。 url:超链接Line2D - 点线 Line2D必须需要输入的数据 xdata:绘制线条的 x 坐标数据,一个float序列。 ydata:绘制线条的 y 坐标数据,一个float序列。 Line2D对象由点marker和线line组成,支持的属性值如下:linewidth,linestyle,color,marker,markersize,markeredgewidth,markeredgecolor,markerfacecolor,markerfacecoloralt dash_capstyle/solid_capstyle:设置虚线/实线CapStyle dash_joinstyle/solid_joinstyle:设置虚线/实线Joinstyle antialiased:线条是否进行抗锯齿渲染,一个bool,默认为 None。 fillstyle:线条上数据点标记的填充样式,一个字符串,默认为 None。通常情况下marker为None,因此不会绘制数据点,设置绘制数据点后可以起作用 import matplotlib.pyplot as plt import numpy as np # 创建一个简单的图形 fig, ax = plt.subplots() # 创建示例数据 x = np.linspace(0, 2*np.pi, 10) y = np.sin(x) # 绘制线条 ax.plot(x, y,'o' ,fillstyle='none', label='none') ax.plot(x, y-0.5, 'o', fillstyle='full', label='full') ax.plot(x, y-1, 'o', fillstyle='left', label='left') ax.plot(x, y-1.5, 'o', fillstyle='right', label='right') ax.plot(x, y-2, 'o', fillstyle='bottom', label='bottom') ax.plot(x, y-2.5, 'o', fillstyle='top', label='top') # 添加图例 ax.legend() plt.show() [info] CapStyle 'butt:线条端点为平直的方形,不延伸过线条的末端。 'round:线条端点为圆形。 'projecting':线条端点为方形,延伸过线条的末端。 [info] JoinStyle miter:连接点为尖角。 round:连接点为圆角。 bevel:连接点为平直的斜角 drawstyle [info] drawstyle \"default\":默认绘制方式,线条将按照给定的坐标点顺序进行插值和绘制 \"steps\":绘制阶梯线条,线条会在每个坐标点之间垂直或水平连接,形成阶梯状的线条。 \"steps-pre\":与 \"steps\" 类似,但是线条是从前一个坐标点开始绘制的。 \"steps-mid\":与 \"steps\" 类似,但是线条是从当前坐标点的中间位置开始绘制的。 \"steps-post\":与 \"steps\" 类似,但是线条是从当前坐标点结束位置开始绘制的。 Text - 文本 Text的属性，其他属性见.Text x/y:float,文本的位置坐标,分别表示 x 和 y 轴上的值。 text:str文本内容。 bbox:dict,外框属性，是一个Rectangle import matplotlib.pyplot as plt # 创建一个文本框并设置样式 text = plt.text(0.5, 0.5, 'Hello, World!', bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.5')) # 显示图形 plt.show() 下面是一个简单的示例 import matplotlib.pyplot as plt from matplotlib.pyplot import Text # 创建图表和坐标轴 fig, ax = plt.subplots() # 添加文本标签 text1 = Text(0.4, 0.4, 'Hello, World!', fontsize=12, color='red') text2 = plt.Text(0.1, 0.4, 'Hello, World!') ax.add_artist(text1) ax.add_artist(text2) plt.show() Annotation - 带箭头文本 Annotation继承了Text,是一个带有箭头的Text - `text:注释的文本内容。 - xy:注释目标点的坐标。可以是一个二元元组 (x, y),表示数据坐标,或者是一个字符串,表示坐标轴上的特殊位置,如 'center'、'top'、'bottom' 等。 - xytext:注释文本的位置坐标。如果为 None,则默认与 xy 相同。 - xycoords:注释目标点的坐标系。可选值包括 'data'、'axes fraction'、'figure fraction' 等。 - textcoords:注释文本的坐标系。如果为 None,则默认与 xycoords 相同。 - arrowprops:一个字典,包含箭头的属性设置,用于在注释目标点和注释文本之间绘制箭头。常用的属性包括 'arrowstyle'（箭头样式）、'arrowcolor'（箭头颜色）、'connectionstyle'（连接线样式）等。 - annotation_clip:是否将注释裁剪到图表区域。如果为 None,则默认使用 rcParams['annotation.clip'] 的值。 基本示例如下 import matplotlib.pyplot as plt from matplotlib.text import Annotation # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建Annotation实例 annotation = Annotation(\"Important Point\", xy=(0.5, 0.5), xytext=(0.2, 0.8), arrowprops=dict(arrowstyle='->')) # 将Annotation添加到Axes实例 ax.add_artist(annotation) # 设置坐标轴范围 ax.set_xlim(0, 1) ax.set_ylim(0, 1) # 显示图表 plt.show() Patch - 边 Patch是一个基类,不能够直接使用,可以使用它的子类,具有的基本属性有edgecolor,facecolor,antialiased,hatch,fill,capstyle,joinstyle Rectangle - 矩形 指定的参数有 xy : (float, float) width : float height : float angle : float rotation_point : {'xy', 'center', (number, number)} args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建矩形对象 rect = patches.Rectangle((0.2, 0.3), 0.5, 0.4, edgecolor='red', facecolor='blue', linewidth=2) # 添加矩形对象到图表 ax.add_patch(rect) plt.show() Circle - 圆形 支持的参数如下 xy:圆心坐标 radius:圆半径 args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建圆形对象 circle = patches.Circle((0.5, 0.5), radius=0.2, edgecolor='red', facecolor='blue', linewidth=2) # 添加圆形对象到图表 ax.add_patch(circle) plt.axis('equal') plt.show() Polygon - 多边形 *(x,y):提供顶点 close:bool args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建多边形对象 polygon = patches.Polygon([(0.2, 0.2), (0.5, 0.7), (0.8, 0.2)], edgecolor='red', facecolor='blue', linewidth=2) # 添加多边形对象到图表 ax.add_patch(polygon) plt.axis('equal') plt.show() Ellipse - 椭圆 xy:圆心坐标 width:横轴长 height:纵轴长 angle:角度 args:Patch支持的参数 Wedge - 扇形 center:扇形的中心点坐标。 r:扇形的半径。 theta1:起始角度（以度为单位）。 theta2:结束角度（以度为单位）。 args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建扇形对象 wedge = patches.Wedge((0.5, 0.5), 0.4, 30, 180, edgecolor='red', facecolor='blue', linewidth=2) # 添加扇形对象到图表 ax.add_patch(wedge) plt.axis('equal') plt.show() Arrow - 箭头 x : float,尾部坐标 y : float,尾部坐标 dx : float,箭头x方向长度 dy : float,箭头y方向长度 width : float, default: 1 args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建箭头对象 arrow = patches.Arrow(0.2, 0.2, 0.4, 0.4, width=0.1, edgecolor='red', facecolor='blue') # 添加箭头对象到图表 ax.add_patch(arrow) plt.axis('equal') plt.show() FancyArror - 装饰性箭头 和Arrow类似,但是多了一些可以控制的参数 length_includes_head:bool,如果为 True,则在计算长度时包括箭头的长度。如果为 False,则仅计算箭头起点到箭头尖端的长度,默认为 False。 head_width:float或 None,默认值为 3 * width,其中 width 是箭头主干的宽度。箭头头部的总宽度。如果未指定,将根据主干宽度自动计算。 head_length:float或 None,默认值为 1.5 * head_width。箭头头部的长度。如果未指定,将根据头部宽度自动计算。 shape:字符串,可选值为 'full'、'left' 或 'right',默认为 'full'。指定箭头的形状。'full' 表示完整箭头,'left' 表示左半箭头,'right' 表示右半箭头。 overhang:folat,表示箭头的倾斜程度。取值范围可以是负数（表示箭头向后倾斜）或大于 1（表示箭头向前倾斜）。默认值为 0,表示箭头为三角形形状。 head_starts_at_zero:bool,如果为 True,则箭头从坐标 0 开始绘制,而不是在坐标 0 结束。默认为 False。Legend - 小标题 几乎每一个Artist（包括Figure、Axes、Line2D等等）都有一个属性叫label（注意和title区分，title是标题，后者为标记文本），当你启动legend时，lable才会起作用 ax.legend参数如下 handles : sequence of .Artist, labels : list of str, optional 有四种使用方式legend():自动检测每个Artist的label legend(handles, labels):绘制给定handles所代表的Artist为对应给定labels legend(handles=handles):绘制给定handles所代表的Artist设定的label legend(labels):按照Artist添加的顺序绘制labels import matplotlib.pyplot as plt import matplotlib.patches as mpatches fig, ax = plt.subplots() red_patch = mpatches.Patch(color='red', label='The red data') ax.legend(handles=[red_patch]) plt.show() Path - 路径 所有matplotlib.patches对象是采用Path绘制的,Path移动方式为位置点-动作方式,支持的动作方式如下 STOP:路径段落类型,表示路径的结束。 MOVETO:路径段落类型,表示移动到一个新的位置,只有一个顶点。 LINETO:路径段落类型,表示绘制一条直线,只有一个顶点。 CURVE3:路径段落类型,表示绘制一个三次贝塞尔曲线,需要两个顶点（起点和终点）。 CURVE4:路径段落类型,表示绘制一个四次贝塞尔曲线,需要三个顶点（起点、控制点和终点）。 CLOSEPOLY:路径段落类型,表示闭合路径,只有一个顶点（起点和终点重合） import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.path import Path # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建路径对象 path_data = [ (Path.MOVETO, [0.2, 0.2]), (Path.LINETO, [0.4, 0.5]), (Path.CURVE3, [0.6, 0.4]), (Path.CURVE3, [0.8, 0.8]), (Path.CLOSEPOLY, [0.2, 0.2]) ] path_codes, path_verts = zip(*path_data) path = Path(path_verts, path_codes) # 创建路径补丁对象 path_patch = patches.PathPatch(path, edgecolor='red', facecolor='blue', linewidth=2) # 添加路径补丁对象到图表 ax.add_patch(path_patch) plt.axis('equal') plt.show() Collection Scatter - 散点图 Scatter必须输入 `x, y` :两个一维数组 支持输入单个下面的属性或者同x，y形状相同的数组 alpha,linewidths,marker,s,c ,linestyle,edgecolors edgecolors : 支持'face', 'none',本别表示同face或者不绘制 支持和点相关的所有参数 import numpy as np import matplotlib.pyplot as plt # 创建网格数据 x = np.linspace(0, 1, 10) y = np.linspace(0, 3, 10) plt.scatter(x,y,s = x*100,c = y,edgecolors='r',marker='p') plt.show() pcolormesh - 伪色彩图 X:二维数组,表示网格数据的 x 坐标。 Y:二维数组,表示网格数据的 y 坐标。 C:二维数组,表示网格数据的颜色值。 cmap:str,颜色映射,用于确定颜色值与颜色的映射关系。默认为 None,使用默认的颜色映射。 vmin 和 vmax:指定颜色值的范围,用于控制颜色填充的范围。默认为 None,自动根据数据的最小值和最大值确定范围。 import numpy as np import matplotlib.pyplot as plt # 创建网格数据 x = np.linspace(0, 1, 10) y = np.linspace(0, 1, 10) X, Y = np.meshgrid(x, y) Z = np.random.rand(10, 10) # 随机生成一个 10x10 的颜色值数组 # 绘制伪彩色图 a = plt.pcolormesh(X, Y, Z, cmap='viridis') # 添加颜色刻度条 plt.colorbar() # 显示图表 plt.show() 封装函数 下面是一些常用的针对添加画件的封装函数 annotate - Annotation bar - Rectangle errorbar - Line2D and Rectangle fill - Polygon hist - Rectangle imshow - AxesImage legend - Legend plot - Line2D scatter - PathCollection text - Text 实际上ax.plot(x,y)等同于 from matplotlib.lines import Line2D line = Line2D(x,y) ax.add_artist(line) 当你手动添加画件后Figure和Axes并不会自动的调整显示,而上面的封装函数包含了对显示的调整当然你也可以主动启动调整函数 fig.tight_layout(): 调整图形中的子图、标签和边界的布局,以确保它们适合图形区域。 fig.subplots_adjust(): 手动调整子图的位置和间距 ax.relim(): 重新计算坐标轴限制,以适应添加的 Artist 对象。 ax.autoscale_view(): 自动调整坐标轴的视图,以适应添加的 Artist 对象。 ax.autoscale(): plot - Line2D plot的封装还支持更多的功能,比如fmt,data,或者同时绘制两个Line2D plot([x], y, [fmt], *, data=None, **kwargs) plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs) format = '[marker][line][color]' plot(x, y, 'bo') #绘制蓝色线条圆圈标记 x/y是类型数组的数据,可以·和data联合起来支持dict、pandas.DataFrame np.random.seed(19680801) # seed the random number generator. data = {'a': np.arange(50), 'c': np.random.randint(0, 50, 50), 'd': np.random.randn(50)} data['b'] = data['a'] + 10 * np.random.randn(50) data['d'] = np.abs(data['d']) * 100 ax.scatter('a', 'b', c='c', s='d', data=data) imshow - AxesImage import matplotlib.pyplot as plt import matplotlib.image as mpimg # 读取图像文件 image = mpimg.imread('path/to/image.jpg') # 创建图形和坐标轴 fig, ax = plt.subplots() # 在坐标轴上显示图像 img = ax.imshow(image) # 显示图形界面 plt.show() 进阶玩法 Cycler - 颜色循环器 matplotlib会自动使用Cycler为你绘制的画件赋予颜色 default_cycler = plt.rcParams['axes.prop_cycle'] # 输出默认样式属性 print(default_cycler) 你也可以创建你自己的Cycler import matplotlib.pyplot as plt from cycler import cycler x = [0, 1, 2, 3, 4] y1 = [0, 1, 0, 2, 1] y2 = [1, 2, 1, 0, 1] # 定义循环器 styles = cycler('color', ['red', 'green', 'blue']) + cycler('linestyle', ['-', '--', ':']) fig, ax = plt.subplots() # 应用循环器样式到线条 ax.plot(x, y1, label='Line 1', **next(styles)) ax.plot(x, y2, label='Line 2', **next(styles)) ax.legend() plt.show() 或者修改配置 plt.rc('axes', prop_cycle=default_cycler) Simplyfy - 简化 patheffects - 路径效果 前文提到,所有对象的底层对象matplotlib.patches是Path,那么他们都可以使用path_effects这个属性来调整显示效果。 import matplotlib.patheffects as path_effects text = plt.text(0.5, 0.5, 'Hello path effects world!', path_effects=[path_effects.withSimplePatchShadow()]) plt.plot([0, 3, 2, 5], linewidth=5, color='blue', path_effects=[path_effects.SimpleLineShadow(), path_effects.Normal(),path_effects.withTickedStroke()]) plt.show() AbstractPathEffect是所有PathEffect的基类唯一的属性是 offset:(x,y)表示偏移 PathPatchEffect - 基础样式 基础样式,可以任意设定,并且可以叠加 import numpy as np import matplotlib.pyplot as plt fig = plt.figure(figsize=(8.5, 1)) t = fig.text(0.02, 0.5, 'Hatch shadow', fontsize=75, weight=1000, va='center') t.set_path_effects([ path_effects.PathPatchEffect( offset=(4, -4), hatch='xxxx', facecolor='gray'), path_effects.PathPatchEffect( edgecolor='white', linewidth=1.1, facecolor='black')]) plt.show() SimpleLineShadow - 阴影样式 适用于Line2D,如直线、曲线等 offset:(x,y)表示偏移 shadow_color:阴影颜色 alpha:float,透明度 rho:float,shadow_color 为 None 时,rho 参数可以用于调整 rgbFace 颜色的亮度或饱和度SimplePatchShadow - 阴影样式 适用于路径对象,如矩形、圆形等,参数同SimpleLineShadowStroke - 重绘样式 接受gc_kw参数,相当于重新指定样式Normal - 原始样式 绘制原始样式TickedStroke - 刻度样式 添加刻度线 offset angle:刻度线的角度,以度为单位。默认值为 45.0。 length:刻度线的长度。默认值为 3。 spacing:刻度线之间的间距。默认值为 5。 length : 长度,默认为1.414transform 坐标变化 在matplotlib中有四种基本坐标,你可以使用前三者,使用转化函数转化为实际显示的像素坐标,转化函数还有一个invert的反向转化 | | | | 转化函数 | |----------|------------------|-----------------------------|:-------------| | 数据坐标 | 按照x,y轴定位 | （12,12） | ax.transData | | 相对坐标 | 按照相对大小定位 | （0.1,0.2） | ax.transAxes,subfigure.transSubfigure,fig.transFigure | | 物理坐标 | 按照实际尺寸定位 | （2/72,2/72）默认单位为（inch） | fig.dpi_scale_trans | | 显示坐标 | 按照像素点定位 | （368,459） | | In [15]: ax.transData.transform((5, 0)) Out[15]: array([ 335.175, 247. ]) In [16]: ax.transData.transform([(5, 0), (1, 2)]) Out[16]: array([[ 335.175, 247. ], [ 132.435, 642.2 ]]) In [41]: inv = ax.transData.inverted() In [43]: inv.transform((335.175, 247.)) Out[43]: array([ 5., 0.]) x = np.arange(0, 10, 0.005) y = np.exp(-x/2.) * np.sin(2*np.pi*x) fig, ax = plt.subplots() ax.plot(x, y) ax.set_xlim(0, 10) ax.set_ylim(-1, 1) xdata, ydata = 5, 0 # This computing the transform now, if anything # (figure size, dpi, axes placement, data limits, scales..) # changes re-calling transform will get a different value. xdisplay, ydisplay = ax.transData.transform((xdata, ydata)) bbox = dict(boxstyle=\"round\", fc=\"0.8\") arrowprops = dict( arrowstyle=\"->\", connectionstyle=\"angle,angleA=0,angleB=90,rad=10\") offset = 72 ax.annotate(f'data = ({xdata:.1f}, {ydata:.1f})', (xdata, ydata), xytext=(-2*offset, offset), textcoords='offset points', bbox=bbox, arrowprops=arrowprops) disp = ax.annotate(f'display = ({xdisplay:.1f}, {ydisplay:.1f})', (xdisplay, ydisplay), xytext=(0.5*offset, -offset), xycoords='figure pixels', textcoords='offset points', bbox=bbox, arrowprops=arrowprops) plt.show() Blended transformations - 混合坐标变化 通过transforms.blended_transform_factory创建混合变化,x坐标被解析为ax.transData,y坐标被解析为ax.transAxes,比如起点（1,0）即为x坐标为1,y位于0%处,x宽为坐标轴长1,y为整个区域100% import matplotlib.transforms as transforms import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() trans = transforms.blended_transform_factory( ax.transData, ax.transAxes) rect = mpatches.Rectangle((1, 0), width=1, height=1, transform=trans, color='yellow', alpha=0.5) ax.add_patch(rect) ax.set_ylim(2,800) ax.set_xlim(0,3) plt.show() 实际上x,y坐标的解析就是混合坐标变化 ax.get_xaxis_transform(), ax.get_yaxis_transform() ScaledTranslation - 偏移坐标变换 class matplotlib.transforms.ScaledTranslation(xt, yt, scale_trans,...) 下面的圆首先被fig.dpi_scale_trans转化,圆心在（0,0）,然后偏移到（0.2,0.7）,注意顺序很重要 import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() xdata, ydata = (0.2, 0.7), (0.5, 0.5) ax.plot(xdata, ydata, \"o\") ax.set_xlim((0, 1)) trans = (fig.dpi_scale_trans + transforms.ScaledTranslation(xdata[0], ydata[0], ax.transData)) # plot an ellipse around the point that is 150 x 130 points in diameter... circle = mpatches.Ellipse((0, 0), 150/72, 130/72, angle=40, fill=None, transform=trans) ax.add_patch(circle) plt.show() 还可以创建阴影 import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() # make a simple sine wave x = np.arange(0., 2., 0.01) y = np.sin(2*np.pi*x) line, = ax.plot(x, y, lw=3, color='blue') # shift the object over 2 points, and down 2 points dx, dy = 2/72., -2/72. offset = transforms.ScaledTranslation(dx, dy, fig.dpi_scale_trans) shadow_transform = ax.transData + offset # now plot the same data with our offset transform; # use the zorder to make sure we are below the line ax.plot(x, y, lw=3, color='gray', transform=shadow_transform, zorder=0.5*line.get_zorder()) ax.set_title('creating a shadow effect with an offset transform') plt.show() 后端配置 后端分为内置后端、拓展后端，静态后端、交互式后端。拓展后端的名称为 类似'module://matplotlib_inline.backend_inline' #查看后端 plt.get_backend() #修改后端 plt.rcParams[\"backend\"] = 'agg1 matplotlib.use('qtagg') 修改配置文件 默认支持的静态后端 ['agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template'] 默认支持的交互式后端 ['GTK3Agg', 'GTK3Cairo', 'GTK4Agg', 'GTK4Cairo', 'MacOSX', 'nbAgg', 'QtAgg', 'QtCairo', 'Qt5Agg', 'Qt5Cairo', 'TkAgg', 'TkCairo', 'WebAgg', 'WX', 'WXAgg', 'WXCairo'] jupyter拓展后端 jupyter有三个拓展后端，第一个默认，为静态后端，后两个交互式后端需要安装ipympl %matplotlib inline(默认）-'module://matplotlib_inline.backend_inline' %matplotlib ipympl-'module://ipympl.backend_nbagg' %matplotlib widget-'module://ipympl.backend_nbagg' 如果想在ipynb中使用交互式后端，安装ipympl pip install ipympl conda install ipympl -c conda-forge 动态绘图 Animation - 动画 Animation提供两个函数FuncAnimation和ArtistAnimation，前者按照给定函数不断改变Artist的数据，后者按照给定的Artist列表进行迭代。 FuncAnimation FuncAnimation必须指定的参数如下 fig：画布 func：更新函数 frames：总帧数 interval：帧间隔 支持的参数如下：repeat：bool，repeat_delay:int import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() t = np.linspace(0, 3, 40) g = -9.81 v0 = 12 z = g * t**2 / 2 + v0 * t v02 = 5 z2 = g * t**2 / 2 + v02 * t scat = ax.scatter(t[0], z[0], c=\"b\", s=5, label=f'v0 = {v0} m/s') line2 = ax.plot(t[0], z2[0], label=f'v0 = {v02} m/s')[0] ax.set(xlim=[0, 3], ylim=[-4, 10], xlabel='Time [s]', ylabel='Z [m]') ax.legend() def update(frame): # for each frame, update the data stored on each artist. x = t[:frame] y = z[:frame] # update the scatter plot: data = np.stack([x, y]).T scat.set_offsets(data) # update the line plot: line2.set_xdata(t[:frame]) line2.set_ydata(z2[:frame]) return (scat, line2) ani = animation.FuncAnimation(fig=fig, func=update, frames=40, interval=30) plt.show() ArtistAnimation import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() rng = np.random.default_rng(19680801) data = np.array([20, 20, 20, 20]) x = np.array([1, 2, 3, 4]) artists = [] colors = ['tab:blue', 'tab:red', 'tab:green', 'tab:purple'] for i in range(20): data += rng.integers(low=0, high=10, size=data.shape) container = ax.barh(x, data, color=colors) artists.append(container) ani = animation.ArtistAnimation(fig=fig, artists=artists, interval=400) plt.show() writer 支持图片、HTML、视频、Gif等等 Pillow writers: ani.save(filename=\"/tmp/pillow_example.gif\", writer=\"pillow\") ani.save(filename=\"/tmp/pillow_example.apng\", writer=\"pillow\") HTML writers: ani.save(filename=\"/tmp/html_example.html\", writer=\"html\") ani.save(filename=\"/tmp/html_example.htm\", writer=\"html\") ani.save(filename=\"/tmp/html_example.png\", writer=\"html\") FFMpegWriter: ani.save(filename=\"/tmp/ffmpeg_example.mkv\", writer=\"ffmpeg\") ani.save(filename=\"/tmp/ffmpeg_example.mp4\", writer=\"ffmpeg\") ani.save(filename=\"/tmp/ffmpeg_example.mjpeg\", writer=\"ffmpeg\") Imagemagick writers: ani.save(filename=\"/tmp/imagemagick_example.gif\", writer=\"imagemagick\") ani.save(filename=\"/tmp/imagemagick_example.webp\", writer=\"imagemagick\") ani.save(filename=\"apng:/tmp/imagemagick_example.apng\", writer=\"imagemagick\", extra_args=[\"-quality\", \"100\"]) 首先先建立一个基本概念,交互模式与非交互模式 pyplot.ion:打开交互模式 pyplot.ioff:关闭交换模式 pyplot.isinteractive:查看是否为交互模式 pyplot.show:显示所有绘图 pyplot.pause:显示一段时间 事件管理 见文章 ax.cla() fig.clf() ax.cla() fig.canvas.draw_idle() fig.canvas.flush_events() "}}