{"./":{"url":"./","title":"Introduction","keywords":"","body":"teamteee.github.io 这里是Teamtee的博客，我希望记录我的生活、学习和思考！欢迎各位来访问。 "},"Gitbook Explore in Mac/":{"url":"Gitbook Explore in Mac/","title":"Gitbook Explore in Mac","keywords":"","body":"[Mac] Gitbook in Mac 最近一直在思考如何学习 ，其中很重要的一环是输出。我曾经使用过语雀、思云等等，尽管它们功能丰富并且支持云端，但是对于像一本书一样阅读，这样的要求是达不到的，因此我选择了Gitbook + Githubpages 一、简单使用 Gitbook有网页版和本地版两种，网页版的功能感觉和语雀等类似，因此我选择本地版。你可以将本地版Gitbook（以下简称Gitbook）认为是一个工具链，这个工具链依赖于Node.js和npm。在mac的教程如下，windos还未尝试 1.安装 brew 在mac下需要先安装开发者工具brew,brew是一个类似apt、yum的包管理工具 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 安装完后命令行输入brew检查是否成功安装 npm 安装完brew后利用brew安装npm，npm是一个Node.js的包管理工具。我们需要用它来安装gitbook。 brew install npm 输入npm -v检查是否安装成功 nvm nvm也是Node.js的版本管理工具，类似Python里面的conda。我们需要用它来管理Node.js的版本。 brew install nvm 输入nvm -v检查是否安装成功 gitbook 使用brew安装gitbook.-g选项的意思安装在全局，否则默认为安装在用户下。 brew install gitbook-cli -g 2.使用 初始化 选择一个你希望的空文件夹，初始化工作目录 # 初始化工作目录会生成 README.md 和 SUMMARY.md gitbook init # 构建工作会默认在 _book 下生成文件 gitbook build # 服务器会构建本地端口映射 gitbook serve 执行gitbook init可能会出现的报错，如下 Installing GitBook 3.2.3 /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:200:5) Node.js v21.0.0 这是因为 Node.js 的版本不符合 gitbook 的依赖，下面有三个可能的解决方法（推荐三） 注释polyfills.js文件中的这三行 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 升级graceful-fs # 下面的路径换成你的，--save 的意思是安装在当前的本地，即为更新当前的 graceful-fs cd /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/ npm install graceful-fs@latest --save 通过nvm来暂时降低Node.js版本 nvm -v 可能输出如下,箭头为当前的使用版本 $:nvm ls v21.0.0 -> system default -> node (-> v21.0.0) iojs -> N/A (default) unstable -> N/A (default) node -> stable (-> v21.0.0) (default) stable -> 21.0 (-> v21.0.0) (default) lts/* -> lts/hydrogen (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.17.0 (-> N/A) lts/dubnium -> v10.24.1 lts/erbium -> v12.22.12 (-> N/A) lts/fermium -> v14.21.3 (-> N/A) lts/gallium -> v16.20.2 (-> N/A) lts/hydrogen -> v18.18.2 (-> N/A) 我们需要安装10.24.1的版本,注意该段命令会只是会将当前的shell下的Node.js切换成10.24.1。 #Install a specific version number nvm install 10.24.1 #Use the latest available 8.0.x nvm use 10.21.1 二、入门进阶 1.配置文件 SUMMERY.md 一份参考文件如下，这个文件的内容会被用来生成大纲。 []()的超链接用来表示标题， ----会生成分隔符 # Summary的不是必要的，也不会被显示 ## Chapter1会被显示，但是不如超链接好用，一般只用超链接 # Summary ## Chapter1 * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) ---- * [Last part without title](part3/title.md) book.json 你可以新建一个book.json的配置文件，参考内容如下 { \"title\": \"title\", \"description\": \"description\", \"isbn\": \"isbn\", \"author\": \"author\", \"lang\": \"zh-cn\", \"plugins\": [], \"variables\": { } } 你可以修改plugins来加入插件,search插件支持中文搜索，code插件支持复制,-的意思是不使用该插件，需要使用可以去掉前面的- plugins\": ['code','-seacrh'] 然后利用gitbook install来安装上面的插件 gitbook install 插件可以配置属性 pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } 2.插件推荐 菜单折叠插件 { plugins: ['expandable-chapters']; } 返回顶部插件 { plugins: ['back-to-top-button']; } 引用插件 { plugins: ['flexible-alerts']; pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } } 引用插件效果展示如下 [!NOTE] An alert of type 'note' using global style 'callout'. 三、深入探索 Github Pages 在github上新建一个仓库，新建个gh-page分支，在github设置支持静态网页的pages。然后我们可以将这个仓库克隆下来，初始化gitbook。不过值得注意的是github只是支持选择/和/docs这两个路径作为网页根目录。因此我们选择/docs，这样的话适合gitbook. 调整gitbook仓库的目录如下,根路径下的README.md作为仓库的说明，book下的README.md作为书籍首页的说明。book可以修改为你喜欢的名字。 . ├── README.md ├── book │ ├── README.md │ ├── SUMMARY.md │ ├── book.json └── docs 同时我们需要修改gitbook命令参数，可以尝试执行如下命令 # 安装book下book.json的插件 gitbook install book # gitbook build src dest gitbook build book docs # gitbook serve src dest gitbook serve book docs 执行后的示例目录 . ├── README.md ├── bash.sh ├── book │ ├── Gitbook Explore in Mac │ ├── How to write markdown elegantly │ ├── README.md │ ├── SUMMARY.md │ ├── book.json │ └── node_modules └── docs ├── Gitbook Explore in Mac ├── How to write markdown elegantly ├── gitbook ├── index.html ├── search_index.json └── search_plus_index.json 自动化脚本 我构建的一份自动更新上传脚本如下，前两行是为了在bash中使用nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # 加载 nvm nvm use 10 gitbook install book gitbook build book docs git add . git commit -m \"Update\" git push gitbook serve book docs 输出文档 参考链接 官方下载和安装文档 官方Github仓库 Gitbook操作指南 Gitbook详解 Gitbook攻略（推荐） 插件集合 GitBook CookBook(优秀) "},"How to write markdown elegantly/":{"url":"How to write markdown elegantly/","title":"How to write markdown elegantly","keywords":"","body":"how to write markdown elegantly using note [!NOTE] Information the user should notice even if skimming. [!TIP] Optional information to help a user be more successful. [!IMPORTANT] Essential information required for user success. [!CAUTION] Negative potential consequences of an action. [!WARNING] Dangerous certain consequences of an action. "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":"Vim .vimrc ctags "},"Linux/Vim/":{"url":"Linux/Vim/","title":"Vim","keywords":"","body":"Vim .vimrc ctags "},"Linux/Git/":{"url":"Linux/Git/","title":"Git","keywords":"","body":"Git 这里有一份官方教程 基本命令 配置 常用配置 git config --global core.editor emacs 基础 git status -s git rm --cached README git rm git mv file_from file_to git commit --amend # git remote add pb https://github.com/paulboone/ticgit git tag git tag -l \"v1.8.5*\" 查看 git log --oneline --decorate --graph --all 使用技巧 .gitignore .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反 glob 模式是指 shell 所使用的简化了的正则表达式。 支持*，？，[abc],[a-z]星号。 使用两个星号**表示匹配任意中间目录。 分支指代 -- HEAD～ reset和checkout 分支层面 git reset --soft HEAD (移动HEAD和分支） git reset HEAD （移动HEAD和分支，修改暂存区） git reset --hard HEAD （移动HEAD和分支，修改暂存区，工作区）（⚠️） git checkout HEAD （移动HEAD，修改暂存区，工作区） 文件层面 git reset HEAD file （修改暂存区） git checkout HEAD file （修改暂存区，工作区） （⚠️） 分支合并 分支合并有merge和rebase方法,git pull时会自动调用git merge,git merge首次要求设定ff或者rebase的配置值。 git stash git pull git stash pop git checkout -b branchA git add . git commit -m \"\" git checkout main git reset --hard git pull git rebase main branchA 标签（TODO） 有趣命令 修改远程HEAD git remote set-head origin branchA git remote set-head origin -d "},"Linux/Tmux/":{"url":"Linux/Tmux/","title":"Tmux","keywords":"","body":"Tmux 这里是一份教程,可以参考。 基本概念 从服务的角度：server - client tmux有一个server管理多个client，每个client和一个session连接,用户启动tmux的时候实际上是启动一个client连接到server。client是伪终端，进程实际由server管理,当用户断开连接后，运行在client中的进程不会被中断。 从显示的角度：session - windows - pane(terminal) 每个session可以与零个或者多个client相连接，每个session的命名必须唯一。每个session管理多个windos,windows的命名可以重复，可以连接一个或者多个session，windows内有多个pane,其中有一个为活跃的pane 当所有的session中的所有进程终止的时候server终止 命令模式 按下C-b :进入命令模式，按下C-b ?查看所有命令,按下C-b /查看单个命令 Tree 模式 session Tmux有一个模式叫树模式，在Tmux中按下C-b s或者C-b w进入，前者显示当前附着的session的情况，后者显示所有session的情况，还可以通过:choose-tree进入。进入后屏幕分为上部分树和下部分预览。 树模式下可以按下t标记，T取消所有标记，x删除当前项，X删除所有标记项目，也可以用:使用命令对所有的标记项操作。r可以反向排序,v可以取消预览。 client Tmux也有关于client的树模式，按下C-b D进入，可以看到当前活跃的client以及和哪一个session相连接。 基本使用 创建client tmux ls: 列出所有的session tmux: 默认会创建一个client和一个session,等同于tmux new tmux -t session_name: 创建一个client同时连接session 创建session tmux new：创建一个默认的名为index的session（即为名字就是序号) tmux new -syourname: 指定名字为yourname 创建windows :neww: 创建默认窗口，名字为通常为bash :neww -nyourname: 创建窗口同时命名 :neww -t999: 创建窗口同时指定序号为999 :neww top: 创建窗口同时命名和执行改命令top 切换windows C-b [0-9]: 切换窗口为序号[0-9] C-b ': 输入序号然后切换到序号窗口 C-b p: 切换到前窗口 C-b n: 切换到后窗口 创建panes C-b %： 垂直分割 C-b \": 水平分割 切换panes C-b {: 当前pane和上边pane交换位置 C-b }: 当前pane‵和下边pane`交换位置 C-b up/down/right/left: 切换当前聚焦的pane 修改pane的大小 C-b C-up/down/right/left：上下左右微调 C-b M-up/down/right/left： 上下左右大调 C-b M-1/2/3/4/5: 调整布局格式 删除 C-b &: 删除当前session C-b x: 删除当前panes 复制和粘贴 C-b [: 进入复制模式/滚轮模式，复制模式下会冻结输出   C-space:开始选取复制   C-w:结束复制   q: 退出复制 C-b ]: 粘贴上一次复制的文本 C-b =: 选择要粘贴的文本 其他 :set -g mouse on: 支持鼠标 Tmux配置文件（TODO） "},"Linux/Make/":{"url":"Linux/Make/","title":"Make","keywords":"","body":"Makefile 这里是一份教程 基本概念 Makefile主要由目标、依赖、命令构成 targets: prerequisites command command command 规则 隐式规则 当缺乏所需要的文件的编译规则或者链接规则时时会自动 $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 模式规则 %.o:%.c 静态模式规则 $(objects):%.o:%.c 变量 自动变量 $@:target $?:prerequisite newer than target $^: all prerequisite $变量赋值 := 直接赋值 = 间接赋值 ?= 判空赋值（便量不存在,变量存在为空也不会赋值） += 追加赋值 通配符 *在命令中表现为通配符 $(wildcard *.c) $(filter *.o,$(objects):%.o:%.c %在规则和变量赋值中表现为通配符 $(objects):%.o:%.c two := $(foo:%.o=%.c) 函数变量 函数 make有大量的内置函数 # subst （字符替换） $(subst old,new,str) # patsubst （正则表达式替换） $(patsubst pattern,replace,strs) two := $(foo:%.o=%.c) three := $(foo:.o=.c) # if （condition为空或者不存在为假） $(if condition,value1,value2) # call $(call func,arg1,arg2,...) # addprefix （当INC_PATH存在-I开头时不会重复添加） $(addprefix -I,INC_PATH) # fileter $(filter *.o,objects):%.o:*.c 一些指令 .PHONY: .DEFAULT_GOAL: include|-include|sinclude make命令会在-I指定的目录和系统的include目录下查找include所包含的文件，当为查找到文件且没有构建该文件的规则时，如果是include，make会报错退出，-include忽视会继续执行，sinclude是GNU make下为了和其他make兼容的-inlcude "},"Jyy's PA/":{"url":"Jyy's PA/","title":"Jyy's PA","keywords":"","body":"Jyy's PA 这是我在2023年夯实我基础的首个课程笔记，欢迎大家观看！ PA0 Makefile section 1 $(deps_config): ; 是一个空规则。它表示 deps_config 中的文件不需要进行任何操作，即使这些文件不存在，也不会报错 deps_config := \\ src/device/Kconfig \\ src/memory/Kconfig \\ src/isa/riscv32/Kconfig \\ /home/teamtee/Desktop/ics2021/nemu/Kconfig include/config/auto.conf: \\ $(deps_config) $(deps_config): ; section 2 remove_quote = $(patsubst \"%\",%,$(1)) CC = $(call remove_quote,$(CONFIG_CC)) PA1 调试器 Readline Str char *strtok(char *str, const char *delim); C regular C 的正则表达式匹配通过编译+匹配的方式进行匹配，可以通过man regexec查看教程 regcomp用来编译正则表达算式，cflags表示支持的正则表达式语法,编译成功返回0 int regcomp(regex_t *preg, const char *regex, int cflags); regexec用编译好的正则表达式来匹配字符串,匹配成功至少一次后返回0，preg表示编译好的正则表达式，string表示待匹配的字符串，nmatch表示要匹配的pmathc，pmathc用来存储匹配的信息，pmatch有两个变量,rm_so表示匹配到的开始，rm_eo表示匹配到的结束,如果rm_so为-1表示未匹配到，eflags一般取0. int regexec(const regex_t *preg, const char *string, size_t nmatch,regmatch_t pmatch[], int eflags); typedef struct { regoff_t rm_so; regoff_t rm_eo; } regmatch_t; 颜色输出 但我们使用命令的时候可以看到是有颜色输出的，比如ls,实际上命令通常都有一个--color的选项来控制在什么情况下输出字符,如果我们ls --color=true | vim -是可以看到奇怪的输出. 实际上控制台通过以下方式输出颜色 # 其中0；31；42；为控制输出条件 \\033[0;31;42moutput\\033[0m 0-9字体效果：0默认，1高亮，4下划，5闪烁，7反白显示 30-39字体颜色，40-49背景颜色：黑红绿黄蓝紫青白 附录 C regular实例 下面是一个简单的示例 #include #include #include #include #define ARRAY_SIZE(arr) (sizeof((arr)) / sizeof((arr)[0])) static const char *const str = \"1) John Driverhacker;\\n2) John Doe;\\n3) John Foo;\\n\"; static const char *const re = \"John.*o\"; int main(void) { static const char *s = str; regex_t regex; regmatch_t pmatch[1]; regoff_t off, len; if (regcomp(&regex, re, REG_EXTENDED)) exit(EXIT_FAILURE); printf(\"String = \\\"%s\\\"\\n\", str); printf(\"Matches:\\n\"); for (int i = 0; ; i++) { if (regexec(&regex, s, ARRAY_SIZE(pmatch), pmatch, 0)) break; off = pmatch[0].rm_so + (s - str); len = pmatch[0].rm_eo - pmatch[0].rm_so; printf(\"#%d:\\n\", i); printf(\"offset = %jd; length = %jd\\n\", (intmax_t) off, (intmax_t) len); printf(\"substring = \\\"%.*s\\\"\\n\", len, s + pmatch[0].rm_so); s += pmatch[0].rm_eo; } exit(EXIT_SUCCESS); } "},"Tutorial/":{"url":"Tutorial/","title":"Tutorial","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(vimtutor，在linux下安装了vim的话可以输入vimtutor来看教程) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "},"DeepLearning/":{"url":"DeepLearning/","title":"DeepLearning","keywords":"","body":"Transformer精讲 RNN 标准神经网络中的所有输入和输出都是相互独立的，但是在某些情况下，例如在预测短语的下一个单词时，前面的单词是必要的，因此必须记住前面的单词。结果，RNN 应运而生，它使用隐藏层来克服这个问题。RNN 最重要的组成部分是隐藏状态，它记住有关序列的特定信息。 RNN 有一个内存，用于存储有关计算的所有信息。它对每个输入采用相同的设置，因为它通过在所有输入或隐藏层上执行相同的任务来产生相同的结果。 RNN通常会用来一对多、多对多、多对一对任务。 Simple RNN 本节点的输出同时取决于当前的输入和隐藏状态。 ElmanRNN将上一次的隐藏层状态作为下一次的隐藏状态，JordanRNN将上一次的输出作为下一次的隐藏状态,下面以Elman为例说明隐藏状态如何起作用 这样的RNN会面临两个问题： （1）梯度消失：LSTM可以解决梯度消失的问题（记忆不会因为一次输出为0就被洗掉） （2）梯度爆炸：因为某一个状态可能累计在隐藏状态中导致不断累积，可以通过Clipping解决 LSTM LSTM的核心就是记忆单元和输入门、输出门、遗忘门，主要步骤如下： （1）记忆单元遗忘： （2）记忆如何更新： （3）记忆如何输出： GRU GRU只有重置门、更新门，没有隐藏记忆单元，会生成隐藏状态 （1）产生候选隐藏状态： （2）输出当前隐藏状态 Bidrectional RNN 拓展 Sequence to Sequence AutoDecoder "},"DeepLearning/ML2023HW/":{"url":"DeepLearning/ML2023HW/","title":"ML2023HW","keywords":"","body":"作业 HW01 初步代码 得分为3.99 特征选择 通过计算协方差系数选择绝对值较大的特征，难点是选择多相关的特征？ 0.5为门槛：1.7 0.6:1.31 0.75为门槛：1.13 0.9为门槛：1.31 模型复杂 1:300 -> 300 - 300 -> 300 -1 1N：1.13 1N：（wd=1e-3） 1N：（ba=256-》64）：1.5 1N：（ba=64-》32）：1.4 1n:(SGD)1.5 1n:(SGD,mounent = 0.9)1.2 1n:(SGD,mounent = 0.9,batch=4):0.98 1n:(SGD,mounent = 0.9,batch=4，lr=1e-6):1.3 1n:(SGD,mounent = 0.9,batch=4，lr=1e-4):100 1n:(SGD,mounent = 0.9,batch=4，lr=5e-5):0.95 1n:(SGD,mounent = 0.9,batch=16，lr=5e-5):0.88 2N：2 1:4 -> 4:4 -> 4:1 1N:5.2 1:16 -> 16:16 -> 16:1 1N:3.2 2N:4.3 3N:16 1:64 -> 64:64 -> 64:1 1N:2.4 1:128 -> 128:128 ->128:1 1N：1.7 1:400 -> 400 :400 ->400 :1 1N：1.71 1:600 -> 600 :600 ->600 :1（选择0.7作为门槛） 1N：1.92 1:600 -> 600 :600 ->600 :1（选择0.9作为门槛） 1N：1.31 结果总结 strong boss不知道用什么架构，过吧 HW02 connect：3 0.53 connect：5 0.55 connect：7 0.58 connect：9 0.60 connect：9 layer：2-》3 0.62 connect：9 layer：2-》4 0.63 "},"DeepLearning/Pandas/":{"url":"DeepLearning/Pandas/","title":"Pandas","keywords":"","body":"Pands库的使用 这里是一份官方教程 基本概念 Pandas的数据由series和DataFrame组成，通常这两个数据结构的值是可以改变的，但是大小不可改变 series是具有index和name的同类dtype的values数据序列,使用numpy.ndarray来存储数据，pandas只有三种数据类型int (int64)、float (float64)、str(object) ages = pd.Series(index=[0,1,2],value=[22, 35, 58],name=\"Age\",dtype=int) DataFrame是一系列series的集合,每个series具有相同的index和相同的长度，name在dataFrame中组成colunms,DataFrame的index和colunms属性实际上是Series,具有单个类型series的dataFrame同一类型，具备多种类型series的dataFrame为object类型。 df = pd.DataFrame(np.arange(9).reshape(3, 3), index = ['TJ', 'BJ', 'SH'], columns=['q', 'w', 'e']) 基本操作 读取与转化 可以通过字典创建dataFrame,通过列表创建series，也可以通过read_* 类函数和to_*函数进行读取和存储,支持csv、excel、json等等流行文件。 pd.read_excel(\"titanic.xlsx\", sheet_name=\"passengers\") df.to_excel(\"titanic.xlsx\", sheet_name=\"passengers\", index=False) pd.read_csv( \"data/air_quality_long.csv\", index_col=\"date.utc\", parse_dates=True ) 查看信息 df.tail df.head df.info df.dtypes df.shape 数据索引 注意你的到的数据通常和原数据是同一份，修改会改变两者 df[\"age\"] df[[\"age\",\"sex\"]] df[df[\"age\"]>35] df[\"age\"]>35 df[df[\"Pclass\"].isin([2, 3])] df[(df[\"Pclass\"] == 2) | (df[\"Pclass\"] == 3)] df[df[\"Age\"].notna()] df.loc[df[\"Age\"] > 35, \"Name\"] df.iloc[9:25, 2:5] df.iloc[0:3, 3] = \"anonymous\" 统计操作 对series可以求max、mean、median，对于dataFrame可以求corr,也可以通过describe查看多个统计值列表，还可以通过value_counts统计出现的次数 agg函数可以选择多个统计量聚类分析 In [7]: titanic.agg( ...: { ...: \"Age\": [\"min\", \"max\", \"median\", \"skew\"], ...: \"Fare\": [\"min\", \"max\", \"median\", \"mean\"], ...: } ...: ) ...: Out[7]: Age Fare min 0.420000 0.000000 max 80.000000 512.329200 median 28.000000 14.454200 skew 0.389108 NaN mean NaN 32.204208 groupby可以选择将某列值作为分类依据,将原数据分为多组,然后计算某个统计值 In [9]: titanic.groupby(\"Sex\").mean() Out[9]: Sex PassengerId Survived Pclass ... SibSp Parch Fare ... female 431.028662 0.742038 2.159236 ... 0.694268 0.649682 44.479818 male 454.147314 0.188908 2.389948 ... 0.429809 0.235702 25.523893 groupby也可以选择多个列,会对这多个列进行排列组合 In [11]: titanic.groupby([\"Sex\", \"Pclass\"])[\"Fare\"].mean() Out[11]: Sex Pclass female 1 106.125798 2 21.970121 3 16.118810 male 1 67.226127 2 19.741782 3 12.661633 Name: Fare, dtype: float64 value_counts可以统计每一种元素出现的次数 In [12]: titanic[\"Pclass\"].value_counts() Out[12]: Pclass 3 491 1 216 2 184 Name: count, dtype: int64 数据重组 sort_values可以按值排序，sort_index可以按照序列排序 In [7]: titanic.sort_values(by=['Pclass', 'Age'], ascending=False).head() Out[7]: PassengerId Survived Pclass ... Fare Cabin Embarked 851 852 0 3 ... 7.7750 NaN S 116 117 0 3 ... 7.7500 NaN Q 280 281 0 3 ... 7.7500 NaN Q 483 484 1 3 ... 9.5875 NaN S 326 327 0 3 ... 6.2375 NaN S [5 rows x 12 columns] pivot可以从原数据中抽取数据，有两种使用方式 pivot(columns=\"location\", values=\"value\") pivot_table同时可以指定index,但是需要指定聚合方法 air_quality.pivot_table( values=\"value\", index=\"location\", columns=\"parameter\", aggfunc=\"mean\" )_counts melt函数创建透视表 pd.melt(df, id_vars =['Name'], value_vars =['Course'],var_name = \"\",value_name = \"\") 合并表格 concat pd.concat([air_quality_pm25, air_quality_no2], axis=0) pd.concat([air_quality_pm25, air_quality_no2], keys=[\"PM25\", \"NO2\"]) merge 见这篇文章 import pandas as pd left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']}) right = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']}) result = pd.merge(left, right, on='key') # on参数传递的key作为连接键 result Out[4]: A B key C D 0 A0 B0 K0 C0 D0 1 A1 B1 K1 C1 D1 2 A2 B2 K2 C2 D2 3 A3 B3 K3 C3 D3 绘制 ['area', 'bar', 'barh', 'box', 'density', 'hexbin', 'hist', 'kde', 'line', 'pie', 'scatter'] df.plot() plt.show() 映射操作 参考这篇文章 series.map:支持字典，函数 series.apply:支持带参数的函数 dataFrame.apply:函数 dataFrame.applymap:函数 data[\"gender\"].map({\"男\":1, \"女\":0}) data[\"gender\"].map(lambda x:\"%.2f\" % x) addition = lambda x, y: x + y data[\"age\"].apply(addtion,args=(-3,)) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=0) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=1) df.applymap(lambda x:\"%.2f\" % x) 还可以对index和name进行映射，这个函数叫rename air_quality_renamed = air_quality.rename( columns={ \"station_antwerp\": \"BETR801\", \"station_paris\": \"FR04014\", \"station_london\": \"London Westminster\", } ) 时间序列处理和文本处理（TODO） 操作实例 "}}