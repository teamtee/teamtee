{"./":{"url":"./","title":"Introduction","keywords":"","body":"teamteee.github.io 这里是Teamtee的博客，我希望记录我的生活、学习和思考！欢迎各位来访问。 "},"Gitbook Explore in Mac/":{"url":"Gitbook Explore in Mac/","title":"Gitbook Explore in Mac","keywords":"","body":"[Mac] Gitbook in Mac 最近一直在思考如何学习 ，其中很重要的一环是输出。我曾经使用过语雀、思云等等，尽管它们功能丰富并且支持云端，但是对于像一本书一样阅读，这样的要求是达不到的，因此我选择了Gitbook + Githubpages 一、简单使用 Gitbook有网页版和本地版两种，网页版的功能感觉和语雀等类似，因此我选择本地版。你可以将本地版Gitbook（以下简称Gitbook）认为是一个工具链，这个工具链依赖于Node.js和npm。在mac的教程如下，windos还未尝试 1.安装 brew 在mac下需要先安装开发者工具brew,brew是一个类似apt、yum的包管理工具 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 安装完后命令行输入brew检查是否成功安装 npm 安装完brew后利用brew安装npm，npm是一个Node.js的包管理工具。我们需要用它来安装gitbook。 brew install npm 输入npm -v检查是否安装成功 nvm nvm也是Node.js的版本管理工具，类似Python里面的conda。我们需要用它来管理Node.js的版本。 brew install nvm 输入nvm -v检查是否安装成功 gitbook 使用brew安装gitbook.-g选项的意思安装在全局，否则默认为安装在用户下。 brew install gitbook-cli -g 2.使用 初始化 选择一个你希望的空文件夹，初始化工作目录 # 初始化工作目录会生成 README.md 和 SUMMARY.md gitbook init # 构建工作会默认在 _book 下生成文件 gitbook build # 服务器会构建本地端口映射 gitbook serve 执行gitbook init可能会出现的报错，如下 Installing GitBook 3.2.3 /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:200:5) Node.js v21.0.0 这是因为 Node.js 的版本不符合 gitbook 的依赖，下面有三个可能的解决方法（推荐三） 注释polyfills.js文件中的这三行 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 升级graceful-fs # 下面的路径换成你的，--save 的意思是安装在当前的本地，即为更新当前的 graceful-fs cd /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/ npm install graceful-fs@latest --save 通过nvm来暂时降低Node.js版本 nvm -v 可能输出如下,箭头为当前的使用版本 $:nvm ls v21.0.0 -> system default -> node (-> v21.0.0) iojs -> N/A (default) unstable -> N/A (default) node -> stable (-> v21.0.0) (default) stable -> 21.0 (-> v21.0.0) (default) lts/* -> lts/hydrogen (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.17.0 (-> N/A) lts/dubnium -> v10.24.1 lts/erbium -> v12.22.12 (-> N/A) lts/fermium -> v14.21.3 (-> N/A) lts/gallium -> v16.20.2 (-> N/A) lts/hydrogen -> v18.18.2 (-> N/A) 我们需要安装10.24.1的版本,注意该段命令会只是会将当前的shell下的Node.js切换成10.24.1。 #Install a specific version number nvm install 10.24.1 #Use the latest available 8.0.x nvm use 10.21.1 二、入门进阶 1.配置文件 SUMMERY.md 一份参考文件如下，这个文件的内容会被用来生成大纲。 []()的超链接用来表示标题， ----会生成分隔符 # Summary的不是必要的，也不会被显示 ## Chapter1会被显示，但是不如超链接好用，一般只用超链接 # Summary ## Chapter1 * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) ---- * [Last part without title](part3/title.md) book.json 你可以新建一个book.json的配置文件，参考内容如下 { \"title\": \"title\", \"description\": \"description\", \"isbn\": \"isbn\", \"author\": \"author\", \"lang\": \"zh-cn\", \"plugins\": [], \"variables\": { } } 你可以修改plugins来加入插件,search插件支持中文搜索，code插件支持复制,-的意思是不使用该插件，需要使用可以去掉前面的- plugins\": ['code','-seacrh'] 然后利用gitbook install来安装上面的插件 gitbook install 插件可以配置属性 pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } 2.插件推荐 菜单折叠插件 { plugins: ['expandable-chapters']; } 返回顶部插件 { plugins: ['back-to-top-button']; } 引用插件 { plugins: ['flexible-alerts']; pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } } 引用插件效果展示如下 [!NOTE] An alert of type 'note' using global style 'callout'. 三、深入探索 Github Pages 在github上新建一个仓库，新建个gh-page分支，在github设置支持静态网页的pages。然后我们可以将这个仓库克隆下来，初始化gitbook。不过值得注意的是github只是支持选择/和/docs这两个路径作为网页根目录。因此我们选择/docs，这样的话适合gitbook. 调整gitbook仓库的目录如下,根路径下的README.md作为仓库的说明，book下的README.md作为书籍首页的说明。book可以修改为你喜欢的名字。 . ├── README.md ├── book │ ├── README.md │ ├── SUMMARY.md │ ├── book.json └── docs 同时我们需要修改gitbook命令参数，可以尝试执行如下命令 # 安装book下book.json的插件 gitbook install book # gitbook build src dest gitbook build book docs # gitbook serve src dest gitbook serve book docs 执行后的示例目录 . ├── README.md ├── bash.sh ├── book │ ├── Gitbook Explore in Mac │ ├── How to write markdown elegantly │ ├── README.md │ ├── SUMMARY.md │ ├── book.json │ └── node_modules └── docs ├── Gitbook Explore in Mac ├── How to write markdown elegantly ├── gitbook ├── index.html ├── search_index.json └── search_plus_index.json 自动化脚本 我构建的一份自动更新上传脚本如下，前两行是为了在bash中使用nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # 加载 nvm nvm use 10 gitbook install book gitbook build book docs git add . git commit -m \"Update\" git push gitbook serve book docs 输出文档 参考链接 官方下载和安装文档 官方Github仓库 Gitbook操作指南 Gitbook详解 Gitbook攻略（推荐） 插件集合 GitBook CookBook(优秀) "},"How to write markdown elegantly/":{"url":"How to write markdown elegantly/","title":"How to write markdown elegantly","keywords":"","body":"how to write markdown elegantly using note [!NOTE] Information the user should notice even if skimming. [!TIP] Optional information to help a user be more successful. [!IMPORTANT] Essential information required for user success. [!CAUTION] Negative potential consequences of an action. [!WARNING] Dangerous certain consequences of an action. "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":"Vim .vimrc ctags "},"Linux/Vim/":{"url":"Linux/Vim/","title":"Vim","keywords":"","body":"Vim .vimrc ctags "},"Linux/Git/":{"url":"Linux/Git/","title":"Git","keywords":"","body":"Git 这里有一份官方教程 基本命令 配置 常用配置 git config --global core.editor emacs 基础 git status -s git rm --cached README git rm git mv file_from file_to git commit --amend # git remote add pb https://github.com/paulboone/ticgit git tag git tag -l \"v1.8.5*\" 查看 git log --oneline --decorate --graph --all 使用技巧 .gitignore .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反 glob 模式是指 shell 所使用的简化了的正则表达式。 支持*，？，[abc],[a-z]星号。 使用两个星号**表示匹配任意中间目录。 分支指代 -- HEAD～ reset和checkout 分支层面 git reset --soft HEAD (移动HEAD和分支） git reset HEAD （移动HEAD和分支，修改暂存区） git reset --hard HEAD （移动HEAD和分支，修改暂存区，工作区）（⚠️） git checkout HEAD （移动HEAD，修改暂存区，工作区） 文件层面 git reset HEAD file （修改暂存区） git checkout HEAD file （修改暂存区，工作区） （⚠️） 分支合并 分支合并有merge和rebase方法,git pull时会自动调用git merge,git merge首次要求设定ff或者rebase的配置值。 git stash git pull git stash pop git checkout -b branchA git add . git commit -m \"\" git checkout main git reset --hard git pull git rebase main branchA 标签（TODO） 有趣命令 修改远程HEAD git remote set-head origin branchA git remote set-head origin -d "},"Linux/Tmux/":{"url":"Linux/Tmux/","title":"Tmux","keywords":"","body":"Tmux 这里是一份教程,可以参考。 基本概念 从服务的角度：server - client tmux有一个server管理多个client，每个client和一个session连接,用户启动tmux的时候实际上是启动一个client连接到server。client是伪终端，进程实际由server管理,当用户断开连接后，运行在client中的进程不会被中断。 从显示的角度：session - windows - pane(terminal) 每个session可以与零个或者多个client相连接，每个session的命名必须唯一。每个session管理多个windos,windows的命名可以重复，可以连接一个或者多个session，windows内有多个pane,其中有一个为活跃的pane 当所有的session中的所有进程终止的时候server终止 命令模式 按下C-b :进入命令模式，按下C-b ?查看所有命令,按下C-b /查看单个命令 Tree 模式 session Tmux有一个模式叫树模式，在Tmux中按下C-b s或者C-b w进入，前者显示当前附着的session的情况，后者显示所有session的情况，还可以通过:choose-tree进入。进入后屏幕分为上部分树和下部分预览。 树模式下可以按下t标记，T取消所有标记，x删除当前项，X删除所有标记项目，也可以用:使用命令对所有的标记项操作。r可以反向排序,v可以取消预览。 client Tmux也有关于client的树模式，按下C-b D进入，可以看到当前活跃的client以及和哪一个session相连接。 基本使用 创建client tmux ls: 列出所有的session tmux: 默认会创建一个client和一个session,等同于tmux new tmux -t session_name: 创建一个client同时连接session 创建session tmux new：创建一个默认的名为index的session（即为名字就是序号) tmux new -syourname: 指定名字为yourname 创建windows :neww: 创建默认窗口，名字为通常为bash :neww -nyourname: 创建窗口同时命名 :neww -t999: 创建窗口同时指定序号为999 :neww top: 创建窗口同时命名和执行改命令top 切换windows C-b [0-9]: 切换窗口为序号[0-9] C-b ': 输入序号然后切换到序号窗口 C-b p: 切换到前窗口 C-b n: 切换到后窗口 创建panes C-b %： 垂直分割 C-b \": 水平分割 切换panes C-b {: 当前pane和上边pane交换位置 C-b }: 当前pane‵和下边pane`交换位置 C-b up/down/right/left: 切换当前聚焦的pane 修改pane的大小 C-b C-up/down/right/left：上下左右微调 C-b M-up/down/right/left： 上下左右大调 C-b M-1/2/3/4/5: 调整布局格式 删除 C-b &: 删除当前session C-b x: 删除当前panes 复制和粘贴 C-b [: 进入复制模式/滚轮模式，复制模式下会冻结输出   C-space:开始选取复制   C-w:结束复制   q: 退出复制 C-b ]: 粘贴上一次复制的文本 C-b =: 选择要粘贴的文本 其他 :set -g mouse on: 支持鼠标 Tmux配置文件（TODO） "},"Linux/Make/":{"url":"Linux/Make/","title":"Make","keywords":"","body":"Makefile 这里是一份教程 基本概念 Makefile主要由目标、依赖、命令构成 targets: prerequisites command command command 规则 隐式规则 当缺乏所需要的文件的编译规则或者链接规则时时会自动 $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 模式规则 %.o:%.c 静态模式规则 $(objects):%.o:%.c 变量 自动变量 $@:target $?:prerequisite newer than target $^: all prerequisite $变量赋值 := 直接赋值 = 间接赋值 ?= 判空赋值（便量不存在,变量存在为空也不会赋值） += 追加赋值 通配符 *在命令中表现为通配符 $(wildcard *.c) $(filter *.o,$(objects):%.o:%.c %在规则和变量赋值中表现为通配符 $(objects):%.o:%.c two := $(foo:%.o=%.c) 函数变量 函数 make有大量的内置函数 # subst （字符替换） $(subst old,new,str) # patsubst （正则表达式替换） $(patsubst pattern,replace,strs) two := $(foo:%.o=%.c) three := $(foo:.o=.c) # if （condition为空或者不存在为假） $(if condition,value1,value2) # call $(call func,arg1,arg2,...) # addprefix （当INC_PATH存在-I开头时不会重复添加） $(addprefix -I,INC_PATH) # fileter $(filter *.o,objects):%.o:*.c 一些指令 .PHONY: .DEFAULT_GOAL: include|-include|sinclude make命令会在-I指定的目录和系统的include目录下查找include所包含的文件，当为查找到文件且没有构建该文件的规则时，如果是include，make会报错退出，-include忽视会继续执行，sinclude是GNU make下为了和其他make兼容的-inlcude "},"Jyy's PA/":{"url":"Jyy's PA/","title":"Jyy's PA","keywords":"","body":"Jyy's PA 这是我在2023年夯实我基础的首个课程笔记，欢迎大家观看！ PA0 Makefile section 1 $(deps_config): ; 是一个空规则。它表示 deps_config 中的文件不需要进行任何操作，即使这些文件不存在，也不会报错 deps_config := \\ src/device/Kconfig \\ src/memory/Kconfig \\ src/isa/riscv32/Kconfig \\ /home/teamtee/Desktop/ics2021/nemu/Kconfig include/config/auto.conf: \\ $(deps_config) $(deps_config): ; section 2 remove_quote = $(patsubst \"%\",%,$(1)) CC = $(call remove_quote,$(CONFIG_CC)) PA1 调试器 Readline Str char *strtok(char *str, const char *delim); C regular C 的正则表达式匹配通过编译+匹配的方式进行匹配，可以通过man regexec查看教程 regcomp用来编译正则表达算式，cflags表示支持的正则表达式语法,编译成功返回0 int regcomp(regex_t *preg, const char *regex, int cflags); regexec用编译好的正则表达式来匹配字符串,匹配成功至少一次后返回0，preg表示编译好的正则表达式，string表示待匹配的字符串，nmatch表示要匹配的pmathc，pmathc用来存储匹配的信息，pmatch有两个变量,rm_so表示匹配到的开始，rm_eo表示匹配到的结束,如果rm_so为-1表示未匹配到，eflags一般取0. int regexec(const regex_t *preg, const char *string, size_t nmatch,regmatch_t pmatch[], int eflags); typedef struct { regoff_t rm_so; regoff_t rm_eo; } regmatch_t; 颜色输出 但我们使用命令的时候可以看到是有颜色输出的，比如ls,实际上命令通常都有一个--color的选项来控制在什么情况下输出字符,如果我们ls --color=true | vim -是可以看到奇怪的输出. 实际上控制台通过以下方式输出颜色 # 其中0；31；42；为控制输出条件 \\033[0;31;42moutput\\033[0m 0-9字体效果：0默认，1高亮，4下划，5闪烁，7反白显示 30-39字体颜色，40-49背景颜色：黑红绿黄蓝紫青白 附录 C regular实例 下面是一个简单的示例 #include #include #include #include #define ARRAY_SIZE(arr) (sizeof((arr)) / sizeof((arr)[0])) static const char *const str = \"1) John Driverhacker;\\n2) John Doe;\\n3) John Foo;\\n\"; static const char *const re = \"John.*o\"; int main(void) { static const char *s = str; regex_t regex; regmatch_t pmatch[1]; regoff_t off, len; if (regcomp(&regex, re, REG_EXTENDED)) exit(EXIT_FAILURE); printf(\"String = \\\"%s\\\"\\n\", str); printf(\"Matches:\\n\"); for (int i = 0; ; i++) { if (regexec(&regex, s, ARRAY_SIZE(pmatch), pmatch, 0)) break; off = pmatch[0].rm_so + (s - str); len = pmatch[0].rm_eo - pmatch[0].rm_so; printf(\"#%d:\\n\", i); printf(\"offset = %jd; length = %jd\\n\", (intmax_t) off, (intmax_t) len); printf(\"substring = \\\"%.*s\\\"\\n\", len, s + pmatch[0].rm_so); s += pmatch[0].rm_eo; } exit(EXIT_SUCCESS); } "},"Tutorial/":{"url":"Tutorial/","title":"Tutorial","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(Vimtutor) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "}}