{"./":{"url":"./","title":"Introduction","keywords":"","body":"teamteee.github.io 这里是Teamtee的博客，我希望记录我的生活、学习和思考！欢迎各位来访问。 "},"Wrighting/":{"url":"Wrighting/","title":"Wrighting","keywords":"","body":"teamteee.github.io 这里是Teamtee的博客，我希望记录我的生活、学习和思考！欢迎各位来访问。 "},"Wrighting/Gitbook Explore in Mac/":{"url":"Wrighting/Gitbook Explore in Mac/","title":"Gitbook Explore in Mac","keywords":"","body":"[Mac] Gitbook in Mac 最近一直在思考如何学习 ，其中很重要的一环是输出。我曾经使用过语雀、思云等等，尽管它们功能丰富并且支持云端，但是对于像一本书一样阅读，这样的要求是达不到的，因此我选择了Gitbook + Githubpages 一、简单使用 Gitbook有网页版和本地版两种，网页版的功能感觉和语雀等类似，因此我选择本地版。你可以将本地版Gitbook（以下简称Gitbook）认为是一个工具链，这个工具链依赖于Node.js和npm。在mac的教程如下，windos还未尝试 1.安装 brew 在mac下需要先安装开发者工具brew,brew是一个类似apt、yum的包管理工具 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 安装完后命令行输入brew检查是否成功安装 npm 安装完brew后利用brew安装npm，npm是一个Node.js的包管理工具。我们需要用它来安装gitbook。 brew install npm 输入npm -v检查是否安装成功 nvm nvm也是Node.js的版本管理工具，类似Python里面的conda。我们需要用它来管理Node.js的版本。 brew install nvm 输入nvm -v检查是否安装成功 gitbook 使用brew安装gitbook.-g选项的意思安装在全局，否则默认为安装在用户下。 brew install gitbook-cli -g 2.使用 初始化 选择一个你希望的空文件夹，初始化工作目录 # 初始化工作目录会生成 README.md 和 SUMMARY.md gitbook init # 构建工作会默认在 _book 下生成文件 gitbook build # 服务器会构建本地端口映射 gitbook serve 执行gitbook init可能会出现的报错，如下 Installing GitBook 3.2.3 /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:200:5) Node.js v21.0.0 这是因为 Node.js 的版本不符合 gitbook 的依赖，下面有三个可能的解决方法（推荐三） 注释polyfills.js文件中的这三行 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 升级graceful-fs # 下面的路径换成你的，--save 的意思是安装在当前的本地，即为更新当前的 graceful-fs cd /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/ npm install graceful-fs@latest --save 通过nvm来暂时降低Node.js版本 nvm -v 可能输出如下,箭头为当前的使用版本 $:nvm ls v21.0.0 -> system default -> node (-> v21.0.0) iojs -> N/A (default) unstable -> N/A (default) node -> stable (-> v21.0.0) (default) stable -> 21.0 (-> v21.0.0) (default) lts/* -> lts/hydrogen (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.17.0 (-> N/A) lts/dubnium -> v10.24.1 lts/erbium -> v12.22.12 (-> N/A) lts/fermium -> v14.21.3 (-> N/A) lts/gallium -> v16.20.2 (-> N/A) lts/hydrogen -> v18.18.2 (-> N/A) 我们需要安装10.24.1的版本,注意该段命令会只是会将当前的shell下的Node.js切换成10.24.1。 #Install a specific version number nvm install 10.24.1 #Use the latest available 8.0.x nvm use 10.21.1 二、入门进阶 1.配置文件 SUMMERY.md 一份参考文件如下，这个文件的内容会被用来生成大纲。 []()的超链接用来表示标题， ----会生成分隔符 # Summary的不是必要的，也不会被显示 ## Chapter1会被显示，但是不如超链接好用，一般只用超链接 # Summary ## Chapter1 * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) ---- * [Last part without title](part3/title.md) book.json 你可以新建一个book.json的配置文件，参考内容如下 { \"title\": \"title\", \"description\": \"description\", \"isbn\": \"isbn\", \"author\": \"author\", \"lang\": \"zh-cn\", \"plugins\": [], \"variables\": { } } 你可以修改plugins来加入插件,search插件支持中文搜索，code插件支持复制,-的意思是不使用该插件，需要使用可以去掉前面的- plugins\": ['code','-seacrh'] 然后利用gitbook install来安装上面的插件 gitbook install 插件可以配置属性 pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } 2.插件推荐 菜单折叠插件 { plugins: ['expandable-chapters']; } 返回顶部插件 { plugins: ['back-to-top-button']; } 引用插件 这里有个教程 { plugins: ['flexible-alerts']; pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } } 引用插件语法 > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. （这个似乎无效） > [!IMPORTANT] > Essential information required for user success. （这个似乎无效） > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. [!NOTE] Information the user should notice even if skimming. 分隔符 [!TIP] Optional information to help a user be more successful. 分隔符 [!WARNING] Dangerous certain consequences of an action. 拓展玩法：自定义引用 有关图标可以在这里寻找 //自定义类型，className可能有info,warning,tip,note pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } } } [!Comment] Dangerous certain consequences of an action. [引用插件] { plugins: ['alerts']; } 效果如下，支持info，waring，danger，successs > **[info] For info** > > Use this for infomation messages. [info] For info Use this for infomation messages. > **[warning] For warning** > > Use this for warning messages. [warning] For warning Use this for warning messages. > **[danger] For danger** > > Use this for danger messages. [danger] For danger Use this for infomation messages > **[success] For success** > > Use this for success messages. [success] For success Use this for success messages. 数学插件 mathjax有问题，总是安装不了，无意间发现了katex可以直接安装 { \"plugins\": [\"katex\"] } 三、深入探索 Github Pages 在github上新建一个仓库，新建个gh-page分支，在github设置支持静态网页的pages。然后我们可以将这个仓库克隆下来，初始化gitbook。不过值得注意的是github只是支持选择/和/docs这两个路径作为网页根目录。因此我们选择/docs，这样的话适合gitbook. 调整gitbook仓库的目录如下,根路径下的README.md作为仓库的说明，book下的README.md作为书籍首页的说明。book可以修改为你喜欢的名字。 . ├── README.md ├── book │ ├── README.md │ ├── SUMMARY.md │ ├── book.json └── docs 同时我们需要修改gitbook命令参数，可以尝试执行如下命令 # 安装book下book.json的插件 gitbook install book # gitbook build src dest gitbook build book docs # gitbook serve src dest gitbook serve book docs 执行后的示例目录 . ├── README.md ├── bash.sh ├── book │ ├── Gitbook Explore in Mac │ ├── How to write markdown elegantly │ ├── README.md │ ├── SUMMARY.md │ ├── book.json │ └── node_modules └── docs ├── Gitbook Explore in Mac ├── How to write markdown elegantly ├── gitbook ├── index.html ├── search_index.json └── search_plus_index.json 自动化脚本 我构建的一份自动更新上传脚本如下，前两行是为了在bash中使用nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # 加载 nvm nvm use 10 gitbook install book gitbook build book docs git add . git commit -m \"Update\" git push gitbook serve book docs 输出文档 问题合集 gitbook install 出问题 使用下面的替代 npm install gitbook-plugin-* gitbook install 参考链接 官方下载和安装文档 官方Github仓库 Gitbook操作指南 Gitbook详解 Gitbook攻略（推荐） 插件集合 GitBook CookBook(优秀) "},"Wrighting/How to write markdown elegantly/":{"url":"Wrighting/How to write markdown elegantly/","title":"How to write markdown elegantly","keywords":"","body":"how to write markdown elegantly 首先你必须明白mardown是有不同的解析器，不同的解析器对于基础的语法都同时支持，但是对于高级的语法就不一定兼容了。比如Github的README.md，Typora，NWeb这些不同的编译器的解析不同，但是本文主要讲解的是基于Gitbook的markdown语法。 基本入门 参考教程 文本样式 粗体：** ** 或者__ __,快捷键CTRL_b 斜线：* * 或者 _ _,快捷键CTRL_i 删除线：~ ~ 下标： 上标： 特殊块 引用文本： > 代码块：``` ``` [!TIP] 如果想在代码块中使用``` ,可以使用```` 代替``` 包裹） 花体：`` `` 行内代码：`` 无序列表：* + - 有序列表：1. (支持嵌套) 任务列表 - [ ] task1 - [x] task2 - [ ] task3 表格 | Heading 1 | Heading 2 | Heading 3 | | --------- | --------- | --------- | | cell 1 | cell 2 | cell 3 | | cell 4 | cell 5 | cell 6 | 折叠表格 My top languages | Rank | Languages | |-----:|-----------| | 1| Javascript| | 2| Python | | 3| SQL | mergaid关系图 graph TD; A-->B; A-->C; B-->D; C-->D; 数学 \\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right) 链接 超链接：[]() 图片：或者![](src) 视频： 网页： 转义符号 半方大的空白&ensp;或&#8194; 全方大的空白&emsp;或&#8195; 不断行的空白格&nbsp;或&#160; 如何优雅的插入视频 markdown语法 开始我只是想插入Bilibili的jyy的视频，找到了和markdwon相关的两种方法 视频嵌入 网页嵌入 第一方法markdown会识别有问题，markdown阅读器和gitbook都是 第二个markdown阅读器会整个跳转到Bililibi，不过gitbook还是可以正常编译显示 插件 插件有local、youtuber的，我都没试，但是video-player有问题 安装的时候下面这个不行，得用videoplayer,然后他的语法编译也不成功 { \"plugins\": [\"video-player\"] } 教程见此处， "},"Linux/":{"url":"Linux/","title":"Linux","keywords":"","body":"Linux 剪切板 基于X11的系统通常有两个剪切板 PRIMARY - 鼠标选择复制和粘贴(鼠标中键或右键菜单可复制） SECOND (几乎废弃） CLIPBOARD - CRTL-c/v 选择复制和粘贴 不过似乎我的电脑键盘和鼠标共用一个剪切板，当然你也可以编辑设置 你可以通过xclip或则Xsel和剪切板通信 xclip xclip的用法很简单，支持复制文件,支持选择剪切板,支持管道 xclip filename xclip -sel clipboard xclip -select primary echo \"fs\" | xclip "},"Linux/Vim/":{"url":"Linux/Vim/","title":"Vim","keywords":"","body":"Vim 在命令行中输入vimtutor可以进入教程(目前进度user_10) 模式 vim有下面几种模式 普通模式:默认的模式面板，可以使用一些快捷命令 命令模式:在普通模式输入:进入，按下Esc退出 编辑模式:在普通模式中输入i、o、c、a均可进入,按下Esc退出 块/列块模式:在普通模式输入v/CTRL-v进入块/列块模式,按下Esc退出 普通模式 普通模式下可以使用这些命令 编辑命令 d:删除命令，命令格式为d+位置（dw，de，dd，d2w) y:复制命令，命令格式为y+位置(yw,ye,yy) p:粘贴命令 u:撤销命令，撤销上次修改 C-R:恢复命令，恢复上次的撤销 x:字母剪切命令 r:字母替换命令 R:持续替换命令 位置跳转 w:单词头 e:单词尾 $:句子结尾 ^:句子开头 gg:文章开头 G:文章结尾 %:配对符号跳转 [[:按照C语言特性跳转到当前函数开头 ]]:按照C语言特性跳转到当前函数结尾 ]c/[c:跳转到上次修改的地方 :行内位置跳转 编辑模式: i:直接输入 c:纠删输入 o:下新行输入 O:上新行输入 a:前输入 A:后输入 查找命令 按下/全文查找，按下？下文查找，回车确认，n跳转到下一个查找，N跳转到上一个,下面是查找相关的配置 :set ic # 忽略大小写 :set noic # :set hls is # 设置high light search :nohlsearch :hls :set incsearch # 不知道有什么用 命令模式 文件命令 :edit:编辑命令 :edit *.txt:编辑命令 :write one.txt:写入命令 :file main.c:重命名命令 :saveas :编辑命令 :w保存命令 :q退出命令 :!执行外部命令 :read file.txt:读取文件 :0read file.txt:读取第一行 编辑命令 :substitute `:[位置]s/旧字符/新字符/[gc]`:g表示所有项，c表示询问每一项 :4,6s/old/new/g # 替换4-6行的内容 :%s/ld*c/ld/g #替换全文内容 :'s// #配合块模式使用 .表示当前光标位置 :.write file.txt :.,$s/yes/no/ :45s :4,5s :s+one/two+one or two+ 中，or :?^Chapter?,/^Chapter/s=grey=gray=g :.+3,$-5s :help :help vimrc-intro :help user-manual ctrl-d/TAB 提示补全 `:set nocp`设置补全功能 窗口命令 新建立 vim -o/O 1.txt 2.txt vimdiff main.c~ main.c CTLR-w:在窗口间跳转 4CTLR-w +/-:改变大小 CTRL-h/i/j/k: CTRL-t/b: :split :split two.c :vsplit :close :only :new :vertical new :qall :wall 列块模式 I列编辑 A列添加 ~切换大小写 U小写变大写 u大写变小写 >右移动 :set shiftwidth=4 多文件编辑 标记mark CTLR-i:跳转到新位置 CTLR-o:跳转到旧位置 :marks 查看所有mark 匿名mark 当你使用位置跳转时下面会自动记录你的位置 ':The cursor position before doing a jump \":The cursor position when last editing the file [:Start of the last change ]:End of the last change 记名mark ma:标记名为a的mark `a:跳转到名为a的mark 'a:跳转到名为a的mark 文件列表 vim one.c two.c three.c :args :args five.c six.c seven.h :argadd :argdel :next :previous :last :first :set autowrite :set noautowrite 配置文件 :edit ~/.vimrc 这是 Unix 系统所使用的命令 :edit ~/_vimrc 这是 MS-Windows 系统所使用的命令 :r $VIMRUNTIME/vimrc_example.vim :write 查看配置 :options :set nowarp :set sidescroll=10 :set list 查看tabs :syntax enable :syntax off :set background=dark :colorscheme evening 编辑配置 :set autowrite :set noautowrite :set backup :set backupext=.bak 包 mkdir -p ~/.vim/pack/fancy在.vimrc中加入 packadd! matchit 插件 插件位置 system plugin directory Unix ~/.vim/plugin/ PC $HOME/vimfiles/plugin or $VIM/vimfiles/plugin Amiga s:vimfiles/plugin Macintosh $VIM:vimfiles:plugin Mac OS X ~/.vim/plugin/ # ctags 寄存器 A会追加内容到寄存器a中，a表示覆盖,Y等于y$ \"aY \"AY 标签 参数列表 拓展 如何让Vim和Linux共用剪切板 实测安装vim-gtk3后vim匿名寄存器直接变为系统剪切板 +clipboard 参考教程 Vim 需要+clipboard功能标志才能使这些功能发挥作用,你可以通过在 Vim 中使用:echo has('clipboard')来检查你的 Vim 是否有这个功能，返回1表示有，如果没有，请安装 Debian 和 Ubuntu:安装vim-gtk3. Fedora:安装vim-X11并运行vimx（vim更多信息）。 Arch Linux:安装gvim（这也将+clipboard正常启用） 基于X11的系统通常有两个剪切板 PRIMARY - 鼠标选择复制和粘贴 CLIPBOARD - CRTL-c/v 选择复制和粘贴 Vim同样有两个特殊的寄存器和这两个剪切板相关联 * - PRIMARY + - CLIPBOARD 对于Windows和OS X系统而言只有一个剪切板,所以这两个没有区别 你可以直接使用这两个寄存器 \"*yy \"*p 你可以重新设置匿名寄存器set clipboard=unnamed set clipboard=unnamedplus 当然你也可以重新映射快捷键noremap y \"*y noremap p \"*p noremap Y \"+y noremap P \"+p vim -R 1.txtvim -M 1.txt :set modifiable :set write "},"Linux/Git/":{"url":"Linux/Git/","title":"Git","keywords":"","body":"Git 这里有一份官方教程 基本命令 配置 常用配置 git config --global core.editor emacs 基础 git status -s git rm --cached README git rm git mv file_from file_to git commit --amend # git remote add pb https://github.com/paulboone/ticgit git tag git tag -l \"v1.8.5*\" 查看 git log --oneline --decorate --graph --all 使用技巧 .gitignore .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反 glob 模式是指 shell 所使用的简化了的正则表达式。 支持*，？，[abc],[a-z]星号。 使用两个星号**表示匹配任意中间目录。 分支指代 -- HEAD～ reset和checkout 分支层面 git reset --soft HEAD (移动HEAD和分支） git reset HEAD （移动HEAD和分支，修改暂存区） git reset --hard HEAD （移动HEAD和分支，修改暂存区，工作区）（⚠️） git checkout HEAD （移动HEAD，修改暂存区，工作区） 文件层面 git reset HEAD file （修改暂存区） git checkout HEAD file （修改暂存区，工作区） （⚠️） resotre git restore --sourece --staged --worktree file 分支合并(TODO) --continue --abort 分支合并有merge和rebase方法,git pull时会自动调用git merge,git merge首次要求设定ff或者rebase的配置值。 git stash git pull git stash pop git checkout -b branchA git add . git commit -m \"\" git checkout main git reset --hard git pull git rebase main branchA 标签（TODO） 有趣命令 修改远程HEAD git remote set-head origin branchA git remote set-head origin -d "},"Linux/Tmux/":{"url":"Linux/Tmux/","title":"Tmux","keywords":"","body":"Tmux 这里是一份教程,可以参考。 基本概念 从服务的角度：server - client tmux有一个server管理多个client，每个client和一个session连接,用户启动tmux的时候实际上是启动一个client连接到server。client是伪终端，进程实际由server管理,当用户断开连接后，运行在client中的进程不会被中断。 从显示的角度：session - windows - pane(terminal) 每个session可以与零个或者多个client相连接，每个session的命名必须唯一。每个session管理多个windos,windows的命名可以重复，可以连接一个或者多个session，windows内有多个pane,其中有一个为活跃的pane 当所有的session中的所有进程终止的时候server终止 命令模式 PREFIX 默认为CTRL-b,按下PREFIX b :进入命令模式，按下PREFIX b ?查看所有命令,按下PREFIX b /查看单个命令 Tree 模式 session Tmux有一个模式叫树模式，在Tmux中按下PREFIX b s或者PREFIX b w进入，前者显示当前附着的session的情况，后者显示所有session的情况，还可以通过:choose-tree进入。进入后屏幕分为上部分树和下部分预览。 树模式下可以按下t标记，T取消所有标记，x删除当前项，X删除所有标记项目，也可以用:使用命令对所有的标记项操作。r可以反向排序,v可以取消预览。 client Tmux也有关于client的树模式，按下PREFIX b D进入，可以看到当前活跃的client以及和哪一个session相连接。 基本使用 创建client tmux ls: 列出所有的session tmux: 默认会创建一个client和一个session,等同于tmux new tmux -t session_name: 创建一个client同时连接session 创建session tmux new：创建一个默认的名为index的session（即为名字就是序号) tmux new -syourname: 指定名字为yourname 创建windows :neww: 创建默认窗口，名字为通常为bash :neww -nyourname: 创建窗口同时命名 :neww -t999: 创建窗口同时指定序号为999 :neww top: 创建窗口同时命名和执行改命令top 切换windows PREFIX b [0-9]: 切换窗口为序号[0-9] PREFIX b ': 输入序号然后切换到序号窗口 PREFIX b p: 切换到前窗口 PREFIX b n: 切换到后窗口 创建panes PREFIX b %： 垂直分割 PREFIX b \": 水平分割 切换panes PREFIX b {: 当前pane和上边pane交换位置 PREFIX b }: 当前pane‵和下边pane`交换位置 PREFIX b up/down/right/left: 切换当前聚焦的pane 修改pane的大小 PREFIX b PREFIX up/down/right/left：上下左右微调 PREFIX b M-up/down/right/left： 上下左右大调 PREFIX b M-1/2/3/4/5: 调整布局格式 删除 PREFIX b &: 删除当前session PREFIX b x: 删除当前panes 复制和粘贴 PREFIX b [: 进入复制模式/滚轮模式，复制模式下会冻结输出   PREFIX space:开始选取复制   PREFIX w:结束复制   q: 退出复制 PREFIX b ]: 粘贴上一次复制的文本 PREFIX b =: 选择要粘贴的文本 其他 :set -g mouse on: 支持鼠标 Tmux配置文件（TODO） Tmux插件 可以安装tpm来管理和安装插件 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 在配置文件内写入~/.tmux.conf # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' # Other examples: # set -g @plugin 'github_username/plugin_name' # set -g @plugin 'github_username/plugin_name#branch' # set -g @plugin 'git@github.com:user/plugin' # set -g @plugin 'git@bitbucket.com:user/plugin' # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run '~/.tmux/plugins/tpm/tpm' 在tmux中使用PREFIX b I即可安装 tmux-resurrect 自动保存会话 教程 配置文件 set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-resurrect' set -g @plugin 'tmux-plugins/tmux-continuum' set -g @continuum-save-interval '15' set -g @continuum-restore 'on' set -g @resurrect-capture-pane-contents 'on' ​ # Other config ... ​ run -b '~/.tmux/plugins/tpm/tpm' 快捷键 PREFIX + CTRL s：保存会话 PREFIX + CTRL r：加载会话 tmux-yank 和系统剪切板共用 必须装有xsel或者xclip set -g @plugin 'tmux-plugins/tmux-yank' 普通模式： PREFIX-y复制当前光标后内容到剪切板 复制模式：按下PREFIX-[进入 PREFIX-space选中内容后，按下y复制,按下Y复制并且粘贴到当前命令行 当然你也可以在tmux.conf中设置默认交互的剪切板 # ~/.tmux.conf set -g @yank_selection 'primary' # or 'secondary' or 'clipboard' "},"Linux/Make/":{"url":"Linux/Make/","title":"Make","keywords":"","body":"Makefile 这里是一份教程 基本概念 Makefile主要由目标、依赖、命令构成 targets: prerequisites command command command 规则 隐式规则 当缺乏所需要的文件的编译规则或者链接规则时时会自动 $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 模式规则 %.o:%.c 静态模式规则 $(objects):%.o:%.c 变量 自动变量 $@:target $?:prerequisite newer than target $^: all prerequisite $变量赋值 := 直接赋值 = 间接赋值 ?= 判空赋值（便量不存在,变量存在为空也不会赋值） += 追加赋值 通配符 *在命令中表现为通配符 $(wildcard *.c) $(filter *.o,$(objects):%.o:%.c %在规则和变量赋值中表现为通配符 $(objects):%.o:%.c two := $(foo:%.o=%.c) 函数变量 函数 make有大量的内置函数 # subst （字符替换） $(subst old,new,str) # patsubst （正则表达式替换） $(patsubst pattern,replace,strs) two := $(foo:%.o=%.c) three := $(foo:.o=.c) # if （condition为空或者不存在为假） $(if condition,value1,value2) # call $(call func,arg1,arg2,...) # addprefix （当INC_PATH存在-I开头时不会重复添加） $(addprefix -I,INC_PATH) # fileter $(filter *.o,objects):%.o:*.c 指令 目标 .PHONY: .DEFAULT_GOAL: include|-include|sinclude make命令会在-I指定的目录和系统的include目录下查找include所包含的文件，当为查找到文件且没有构建该文件的规则时，如果是include，make会报错退出，-include忽视会继续执行，sinclude是GNU make下为了和其他make兼容的-inlcude Kconfig kconfig是一种帮助复杂工程配置相互关联的选项的配置文件，Linux内核和嵌入式操作系统zephyr就是用kconfig管理的 Kconfig解析 这里是一份教程 Kconfig可以用C语言相关的库解析，也可以通过Python的包解析，这里我演示如何使用Python的kconfiglib解析 from kconfiglib import Kconfig from menuconfig import menuconfig kconf = Kconfig(filename=\"./Kconfig\") menuconfig(Kconf) kconf.write_autoconf() Kconfig语法 这里是一份教程 通常一份配置文件如下 mainmenu \"Kconfig Demo\" menu \"Test Params setting\" config TEST_ENABLE bool \"Enable test work\" default n help Will print debug information if enable. ... endmenu Kconfig文件有以下内容 config menuconfig:设置标题 choice/endchoice：设置bool和tristate的值 comment：设置评论信息 menu/endmenu：设置菜单 if/endif：设置隐藏块 source：设置config 通常的配置项目如下，config name，然后下面是属性 config name ... 必须配置属性值：\"bool\"/\"tristate\"/\"string\"/\"hex\"/\"int\" bool \"Networking support\" (注：tristate为y/n/m三态，y表选择，n不是不选择，m表示编译到内核） 可以配置提示符: 最多一个 \"prompt\" [\"if\" ] bool promt \"Networking support\" 可以配置默认值： 不限数量，取第一个，如果有if，当if为真时该默认值才起作用 \"default\" [\"if\" ] 可以配置依赖项： 只有当依赖项为真的时候该配置项才可见 bool \"foo\" if BAR default y if BAR depends on BAR bool \"foo\" default y 可以配置关联项： 选中了BAR会导致FOO也变为选中(Y)，使得满足依赖关系 config FOO bool \"Foo Option\" config BAR bool \"Bar Option\" select FOO if BAR 可以配置弱依赖： 当FOO被选择后会自动配置BAZ为选中状态 （如果为int，设置为默认值，如果为bool，设置为y,如果为tristate，设置为y） config FOO tristate \"foo\" imply BAZ config BAZ tristate \"baz\" 可以设置范围： 数值类型可以设置范围 \"range\" [\"if\" ] 可以设置提示词： \"help\" menuconfig (1): menuconfig M if M config C1 config C2 endif (2): menuconfig M config C1 depends on M config C2 depends on M choice \"choice\" [symbol] \"endchoice\" choice prompt \"Fruit options\" config APPLE bool \"Apple\" help Select this option if you like apples. config ORANGE bool \"Orange\" help Select this option if you like oranges. config BANANA bool \"Banana\" help Select this option if you like bananas. endchoice "},"Computer science/":{"url":"Computer science/","title":"Computer science","keywords":"","body":"teamteee.github.io 这里是Teamtee的博客，我希望记录我的生活、学习和思考！欢迎各位来访问。 "},"Computer science/Jyy's PA/":{"url":"Computer science/Jyy's PA/","title":"Jyy's PA","keywords":"","body":"2020 南京大学计算机系统基础习题课 这是我在2023年夯实我基础的首个课程笔记，欢迎大家观看！ 课程主页 视频链接 gcc的替代品 手动选择文件的命令 1.The Missing Course of Your CS Education 主要内容是简介，包括学术诚信和生存指南等等，推荐了下面的课程，无视频 Github 的 “Awesome” 系列 The Missing Course of Your CS Education 2.C 语言拾遗 (1): 机制 c程序的编译如下，gcc通过-E，-s，c来控制过程 .c → 预编译 → .i → 编译 → .s → 汇编 → .o → 链接 → a.out 预编译 预编译也称为元编译，预编译实际上发生的就是宏替换,我们使用gcc -E编译下面的文件，会发现实际上预编译就是将stdio.h文件的内容复制粘贴而已。 #include [info] 宏编译举例 a文件 #include int main(){ #include \"b.inc\" } b文件 printf(\"hello,wolrd\\n\"); 以上这两个文件都可以直接编译 我们已经知道#include的功能就是字符串的替换，那么其实我不需要这么多的定义和函数，能不能我们主动替换掉#include [info] 最小printf文件 我们实际上不需要所有的stdio文件，只需要其中的某一个函数 extern int printf (const char *__restrict __format, ...); int main(){ printf(\"hello,wolrd\\n\") } [warning] 以下代码有什么区别？ #include #include \"stdio.h\" 为什么在没有安装库时会发生错误？ #include 是系统头文件会在系统指定的路径寻找，，\"stdio.h\"是自定义头文件会在当前目录下寻找,你可以通过下面的选项来指定 gcc -I:添加系统头文件寻找路径 gcc -L:添加系统库文件寻找路径 gcc -l:添加编译使用的库文件 gcc --verbose 查看系统编译过程中的详细信息 (verbose是啰嗦的意思，git命令也可以使用--verbose 比如git branch --verbose） [info] gcc实际干了什么？ gcc实际上调用了cc1和ld， .c → cc1 → .s → 汇编 → .o → ld → a.out [info] 有趣的宏编译 以下代码会输出什么？为什么？ #include int main() { #if aa == bb printf(\"Yes\\n\"); #else printf(\"No\\n\"); #endif } 因为aa和bb都不存在，所有相等，#开头的全部消失，保留第一个yes的printf语句 ##的作用是连接两边的字符串 #define SYSTEM sys ## tem 陷害队友的代码 #define true (__LINE__ % 16 != 0 ) 推荐书籍 The Art of Readable Code.pdf 3.C 语言拾遗 (2)：编程实践 编程的首先要原则是编写可读的代码和降低代码的耦合程度 [info]编写可读的代码 不可读=不可维护 人类不可读版 (STFW: clockwise/spiral rule) void (*signal(int sig, void (*func)(int)))(int); 人类可读版 typedef void (*sighandler_t)(int); sighandler_t signal(int, sighandler_t); gcc -E hour.c | indent - [info]c语言指定初始化器 enum { RA, R1, ..., PC }; u8 R[] = { [RA] = 0, // 这是什么语法？？ [R1] = 0, ... [PC] = init_pc, }; [info]降低程序间的耦合程度 ``` // breaks when adding a register define NREG 5 // 隐藏假设max{RA, RB, ... PC} == (NREG - 1) // breaks when changing register size define NREG (sizeof(R) / sizeof(u8)) // 隐藏假设寄存器是8-bit // never breaks define NREG (sizeof(R) / sizeof(R[0])) // 但需要R的定义 // even better (why?) enum { RA, ... , PC, NREG } --- > **[info]编写可读的代码** > typedef union inst { struct { u8 rs : 2, rt: 2, op: 4; } rtype; struct { u8 addr: 4, op: 4; } mtype; } inst_t; define RTYPE(i) u8 rt = (i)->rtype.rt, rs = (i)->rtype.rs; define MTYPE(i) u8 addr = (i)->mtype.addr; void idex() { inst_t cur = (inst_t )&M[pc]; switch (cur->rtype.op) { case 0b0000: { RTYPE(cur); R[rt] = R[rs]; pc++; break; } case 0b0001: { RTYPE(cur); R[rt] += R[rs]; pc++; break; } case 0b1110: { MTYPE(cur); R[RA] = M[addr]; pc++; break; } case 0b1111: { MTYPE(cur); M[addr] = R[RA]; pc++; break; } default: panic(\"invalid instruction at PC = %x\", pc); } } ## 3. 框架代码选讲 (1)：编译运行 主要内容是Git，推荐两个链接 [A Visual Git Reference](https://marklodato.github.io/visual-git-guide/index-en.html) [Visualizing Git Concepts with D3](http://onlywei.github.io/explain-git-with-d3) > **[info]doc as code** > > abstract-machine 有一个彩蛋 ### 提交脚本 ## 4. 框架代码选讲 (2)：编译运行 如何了解一个代码库 find . -name \".c\" -o -name \".h\" | xargs cat | wc -l 如何寻找main()在的位置 find . | xargs grep --color -nse '\\' vim **/main.c > **[info] grep** > > 实际上grep命令是“Global Regular Expression Print”的缩写， > -n显示行号，-s不显示匹配失败的信息，-e指定匹配模式（不知道是啥） > **[info] man** `man getopt`和`man 3 getopt`的区别是，前者查看命令行工具，后者查看C标准库，也可以说用`man -k getopt` > **[info] static与inline** > > 一般在头文件中生命，在C文件内定义，但是你的程序较短且性能攸关，则可以使用 static inline 函数定义在头文件中 # Jyy's PA ## PA0 推荐了Tmux、Vim、Git工具的深入使用，具体的教程参加我的Linux下的[笔记](https://teamtee.github.io/teamtee/Linux/) 其他的包括源码的获取，挺简单的。 ### Makefile #### section 1 `$(deps_config): ;` 是一个空规则。它表示 `deps_config` 中的文件不需要进行任何操作，即使这些文件不存在，也不会报错 deps_config := \\ src/device/Kconfig \\ src/memory/Kconfig \\ src/isa/riscv32/Kconfig \\ /home/teamtee/Desktop/ics2021/nemu/Kconfig include/config/auto.conf: \\ $(deps_config) $(deps_config): ; #### section 2 remove_quote = $(patsubst \"%\",%,$(1)) CC = $(call remove_quote,$(CONFIG_CC)) ## PA1 ### 调试器 #### Readline #### Str ```c char *strtok(char *str, const char *delim); C regular C 的正则表达式匹配通过编译+匹配的方式进行匹配，可以通过man regexec查看教程 regcomp用来编译正则表达算式，cflags表示支持的正则表达式语法,编译成功返回0 int regcomp(regex_t *preg, const char *regex, int cflags); regexec用编译好的正则表达式来匹配字符串,匹配成功至少一次后返回0，preg表示编译好的正则表达式，string表示待匹配的字符串，nmatch表示要匹配的pmathc，pmathc用来存储匹配的信息，pmatch有两个变量,rm_so表示匹配到的开始，rm_eo表示匹配到的结束,如果rm_so为-1表示未匹配到，eflags一般取0. int regexec(const regex_t *preg, const char *string, size_t nmatch,regmatch_t pmatch[], int eflags); typedef struct { regoff_t rm_so; regoff_t rm_eo; } regmatch_t; 颜色输出 但我们使用命令的时候可以看到是有颜色输出的，比如ls,实际上命令通常都有一个--color的选项来控制在什么情况下输出字符,如果我们ls --color=true | vim -是可以看到奇怪的输出. 实际上控制台通过以下方式输出颜色 # 其中0；31；42；为控制输出条件 \\033[0;31;42moutput\\033[0m 0-9字体效果：0默认，1高亮，4下划，5闪烁，7反白显示 30-39字体颜色，40-49背景颜色：黑红绿黄蓝紫青白 Kconfig 这里是一份教程 sizeof和 strlen 这里是一份教程 define ARRLE(arr) int(sizof(arr)/sizeof(arr[0])) RISC-V 这里是一份很好的RISC-V 32的资料 "},"Computer science/Compliers/":{"url":"Computer science/Compliers/","title":"Compliers","keywords":"","body":"Compilers and Computer Architecture (G5035) 参考资料 课程主页资料 课程笔记 1.Compilers and computer architecture:introduction 编译器的分为分析和生成俩个阶段：源码解析和代码生成 源码解析通常都发生在编译阶段，但是有的即时编译语言发生在运行时（Just in time compiler） Lexical analysis（词法分析） 编译器的输入通常都是字符串，在这个阶段通过将字符串识别为token int testfun( int n ){ int res = 1; while( n > 0 ){ n--; res *= 2; } return res; } 可以被识别成为 T_int, T_ident ( \"testfun\" ), T_left_brack, T_int, T_ident ( \"n\" ), T_rightbrack, T_left_curly_brack, T_int, T_ident ( \"res\" ), T_eq, T_num ( 1 ), T_semicolon, T_while, ... Syntax analysis/parsing（语法分析） 语法分析将tokens转化为抽选语法树AST（abstract syntax trees） 需要满足两个目标：（1）数的生成组织和解析的快慢（2）语义分析的方便 Senmantic analysis(语义分析） 语法分析可以拒绝语法不合规的项目，但是无法检查语义不合规的项目,检查的关键技巧在于类型检查 void main() { i = 7 int i = 7 ... if ( 3 + true ) > \"hello\" then ... ntermediate code generation（中间码生成） 对于不同的CPU都有不同的机器码，甚至不同的CPU版本的机器码都有差别，因此编译器首先根据AST生成中间码，对中间码进行优化，然后将中间码翻译成对应的机器码。 Optimisation（优化） 通常而言优化器会以减少内存和运行功率作为优化目标，优化是一个NPC问题，因此优化器只是会做最少的优化，特别是对于JIT（即时编译语言）优化更加困难。 Code generatio（代码生成） 将中间码翻译成机器码，因为很相似，因此这一阶段很简单 Complier vs interpreter 翻译器通常比编译器简单，但是编译器只需要编译一次即可永远运行 推荐书籍 Modern Compiler Implementation in Java Compilers - Principles, Techniques and Tools 2.Compilers and computer architecture:From strings to ASTs (1): lexing lexing 词法分析 词法分析类似下面的过程 String: “Synchronised dancing is great!” List(String): [“Synchronised”, “dancing”, “is”, “great”, “!”] List(Token): [Adjective, Noun, Verb, Adverb, Punctuation] 我们需要确定语言的语法结构构成，比如 Keywords (IF, ELSE, WHILE, ...), but not GIRAFFE Identifiers (x, i, username, ...), but not _+++17 Integers (0, 1, 17, -3, ...), but not ... Floating point numbers (2.0, 3.1415, -16.993, ...) Binary operators (+, *, &&, ||, =, ==, !=, :=, ...) Left bracket Right bracket Token boundaries (whitespace, tab-stops, newlines, semicolon, ...) 关键字优先级 最长匹配原则 Look ahead 在下面的语句中for不是一个关键字，而是一个数据类型，但是决定for的token类型需要向后看，向后看的越多编译器效率越低，现代编译器基本上只需要往后看一个字符 int formulaLength = 17; for i = 0 to ... "},"Computer science/Compliers/RISC-V32/":{"url":"Computer science/Compliers/RISC-V32/","title":"RSVC-V32","keywords":"","body":"teamteee.github.io 这里是Teamtee的博客，我希望记录我的生活、学习和思考！欢迎各位来访问。 "},"Tutorial/":{"url":"Tutorial/","title":"Tutorial","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(vimtutor，在linux下安装了vim的话可以输入vimtutor来看教程) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "},"Tutorial/Dian/Linux/":{"url":"Tutorial/Dian/Linux/","title":"Linux/ssh","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(vimtutor，在linux下安装了vim的话可以输入vimtutor来看教程) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "},"Tutorial/Dian/Git/":{"url":"Tutorial/Dian/Git/","title":"Git","keywords":"","body":"Git 从版本控制开始说起 版本管理一直以来都是挺烦人的事情，比如看下面的图 这还只是一个文件，当涉及到网络和多人协作的大型项目时，那简直是恐怖的灾难。不过很显然，在计算机的世界，有需要就会有轮子，如果没有，那就造一个 版本管理的思想 中心化管理 SVN 版本库放在中心服务器，所有人必须获得最新的版本，在最新的版本上提交他们的修改 分布式管理 Git Git 基于差异和分支的管理 存储目录 文件状态： U、M、A 安装Git Linux sudo apt install git Windows:下载Git bash 开始实战 初始化 git init 配置 git config --global user.name \"John Doe\" git config --global user.email johndoe@example.com git config --list 使用 git clone git status git add . git commit -m \"\" git commit git commit -a -m git push git pull 远程 git remote git remote add pb https://github.com/paulboone/ticgit git push origin master 分支 git branch testing git checkout testing git merge hotfix 实践 本地的版本管理 工作区、暂存区、本地仓库 文件、分支、提交 git init git config --global git add . git commit git branch git branch 和别人联网使用 远程仓库 remote "},"DeepLearning/":{"url":"DeepLearning/","title":"DeepLearning","keywords":"","body":"优化器Optim 优化即为寻找最小loss的过程，通常采用梯度下降的算法，关于移动的方向在深度学习里基本上是沿着梯度的方向，但是对于移动的距离，会有不同的解法，朝着所有样本的梯度方向移动是数学里梯度下降法的做法，但是不适合深度学习。 SGD：朝着当前批次的梯度方向移动 θt=θt−1−ηgt−1 \\theta_t = \\theta_{t-1} - \\eta g_{t-1} θ​t​​=θ​t−1​​−ηg​t−1​​ SGDM：朝着当前批次批次和上一次批次的联合梯度方向移动 v=−ηgt−1 v = - \\eta g_{t-1} v=−ηg​t−1​​ θt=θt−1+vt+mvt−1 \\theta_t = \\theta_{t-1} + v_t + m v_{t-1} θ​t​​=θ​t−1​​+v​t​​+mv​t−1​​ Adagrad：朝着当前批次的梯度方向移动，但是大小要考虑过去的梯度均方值 θt=θt−1−η∑i=0t−1gi2gt−1 \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t-1} g_i^2 }} g_{t-1} θ​t​​=θ​t−1​​−​√​∑​i=0​t−1​​g​i​2​​​​​​​η​​g​t−1​​ RMSPro：朝着当前批次的梯度方向移动，但是大小要考虑过去的梯度均方值递减 v1=g0 v_1 = g_0 v​1​​=g​0​​ vt=αvt−1+(1−α)gt−12 v_t =\\alpha v_{t-1} + (1- \\alpha) g_{t-1}^2 v​t​​=αv​t−1​​+(1−α)g​t−1​2​​ θt=θt−1−ηvtgt−1 \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{v_t}} g_{t-1} θ​t​​=θ​t−1​​−​√​v​t​​​​​​​η​​g​t−1​​ （和Adagrad比较更好，因为过去的梯度会累积到很大，会导致后面梯度非常小） Adam：SGDM + RMSPro Tacotron\\Bert\\Transformer\\Big-gan\\MEMO：Adam YOLO\\Mask RNN\\Resnet\\Mask RNN：SGDM 比较：Adam和SGDM Adam：训练较快，但是泛化性不好 SGDM：训练较慢，但是泛化性好 SWATS：Adam->SGDM 解决Adam问题： （1）小的梯度累积会影响突然出现的大梯度：很有可能只有少部分批次会提供大的梯度，但是大的梯度在小的梯度累积下只会走很小的距离 AMSGrad AdaBound 提升SGDM： CNN 卷积神经网络的成功之处在与卷积和池化 卷积可以认为是简化了的全连接层 （1）没有偏差 （2）参数共享 多个输出的卷积可以认为是识别不同特征的通道 池化在于可以通过全局的视角搜寻特征 卷积 首先你明白卷积多基本含义，然后理解卷积不仅仅是在通道内卷积，而且是是跨越多通道的 池化 池化只是在通道内池化，并不跨越不同通道 最大池化、平均池化、注意力池化 RNN 标准神经网络中的所有输入和输出都是相互独立的，但是在某些情况下，例如在预测短语的下一个单词时，前面的单词是必要的，因此必须记住前面的单词。结果，RNN 应运而生，它使用隐藏层来克服这个问题。RNN 最重要的组成部分是隐藏状态，它记住有关序列的特定信息。 RNN 有一个内存，用于存储有关计算的所有信息。它对每个输入采用相同的设置，因为它通过在所有输入或隐藏层上执行相同的任务来产生相同的结果。 RNN通常会用来一对多、多对多、多对一对任务。 Simple RNN 本节点的输出同时取决于当前的输入和隐藏状态。 ElmanRNN将上一次的隐藏层状态作为下一次的隐藏状态，JordanRNN将上一次的输出作为下一次的隐藏状态,下面以Elman为例说明隐藏状态如何起作用 这样的RNN会面临两个问题： （1）梯度消失：LSTM可以解决梯度消失的问题（记忆不会因为一次输出为0就被洗掉） （2）梯度爆炸：因为某一个状态可能累计在隐藏状态中导致不断累积，可以通过Clipping解决 LSTM LSTM的核心就是记忆单元和输入门、输出门、遗忘门，主要步骤如下： （1）记忆单元遗忘： （2）记忆如何更新： （3）记忆如何输出： GRU GRU只有重置门、更新门，没有隐藏记忆单元，会生成隐藏状态 （1）产生候选隐藏状态： （2）输出当前隐藏状态 Bidrectional RNN 拓展 Sequence to Sequence AutoDecoder Pytorch 关于RNN的函数 Pytorch中关于RNN的函数有下面四个，其中nn.RNNBase只是三者共同的祖先，没有forward函数 nn.RNNBase nn.RNN nn.LSTM nn.GRU Transformer Transformer完全是基于Attention和Seq to Seq的模型,论文原文如下Attention Is All You Need,有关Transformer的讲解我不再重复造轮子，请参考Transformer精讲，The Illustrated Transformer Pytorch中关于Transformer的函数 nn.Transformer nn.TransformerEncoder nn.TransformerDecoder nn.TransformerEncoderLayer nn.TransformerDecoderLayer 参考资料 动手学深度学习v2 李宏毅ML2023 "},"DeepLearning/ML2023HW/":{"url":"DeepLearning/ML2023HW/","title":"ML2023HW","keywords":"","body":"作业 HW01 参数优化 MLP模型：（input_feature，dim）->(dim,dim)xlayer ->(dim,1) 特征选择 loss lr batch seed epoch optim loss model model_params feature 1.7 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=2,dim=300 0.6 1.31 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=2,dim=300 0.7 1.13 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=2,dim=300 0.75 1.31 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=2,dim=300 0.9 模型复杂 loss lr batch seed epoch optim loss model model_params feature 5.2 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=4 0.7 3.2 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=16 0.7 4.3 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=2,dim=16 0.7 16 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=3,dim=16 0.7 2.4 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=64 0.7 1.7 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=128 0.7 1.71 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=400 0.7 优化器和批次 loss lr batch seed epoch optim loss model model_params feature 1.13 1e-5 256 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=300 0.7 1.5 1e-5 64 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=300 0.7 1.4 1e-5 32 5201314 5000 Adam CrossEntropyLoss MLP layer=1,dim=300 0.7 1.5 1e-5 32 5201314 5000 SGD CrossEntropyLoss MLP layer=1,dim=300 0.7 1.2 1e-5 32 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=1,dim=300 0.7 0.98 1e-5 4 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=1,dim=300 0.7 1.3 1e-6 4 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=1,dim=300 0.7 100 1e-4 4 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=1,dim=300 0.7 0.95 5e-5 4 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=1,dim=300 0.7 0.88 5e-5 16 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=1,dim=300 0.7 2 5e-5 4 5201314 5000 SGD(m=0.9) CrossEntropyLoss MLP layer=2,dim=300 0.7 结果总结 strong boss不知道用什么架构，过吧 HW02 参数优化 关于特征 acc lr batch seed epoch optim loss model model_params feature 0.53 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=3 0.55 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=5 0.58 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=7 0.60 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=9 0.61 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=11 0.63 1e-4 512 1213 184 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=13 0.64 1e-4 512 1213 221 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=15 0.64 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=17 0.64 1e-4 512 1213 150 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=19 关于层数 acc lr epoch seed batch optim loss model model_params feature 0.64 1e-4 512 1213 512 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=19 0.6526 1e-4 317 1213 512 Adam CrossEntropyLoss MLP layer=3,dim=64 connect=19 0.6543 1e-4 302 1213 512 Adam CrossEntropyLoss MLP layer=4,dim=64 connect=19 0.6546 1e-4 300 1213 512 Adam CrossEntropyLoss MLP layer=8,dim=64 connect=19 0.6520 1e-4 320 1213 512 Adam CrossEntropyLoss MLP layer=12,dim=64 connect=19 0.65 1e-4 512 1213 512 Adam CrossEntropyLoss MLP layer=10,dim=64 connect=19 训练集 acc lr epoch seed batch optim loss model model_params feature 0.64 1e-4 512 1213 512 Adam CrossEntropyLoss MLP layer=2,dim=64 connect=19 0.67 1e-4 70 1213 512 Adam CrossEntropyLoss MLP layer=2,dim=128 connect=19 0.68 1e-4 58 1213 512 Adam CrossEntropyLoss MLP layer=2,dim= 256 connect=19 0.86 0.68 1e-4 70 1213 512 Adam CrossEntropyLoss MLP layer=2,dim=512 connect=19 0.97 0.69 1e-4 8 1213 512 Adam CrossEntropyLoss MLP layer=2,dim= 1024 connect=19 0.98 0.69 1e-4 30 1213 512 Adam CrossEntropyLoss MLP layer=2,dim= 2048 connect=19 关于Droupout Droupout默认放在激活函数后 | 训练集 | acc | lr | epoch | seed | batch | optim | loss | model | model_params | feature | |:------:|:-----:|:----:|:-----:|:----:|:-----:|:------------------:|:----------------:|:-----:|:-----------------:|:----------:| | 0.72 | 0.741 | 1e-4 | 238 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.5) | layer=2,dim=512 | connect=19 | | 0.92 | 0.71 | 1e-4 | 110 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.1) | layer=2,dim= 1024 | connect=19 | | 0.78 | 0.73 | 1e-4 | 100 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.3) | layer=2,dim= 1024 | connect=19 | | 0.80 | 0.748 | 1e-4 | 191 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.5) | layer=2,dim= 1024 | connect=19 | | 0.68 | 0.69 | 1e-4 | 110 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.7) | layer=2,dim= 1024 | connect=19 | | 0.82 | 0.748 | 1e-4 | 100 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.5) | layer=2,dim= 2048 | connect=19 | | 0.70 | 0.74 | 1e-4 | 100 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Droupout=0.7) | layer=2,dim= 2048 | connect=19 | 关于Batchnormal Batchnormal放在激活函数前 | 训练集 | acc | lr | epoch | seed | batch | optim | loss | model | model_params | feature | |:------:|:-----:|:----:|:-----:|:----:|:-----:|:------------------:|:----------------:|:-----:|:-----------------:|:----------:| | 0.97 | 0.68 | 1e-4 | 238 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Batchnorm) | layer=2,dim=2048 | connect=19 | | 0.94 | 0.67 | 1e-4 | 110 | 1213 | 512 | Adam | CrossEntropyLoss | MLP(Batchnorm) | layer=2,dim= 1024 | connect=19 | 关于Dropout和Batchnorm 训练集 acc lr epoch seed batch optim loss model model_params feature 0.80 0.751 1e-4 250 1213 512 Adam CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim=2048 connect=19 0.72 0.741 1e-4 250 1213 512 Adam CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 1024 connect=19 关于Batchsize 训练集 acc lr epoch seed batch optim loss model model_params feature 0.72 0.741 1e-4 250 1213 512 Adam CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 1024 connect=19 0.80（184） 0.748（184） 1e-4 250 1213 256 Adam CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 1024 connect=19 0.81（302） 0.751（301） 1e-4 250 1213 512 Adam CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 2048 connect=19 关于weight_decay 训练集 acc lr epoch seed batch optim loss model model_params feature 0.70 0.73 1e-4 250 1213 512 Adam(wd = 1e-4) CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 1024 connect=19 0.71(284) 0.74(284) 1e-4 250 1213 512 Adam(wd = 1e-5) CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 1024 connect=19 0.71(170) 0.74(170) 1e-4 250 1213 512 Adam CrossEntropyLoss MLP(Droupout=0.5,Batchnorm) layer=2,dim= 2048 connect=19 关于RNN 简单RNN 训练集 acc lr epoch seed batch optim loss model model_params feature 0.95 0.71 1e-4 17 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=2,dim=2048 connect=19 0.94 0.70 1e-4 21 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=2,dim=1024 connect=19 0.83 0.70 1e-4 20 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=2,dim=512 connect=19 0.97(149) 0.71(30) 1e-4 17 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=1,dim=1024 connect=19 0.88(149) 0.70(48) 1e-4 21 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=1,dim=512 connect=19 0.76(128) 0.70(128) 1e-4 17 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=1,dim=256 connect=19 0.68(138) 0.66(138) 1e-4 21 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=1,dim=128 connect=19 0.75(138) 0.71(138) 1e-4 17 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=2,dim=128 connect=19 0.78(108) 0.71(138) 1e-4 17 1213 512 Adam CrossEntropyLoss RNN+fc(line) layer=3 ,dim=128 connect=19 0.76(139) 0.70(138) 1e-4 21 1213 512 Adam CrossEntropyLoss RNN +fc(line+relue+line) layer=1,dim=256 connect=19 0.84(104) 0.71(32) 1e-4 21 1213 512 Adam CrossEntropyLoss RNN +fc(line+relue+line) layer=2,dim=256 connect=19 （垃圾简单RNN，训练的久效果还不好👎） GRU | 训练集 | acc | lr | epoch | seed | batch | optim | loss | model | model_params | feature | |:---------:|:--------:|:----:|:-----:|:----:|:-----:|:-----:|:----------------:|:-----:|:----------------:|:----------:| | 0.90（37） | 0.72（32） | 1e-4 | 17 | 1213 | 512 | Adam | CrossEntropyLoss | GRU(layer=1,dim=256)+fc(line) | layer=1,dim=256 | connect=19 | | 0.83（13） | 0.73（10） | 1e-4 | 17 | 1213 | 512 | Adam | CrossEntropyLoss | GRU(layer=3,dim=256)+fc(line) | layer=3,dim=256 | connect=19 | LSTM 训练集 acc lr seed batch optim loss model feature 0.97（56） 0.72（5） 1e-4 1213 512 Adam CrossEntropyLoss LSTM(droupout=0.5,layer=2,dim=512)+fc(line) connect=19 0.84（14） 0.734（8） 1e-4 1213 128 Adam CrossEntropyLoss prefc(line+Droupout=0.5)+LSTM(droupout=0.5,layer=2,dim=512)+fc(line) connect=19 0.84（14） 0.734（8） 1e-5 1213 128 Adam CrossEntropyLoss prefc(line+Droupout=0.5)+LSTM(droupout=0.5,layer=2,dim=512)+fc(line) connect=19 0.86（212）0.76(33) 0.74（33） 1e-4 1213 1024 Adam CrossEntropyLoss prefc(line+Droupout=0.5)+LSTM(droupout=0.5,layer=2,dim=512)+fc(line) connect=19 0.77（47）0.85(212) 0.74（47）0.69(212) 1e-4 1213 2048 Adam CrossEntropyLoss prefc(line+Droupout=0.5)+LSTM(droupout=0.5,layer=2,dim=512)+fc(line) connect=19 0.92（45）0.86(18) 0.762（18）0.73(45) 1e-4 1213 512 Adam CrossEntropyLoss prefc(line+Droupout=0.5)+LSTM(droupout=0.5,layer=6,dim=450)+fc(line) connect=27 "},"DeepLearning/Pandas/":{"url":"DeepLearning/Pandas/","title":"Pandas","keywords":"","body":"Pands库的使用 这里是一份官方教程 基本概念 Pandas的数据由series和DataFrame组成，通常这两个数据结构的值是可以改变的，但是大小不可改变 series是具有index和name的同类dtype的values数据序列,使用numpy.ndarray来存储数据，pandas只有三种数据类型int (int64)、float (float64)、str(object) ages = pd.Series(index=[0,1,2],value=[22, 35, 58],name=\"Age\",dtype=int) DataFrame是一系列series的集合,每个series具有相同的index和相同的长度，name在dataFrame中组成colunms,DataFrame的index和colunms属性实际上是Series,具有单个类型series的dataFrame同一类型，具备多种类型series的dataFrame为object类型。 df = pd.DataFrame(np.arange(9).reshape(3, 3), index = ['TJ', 'BJ', 'SH'], columns=['q', 'w', 'e']) 基本操作 读取与转化 可以通过字典创建dataFrame,通过列表创建series，也可以通过read_* 类函数和to_*函数进行读取和存储,支持csv、excel、json等等流行文件。 pd.read_excel(\"titanic.xlsx\", sheet_name=\"passengers\") df.to_excel(\"titanic.xlsx\", sheet_name=\"passengers\", index=False) pd.read_csv( \"data/air_quality_long.csv\", index_col=\"date.utc\", parse_dates=True ) 查看信息 df.tail df.head df.info df.dtypes df.shape 数据索引 注意你的到的数据通常和原数据是同一份，修改会改变两者 df[\"age\"] df[[\"age\",\"sex\"]] df[df[\"age\"]>35] df[\"age\"]>35 df[df[\"Pclass\"].isin([2, 3])] df[(df[\"Pclass\"] == 2) | (df[\"Pclass\"] == 3)] df[df[\"Age\"].notna()] df.loc[df[\"Age\"] > 35, \"Name\"] df.iloc[9:25, 2:5] df.iloc[0:3, 3] = \"anonymous\" 统计操作 对series可以求max、mean、median，对于dataFrame可以求corr,也可以通过describe查看多个统计值列表，还可以通过value_counts统计出现的次数 agg函数可以选择多个统计量聚类分析 In [7]: titanic.agg( ...: { ...: \"Age\": [\"min\", \"max\", \"median\", \"skew\"], ...: \"Fare\": [\"min\", \"max\", \"median\", \"mean\"], ...: } ...: ) ...: Out[7]: Age Fare min 0.420000 0.000000 max 80.000000 512.329200 median 28.000000 14.454200 skew 0.389108 NaN mean NaN 32.204208 groupby可以选择将某列值作为分类依据,将原数据分为多组,然后计算某个统计值 In [9]: titanic.groupby(\"Sex\").mean() Out[9]: Sex PassengerId Survived Pclass ... SibSp Parch Fare ... female 431.028662 0.742038 2.159236 ... 0.694268 0.649682 44.479818 male 454.147314 0.188908 2.389948 ... 0.429809 0.235702 25.523893 groupby也可以选择多个列,会对这多个列进行排列组合 In [11]: titanic.groupby([\"Sex\", \"Pclass\"])[\"Fare\"].mean() Out[11]: Sex Pclass female 1 106.125798 2 21.970121 3 16.118810 male 1 67.226127 2 19.741782 3 12.661633 Name: Fare, dtype: float64 value_counts可以统计每一种元素出现的次数 In [12]: titanic[\"Pclass\"].value_counts() Out[12]: Pclass 3 491 1 216 2 184 Name: count, dtype: int64 数据重组 sort_values可以按值排序，sort_index可以按照序列排序 In [7]: titanic.sort_values(by=['Pclass', 'Age'], ascending=False).head() Out[7]: PassengerId Survived Pclass ... Fare Cabin Embarked 851 852 0 3 ... 7.7750 NaN S 116 117 0 3 ... 7.7500 NaN Q 280 281 0 3 ... 7.7500 NaN Q 483 484 1 3 ... 9.5875 NaN S 326 327 0 3 ... 6.2375 NaN S [5 rows x 12 columns] pivot可以从原数据中抽取数据，有两种使用方式 pivot(columns=\"location\", values=\"value\") pivot_table同时可以指定index,但是需要指定聚合方法 air_quality.pivot_table( values=\"value\", index=\"location\", columns=\"parameter\", aggfunc=\"mean\" )_counts melt函数创建透视表 pd.melt(df, id_vars =['Name'], value_vars =['Course'],var_name = \"\",value_name = \"\") 合并表格 concat pd.concat([air_quality_pm25, air_quality_no2], axis=0) pd.concat([air_quality_pm25, air_quality_no2], keys=[\"PM25\", \"NO2\"]) merge 见这篇文章 import pandas as pd left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']}) right = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']}) result = pd.merge(left, right, on='key') # on参数传递的key作为连接键 result Out[4]: A B key C D 0 A0 B0 K0 C0 D0 1 A1 B1 K1 C1 D1 2 A2 B2 K2 C2 D2 3 A3 B3 K3 C3 D3 绘制 ['area', 'bar', 'barh', 'box', 'density', 'hexbin', 'hist', 'kde', 'line', 'pie', 'scatter'] df.plot() plt.show() 映射操作 参考这篇文章 series.map:支持字典，函数 series.apply:支持带参数的函数 dataFrame.apply:函数 dataFrame.applymap:函数 data[\"gender\"].map({\"男\":1, \"女\":0}) data[\"gender\"].map(lambda x:\"%.2f\" % x) addition = lambda x, y: x + y data[\"age\"].apply(addtion,args=(-3,)) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=0) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=1) df.applymap(lambda x:\"%.2f\" % x) 还可以对index和name进行映射，这个函数叫rename air_quality_renamed = air_quality.rename( columns={ \"station_antwerp\": \"BETR801\", \"station_paris\": \"FR04014\", \"station_london\": \"London Westminster\", } ) 时间序列处理和文本处理（TODO） 操作实例 "},"DeepLearning/matplotlib/":{"url":"DeepLearning/matplotlib/","title":"Matplotlib","keywords":"","body":"从零开始学Matplotlib绘图 Matplotlib是绘制图片的利器,支持多种类型的绘制样式,甚至还可以绘制动画,快和我一起来学习吧,本文参考 你好世界 下面是第一个实例 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_axes(rect = [0,0,1,1]) ax.plot(x) ax.set_title(\"Hello world!\") plt.show() 这段实例的主要任务如下 创建一个画布Figure:plt.figure 添加一个画区Axes:fig.add_axes,[左,下,宽,高]=[0,0,1,1] 添加一个画件Artist-Line2D:ax.plot 添加一个画件Artist-Text:ax.set_title 展示绘制图形:plt.show 无限可分 使用figure画图的最重要的功能之一是绘制多个图形在一个画布上,你可以通过下面的函数绘制 fig.subfigures() fig.subfigures的参数如下 nrows, ncols : int,指定划分子图的网格行列数 wspace, hspace : float, 指定子图的水平间距和垂直间距 width_ratios : array-like of length *ncols,指定子图的宽度比,数组长度等同与列数 height_ratios : array-like of length *nrows,指定子图的高度比,数组长度等同与行数 实例如下,你可以看到的确划分成功了,但是不同画区的显示好像重叠了诶？ import numpy as np import matplotlib.pyplot as plt fig = plt.figure() sub_figs = fig.subfigures(2,3,wspace=0.1,hspace=0.2,width_ratios=[0.1,0.6,0.1],height_ratios=[0.5,0.5]) for i in sub_figs: for j in i: j.add_axes([0,0,0.8,0.8,]) plt.show() 我们在划分子区的时候的确将不同子区对应到了不重叠的子画布上,但是子区默认的[左,下,宽,高]=[0,0,0.8,0.8],左和底的开始位置恰好位于边界,自动在当前添加的刻度会超出边界被下一个子图覆盖,修改为这样就好了 j.add_axes([0.2,0.2,0.8,0.8,]) 另一个方法是使用自动布局,layout支持constrained、compressed、tight三种布局,它会帮我们自动的调整被覆盖的位置 fig = plt.figure(layout = \"constrained\") fig.add_axes() fig.add_axes的参数如下,较为简单不做演示 rect:(left,bottom,width,height),表示新 Axes 的尺寸。所有值都是相对于图形宽度和高度的分数。 projection:str,投影类型的名称,用于指定 Axes 的投影方式。可以是预定义的投影类型,如 'aitoff'、'hammer'、'lambert'、'mollweide'、'polar'、'rectilinear',也可以是自定义投影的名称。默认值为 None,表示使用默认的 'rectilinear' 投影。 polar:bool,表示是否使用极坐标投影。如果设置为True,则等效于 projection='polar'。 axes_class:matplotlib.axes.Axes的子类类型,用于实例化新的 Axes 对象。该参数与 projection 和 polar 不兼容。可以使用此参数创建自定义的 Axes 子类对象。有关示例,请参阅 :ref:axisartist_users-guide-index。 sharex、sharey:matplotlib.axes.Axes 对象,用于共享 x 轴或 y 轴。共享轴将具有与共享轴的原始轴相同的限制、刻度和刻度尺度。 fig.add_subplot() fig.subplot具有的参数如下 nrows, ncols,projection,polar,sharex,sharey,label:见上 *args:(row, col, *index*)或者 .SubplotSpec, 默认为 (1, 1, 1),按照指定的行列划分在指定序号的位置创建Axes，.SubplotSpec见下fig.add_gridspec()fig.subplots() fig.subplots具有的参数如下,实际上该函数就是调用的fig.add_subplot nrows, ncols,sharex,sharey width_ratios,height_ratios:list of array,长度和行列对齐,指定宽度和长度比 squeeze:bool控制返回的 Axes 对象的维度,指定后返回一个压缩一维数组(2,3)->(6) subplot_kw:dict,传递给 Figure.add_subplot 方法的关键字参数字典。 gridspec_kw:dict,传递给 gridspec.GridSpec 构造函数的关键字参数字典。 fig.subplot_mosaic() fig.subplot_mosaic的参数如下 sharex,sharey,width_ratios,height_ratios,subplot_kw,,gridspec_kw mosaic:str或者list,指定划分分区的方式,比较灵活,见下面的示例 per_subplot_kw:dict,传递给每个子区的参数 empty_sentinel : str,指定无效占位符,默认为. 当mosaic为str时,.表示无效占位符,两个AA表示名称为A的Axes占用两个位置, import numpy as np import matplotlib.pyplot as plt fig = plt.figure() sub_figs = fig.subplot_mosaic(\"AAC;.BC\") sub_figs['A'].plot(x) 当mosaic为list时 import numpy as np import matplotlib.pyplot as plt inner = [ [\"inner A\"], [\"inner B\"], ] outer_nested_mosaic = [ [\"main\", inner], [\"bottom\", \"bottom\"], ] axd = plt.figure(layout=\"constrained\").subplot_mosaic( outer_nested_mosaic ) plt.show() fig.add_gridspec() 实际上该函数是调用了GridSpec，GridSpec的参数如下 nrows, ncols,wspace，hspace，width_ratios，height_ratios left, bottom right, top : float,指定位置信息，默认为(0.125，0.1，0.9，0.9) 该函数生成的参数可以直接给fig.add_subplot使用 import numpy as np import matplotlib.pyplot as plt fig = plt.figure(layout, facecolor='lightblue') gs = fig.add_gridspec(nrows=3, ncols=3, left=0.05, right=1, hspace=0.5, wspace=0.5) ax0 = fig.add_subplot(gs[:-1, :]) ax1 = fig.add_subplot(gs[-1, :-1]) ax2 = fig.add_subplot(gs[-1, -1]) fig.suptitle('Manual gridspec with right=0.75') 也可以直接在该返回值上绘制subgridspec，然后使用subplots def squiggle_xy(a, b, c, d, i=np.arange(0.0, 2*np.pi, 0.05)): return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d) fig = plt.figure(figsize=(8, 8), layout='constrained') outer_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0) for a in range(4): for b in range(4): # gridspec inside gridspec inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0) axs = inner_grid.subplots() # Create all subplots for the inner grid. for (c, d), ax in np.ndenumerate(axs): ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1)) ax.set(xticks=[], yticks=[]) # show only the outside spines for ax in fig.get_axes(): ss = ax.get_subplotspec() ax.spines.top.set_visible(ss.is_first_row()) ax.spines.bottom.set_visible(ss.is_last_row()) ax.spines.left.set_visible(ss.is_first_col()) ax.spines.right.set_visible(ss.is_last_col()) plt.show() 设置样式 Matlotlib通过画布-画区-画件的内容管理,下面是一些基本的属性,你可以暂时先不用记忆 Figure:matplotlib.figure.Figure Axes:matplotlib.axes._axes.Axes super-_AxesBae: dataLim : .Bbox viewLim : .Bbox xaxis/yaxis:XAxis/YAxis super-Axis: XTick/YTick: super-Tick spines:list of matplotlib.spines.Spines super-Patch transAxes: BboxTransformTo transData: Transform fmt_xdata: None | Formatter = ... fmt_ydata: None | Formatter = ... cursor_to_use: Cursors = ... _AxesBase - 画布 _AxesBase具有的基本属性如下 _AxesBase facecolor:设置背景颜色 frameon:bool,设置边缘是否可见 label:str，设置添加的标题 xscale:str，表示 x 轴的缩放类型。可以是以下字符串之一：'linear'（线性缩放）、'log'（对数缩放）、'symlog'（对称对数缩放）或 'logit'（逻辑刻度缩放）。默认为 'linear' yscale:str,同yscale box_aspect:float,表示图形的盒子宽高比 fmt_xdata:Formatter fmt_ydata:Formatter [info] color 指定颜色的方式有三种 str：g或者green或者C0 'b'/C0 blue 'g'/C1 green 'r'/C2 red 'c'/C3 cyan 'm'/C4 magenta 'y'/C5 yellow 'k'/C6 black 'w'/C7 white tuple: (R,G,B)/(R，G，B，A)元祖，比如(2,34,44),(2,34,44,0.5) str:十六进制字符串，'#008000' 设置空白边缘,Axes有一个隐藏属性ax._xmargin,支持负数表示覆盖 ax.set_xmargin import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xmargin(-0.1) ax.plot(x) plt.show() spines - 封闭线 你注意到上文的实例中有这么一段话,实际上这是在修改Axes.spines属性，spines属性表示四周的封闭线，包含top,bottom,left,right。你可以采用ax.spines.top或者ax.spines['top']等方式来访问,下面的语句为设置可见性 ax.spines.top.set_visible() spines的父类是matplotlib.patches.Patch,它是 matplotlib 中所有二维可视元素的基类,是一个带有面部颜色和边缘颜色的二维可视元素。这个父类包含这些基本属性 edgecolor: 边缘颜色。指定图形对象的边缘颜色，可以是颜色名称、RGB 元组或十六进制字符串。默认值为 None，表示使用 rcParams 中的默认设置。 facecolor: 面部颜色。指定图形对象的面部颜色，可以是颜色名称、RGB 元组或十六进制字符串。默认值为 None，表示使用 rcParams 中的默认设置。 color: 颜色。该参数用于同时设置边缘颜色和面部颜色。如果同时指定了 color、edgecolor 和 facecolor，则 color 的优先级最高。 linewidth:float,线条宽度。指定图形对象的边缘线条的宽度，可以是一个浮点数。默认值为 None，表示使用 rcParams 中的默认设置。 linestyle: 线条样式。指定图形对象的边缘线条的样式，可以是字符串(例如 'solid'、'dashed'、'dotted'、'dashdot')或一个元组。默认值为 None，表示使用 rcParams 中的默认设置。 antialiased:bool 抗锯齿效果。指定是否开启图形对象的抗锯齿效果，可以是布尔值。默认值为 None，表示使用 rcParams 中的默认设置。 hatch:str 填充图案。指定图形对象的填充图案，可以是字符串(例如 '/'、'\\\\'、'x'、'+')。默认值为 None，表示不使用填充图案。 fill: bool填充。指定是否填充图形对象的面部。默认值为 True，表示填充面部。 capstyle: str线条端点样式。指定图形对象的线条端点的样式，可以是字符串(例如 'butt'、'round'、'projecting')。默认值为 None，表示使用 rcParams 中的默认设置。 joinstyle: str线条连接样式。指定图形对象的线条连接处的样式，可以是字符串(例如 'miter'、'round'、'bevel')。默认值为 None，表示使用 rcParams 中的默认设置。 _transform:坐标变换(TODO) import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_title(\"Hello world!\") ax.spines['top'].set_color('C0') fig.set_frameon(False) plt.show() [info] linestle 指定线形的方式可以是'solod'或者`'-' '-' solid '--' dashed '-.' dash-dot ':' dotted xaxis/yaxis - 坐标轴 xaxis/yaxis是XAxis/YAxis的实例，XAxis/YAxis继承Axis类，同时还具有一个继承了Tick类的XTick/YTick的属性. Axis是 matplotlib 中用于表示坐标轴的类 Axis: major : matplotlib.axis.Ticker,表示主刻度 minor : matplotlib.axis.Ticker，表示副刻度 callbacks : matplotlib.cbook.CallbackRegistry label : .Text，坐标轴标签 labelpad : float，坐标轴标签和坐标轴的距离 offsetText : .Text majorTicks : list of .Tick,主刻度列表 minorTicks : list of .Tick，副刻度列表 你可以通过下面的函数修改坐标轴label和labelpad,实际上调用的函数均为ax.xaxis.label.set_text和ax.xaxis.label.update的封装 ax.set_xlabel(xlabel:str,fontdict=None:str,labelpad=None:float,*,loc=None:str, **kwargs) ax.xaxis.set_label_text(label:str,fontdict:dict,**kwargs) [info] loc loc =['center','left','right]' [info] fontdict import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xlabel(\"nihao\",labelpad=10,loc=\"right\") plt.show() Ticker 刻度 设置刻度线边界set_xbound实际上调用的就是set_xlim ax.set_xlim ax.set_xbound left : float, right : float, emit : bool, default: True，是否通知observers界限的改变 auto : bool or None, default: False,是否打开axis的autoscaling xmin, xmax : float, optional，等同与left和right但是不能同时传递 示例 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xlim(1,2) ax.plot(x) plt.show() 设置主要刻度线的位置和显示文本 ax.set_xticks ax.set_xticklabels import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.plot(x) ax.xaxis.offsetText.set_text(\"Custom Text\") ax.set_xticks([1,2,3,4]) ax.set_xticklabels(['a','b','c','d']) plt.show() 设置刻度线的尺度,支持'log','linear','logit','symlog' ax.set_xscale('log') 设置刻度线 ax.set_tick_params() ax.xaxis.set_tick_params() axis：指定要设置的坐标轴，可以是 'x'、'y' 或 'both'(xaxis无）。 which：指定要设置的刻度线，可以是 'major'、'minor' 或 'both'。 direction：指定刻度线的方向，可以是 'in'、'out' 或 'inout'。 length：指定刻度线的长度。 width：指定刻度线的宽度。 color：指定刻度线的颜色。 pad：指定刻度标签与刻度线之间的间距。 labelsize：指定刻度标签的字体大小。 labelcolor：指定刻度标签的颜色。 bottom、top、left、right：指定是否显示底部、顶部、左侧、右侧的刻度线。 labelbottom、labeltop、labelleft、labelright import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.plot(x) ax.xaxis.set_tick_params(which='major', width=2, length=10) plt.show() Ticker有两个属性，当然通常情况下我们不需要操作底层的这两个属性,要详细的设置可以参考下面的例子 _locator : matplotlib.ticker.Locator 决定刻度的位置 _formatter : matplotlib.ticker.Formatter 决定刻度的格式 axis中包含两个Ticker，major和minor，分别表示主刻度和副刻度,你可以通过下面的函数获取这些属性 ax.xaxis.get_major_locator ax.xaxis.set_major_locator ax.xaxis.get_major_formatter ax.xaxis.set_major_locator ... 简单的使用formatter ax0.xaxis.set_major_formatter('{x} km') ax1.xaxis.set_major_formatter(lambda x, pos: str(x-5)) locator Locator 支持下面这些类 注意：默认情况下小刻度处于关闭状态（使用NullLocator和NullFormatter） FixedLocator：根据固定位置列表生成刻度。 AutoLocator：根据数据范围和轴长度自动计算刻度位置。 MultipleLocator：在指定基准刻度间隔的倍数上生成刻度。 MaxNLocator：根据指定的最大刻度数量自动计算刻度位置。 LogLocator：在对数刻度上生成刻度。 IndexLocator：根据指定的索引间隔生成刻度。 DateLocator：在日期轴上生成刻度。 比如下面的例子 def setup(ax, title): \"\"\"Set up common parameters for the Axes in the example.\"\"\" # only show the bottom spine ax.yaxis.set_major_locator(ticker.NullLocator()) ax.spines[['left', 'right', 'top']].set_visible(False) ax.xaxis.set_ticks_position('bottom') ax.tick_params(which='major', width=1.00, length=5) ax.tick_params(which='minor', width=0.75, length=2.5) ax.set_xlim(0, 5) ax.set_ylim(0, 1) ax.text(0.0, 0.2, title, transform=ax.transAxes, fontsize=14, fontname='Monospace', color='tab:blue') fig, axs = plt.subplots(8, 1, layout='constrained') # Null Locator setup(axs[0], title=\"NullLocator()\") axs[0].xaxis.set_major_locator(ticker.NullLocator()) axs[0].xaxis.set_minor_locator(ticker.NullLocator()) # Multiple Locator setup(axs[1], title=\"MultipleLocator(0.5)\") axs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5)) axs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1)) # Fixed Locator setup(axs[2], title=\"FixedLocator([0, 1, 5])\") axs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5])) axs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4))) # Linear Locator setup(axs[3], title=\"LinearLocator(numticks=3)\") axs[3].xaxis.set_major_locator(ticker.LinearLocator(3)) axs[3].xaxis.set_minor_locator(ticker.LinearLocator(31)) # Index Locator setup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\") axs[4].plot(range(0, 5), [0]*5, color='white') axs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25)) # Auto Locator setup(axs[5], title=\"AutoLocator()\") axs[5].xaxis.set_major_locator(ticker.AutoLocator()) axs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator()) # MaxN Locator setup(axs[6], title=\"MaxNLocator(n=4)\") axs[6].xaxis.set_major_locator(ticker.MaxNLocator(4)) axs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40)) # Log Locator setup(axs[7], title=\"LogLocator(base=10, numticks=15)\") axs[7].set_xlim(10**3, 10**10) axs[7].set_xscale('log') axs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15)) plt.show() formatter Formatter支持下面这些类 StrMethodFormatter：使用字符串的格式方法进行格式化，可以使用类似于 '{}'.format 的格式字符串。 FuncFormatter：使用用户定义的函数进行格式化，函数接受刻度值为参数，返回格式化后的字符串。 ScalarFormatter：对刻度值进行标量格式化，可以指定刻度值的精度、科学计数法等。 FormatStrFormatter：使用格式字符串进行格式化，可以使用类似于 '%.2f' 的格式字符串。 LogFormatter：对对数刻度的刻度标签进行格式化。 PercentFormatter：将刻度值转换为百分比格式。 def setup(ax, title): \"\"\"Set up common parameters for the Axes in the example.\"\"\" # only show the bottom spine ax.yaxis.set_major_locator(ticker.NullLocator()) ax.spines[['left', 'right', 'top']].set_visible(False) # define tick positions ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00)) ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25)) ax.xaxis.set_ticks_position('bottom') ax.tick_params(which='major', width=1.00, length=5) ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10) ax.set_xlim(0, 5) ax.set_ylim(0, 1) ax.text(0.0, 0.2, title, transform=ax.transAxes, fontsize=14, fontname='Monospace', color='tab:blue') fig = plt.figure(figsize=(8, 8), layout='constrained') fig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5]) fig0.suptitle('String Formatting', fontsize=16, x=0, ha='left') ax0 = fig0.subplots() setup(ax0, title=\"'{x} km'\") ax0.xaxis.set_major_formatter('{x} km') fig1.suptitle('Function Formatting', fontsize=16, x=0, ha='left') ax1 = fig1.subplots() setup(ax1, title=\"def(x, pos): return str(x-5)\") ax1.xaxis.set_major_formatter(lambda x, pos: str(x-5)) fig2.suptitle('Formatter Object Formatting', fontsize=16, x=0, ha='left') axs2 = fig2.subplots(7, 1) setup(axs2[0], title=\"NullFormatter()\") axs2[0].xaxis.set_major_formatter(ticker.NullFormatter()) setup(axs2[1], title=\"StrMethodFormatter('{x:.3f}')\") axs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:.3f}\")) setup(axs2[2], title=\"FormatStrFormatter('#%d')\") axs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter(\"#%d\")) def fmt_two_digits(x, pos): return f'[{x:.2f}]' setup(axs2[3], title='FuncFormatter(\"[{:.2f}]\".format)') axs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits)) setup(axs2[4], title=\"FixedFormatter(['A', 'B', 'C', 'D', 'E', 'F'])\") # FixedFormatter should only be used together with FixedLocator. # Otherwise, one cannot be sure where the labels will end up. positions = [0, 1, 2, 3, 4, 5] labels = ['A', 'B', 'C', 'D', 'E', 'F'] axs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions)) axs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels)) setup(axs2[5], title=\"ScalarFormatter()\") axs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True)) setup(axs2[6], title=\"PercentFormatter(xmax=5)\") axs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5)) Tick(忽略） majorTicks和minorTicks根据Ticker来生成一个list Tick tick1line : .Line2D The left/bottom tick marker. tick2line : .Line2D The right/top tick marker. gridline : .Line2D The grid line associated with the label position. label1 : .Text The left/bottom tick label. label2 : .Text The right/top tick label. 添加画件 你可以用ax.add_artist添加任何你想要的画件 plot-Line2D - 线性绘图 实际上ax.plot(x,y)等同于 from matplotlib.lines import Line2D line = Line2D(x,y) ax.add_artist(line) Line2D支持的参数 xdata：绘制线条的 x 坐标数据，一个浮点数序列。 ydata：绘制线条的 y 坐标数据，一个浮点数序列。 linewidth：线条的宽度，一个浮点数，默认为 None。 linestyle：线条的样式，一个字符串，默认为 None。 color：线条的颜色，一个颜色值，默认为 None。 marker：线条上数据点的标记样式，一个字符串，默认为 None。 markersize：线条上数据点标记的大小，一个浮点数，默认为 None。 markeredgewidth：线条上数据点标记的边缘宽度，一个浮点数，默认为 None。 markeredgecolor：线条上数据点标记的边缘颜色，一个颜色值，默认为 None。 markerfacecolor：线条上数据点标记的填充颜色，一个颜色值，默认为 None。 markerfacecoloralt：线条上数据点标记的备用填充颜色，一个颜色值，默认为 None。 fillstyle：线条上数据点标记的填充样式，一个字符串，默认为 None。 antialiased：线条是否进行抗锯齿渲染，一个布尔值，默认为 None。 dash_capstyle：线条端点的样式，一个 CapStyle 枚举值，默认为 None。 solid_capstyle：实线端点的样式，一个 CapStyle 枚举值，默认为 None。 dash_joinstyle：线条连接点的样式，一个 JoinStyle 枚举值，默认为 None。 solid_joinstyle：实线连接点的样式，一个 JoinStyle 枚举值，默认为 None。 pickradius：线条上数据点的拾取半径，一个浮点数，默认为 None。 drawstyle：线条绘制的方式，一个字符串，默认为 \"default\"。可选值包括 \"default\"、\"steps\"、\"steps-pre\"、\"steps-mid\" 和 \"steps-post\"。 [info] CapStyle CapStyle.BUTT：线条端点为平直的方形，不延伸过线条的末端。 CapStyle.ROUND：线条端点为圆形。 CapStyle.PROJECTING：线条端点为方形，延伸过线条的末端。 [info] CapStyle JoinStyle.MITER：连接点为尖角。 JoinStyle.ROUND：连接点为圆角。 JoinStyle.BEVEL：连接点为平直的斜角 [info] drawstyle \"default\"：默认绘制方式，线条将按照给定的坐标点顺序进行插值和绘制 \"steps\"：绘制阶梯线条，线条会在每个坐标点之间垂直或水平连接，形成阶梯状的线条。 \"steps-pre\"：与 \"steps\" 类似，但是线条是从前一个坐标点开始绘制的。 \"steps-mid\"：与 \"steps\" 类似，但是线条是从当前坐标点的中间位置开始绘制的。 \"steps-post\"：与 \"steps\" 类似，但是线条是从当前坐标点结束位置开始绘制的。 plot的封装还支持更多的功能，比如fmt，data,或者同时绘制两个Line2D plot([x], y, [fmt], *, data=None, **kwargs) plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs) format = '[marker][line][color]' plot(x, y, 'bo') #绘制蓝色线条圆圈标记 [info]Markers ============= =============================== character description ============= =============================== ``'.'`` point marker ``','`` pixel marker ``'o'`` circle marker ``'v'`` triangle_down marker ``'^'`` triangle_up marker ``''`` triangle_right marker ``'1'`` tri_down marker ``'2'`` tri_up marker ``'3'`` tri_left marker ``'4'`` tri_right marker ``'8'`` octagon marker ``'s'`` square marker ``'p'`` pentagon marker ``'P'`` plus (filled) marker ``'*'`` star marker ``'h'`` hexagon1 marker ``'H'`` hexagon2 marker ``'+'`` plus marker ``'x'`` x marker ``'X'`` x (filled) marker ``'D'`` diamond marker ``'d'`` thin_diamond marker ``'|'`` vline marker ``'_'`` hline marker ============= =============================== x/y是类型数组的数据,可以·和data联合起来支持dict、pandas.DataFrame np.random.seed(19680801) # seed the random number generator. data = {'a': np.arange(50), 'c': np.random.randint(0, 50, 50), 'd': np.random.randn(50)} data['b'] = data['a'] + 10 * np.random.randn(50) data['d'] = np.abs(data['d']) * 100 ax.scatter('a', 'b', c='c', s='d', data=data) 进阶玩法 动态绘图 首先先建立一个基本概念，交互模式与非交互模式 pyplot.ion:打开交互模式 pyplot.ioff:关闭交换模式 pyplot.isinteractive:查看是否为交互模式 pyplot.show:显示所有绘图 pyplot.pause:显示一段时间 "},"Leetcode/":{"url":"Leetcode/","title":"Leetcode","keywords":"","body":"经典算法实现 排序算法 冒泡法 归并排序 堆排序 快速排序 希尔排序 经典数据结构 Leetcode 刷题 \\mathcal{O}(n) \\Omega(n) \\Theta(n) "}}