{"./":{"url":"./","title":"Introduction","keywords":"","body":"欢迎👏 这是我的一份云笔记库，欢迎参观！ "},"课程记录/":{"url":"课程记录/","title":"课程记录","keywords":"","body":"笔记系列 计算机 系统基础 《计算机系统基础》 名称:《计算机系统基础》 类型:课程 作者:袁春风 说明:在MOOC和B站可以直接搜 操作系统 操作系统:三个简单的部分（OSTEP） 名称:操作系统:三个简单的部分（OSTEP） 类型:书籍 资源:操作系统:三个简单的部分（OSTEP、课后作业链接、课后答案 作者: 说明:简单易懂，适合入门 南京大学计算机系统基础习题课 名称: 类型:课程 资源:课程主页、视频链接 作者:蒋炎炎 说明:较难，建议掌握更多的技能后解锁 编译原理 Compilers and Computer Architecture (G5035) 名称:Compilers and Computer Architecture (G5035) 类型:课程 资源:课程主页资料 作者: 说明:编译器课程 编程语言 C Unix环境高级编程（APUE） 名称:Unix环境高级编程（APUE） 类型:书籍 资源:MeiK2333的答案、我的笔记 作者: 说明:讲解详细，资料推荐 嵌入式C语言自我修养 名称:嵌入式C语言自我修养 类型:网站 资源:嵌入式C语言自我修养 作者: 说明:讲解C语言的高级部分Python 零基础入门Python 名称:零基础入门Python 类型:书籍、视频 资源:B站视频视频 作者:小甲鱼 说明:通熟易懂 官方文档 名称:官方文档 类型:网页 资源:网站 作者: 说明: C++ 最优资料:CS106L CS106LPDF stackoverflow资料合集推荐 A Tour of C++中文版pdf: Goolge C++ style 参考文档 名称:参考文档 类型:网页 资源:网站 作者: 说明: 语音 Kaldi Kaldi Tutorial 名称:Kaldi Tutorial 类型:网页 资源:网站 作者: 说明: Kaldi siki学院 名称:Kaldi Tutorial 类型:网页 资源:网站 作者: 说明:数据集 AIshare1 178小时中文对话，400小时 数字语音处理 名称: 类型:课程 资源:网站 作者:台大教授李琳山 说明: 3D建模 3D one Blender 推荐 官方文本教程 "},"课程记录/DeepLearning/":{"url":"课程记录/DeepLearning/","title":"DeepLeaning","keywords":"","body":"优化器Optim 优化即为寻找最小loss的过程，通常采用梯度下降的算法，关于移动的方向在深度学习里基本上是沿着梯度的方向，但是对于移动的距离，会有不同的解法，朝着所有样本的梯度方向移动是数学里梯度下降法的做法，但是不适合深度学习。 SGD：朝着当前批次的梯度方向移动 θt=θt−1−ηgt−1\r \\theta_t = \\theta_{t-1} - \\eta g_{t-1}\r θ​t​​=θ​t−1​​−ηg​t−1​​ SGDM：朝着当前批次批次和上一次批次的联合梯度方向移动 v=−ηgt−1\r v = - \\eta g_{t-1} \r v=−ηg​t−1​​ θt=θt−1+vt+mvt−1\r \\theta_t = \\theta_{t-1} + v_t + m v_{t-1}\r θ​t​​=θ​t−1​​+v​t​​+mv​t−1​​ Adagrad：朝着当前批次的梯度方向移动，但是大小要考虑过去的梯度均方值 θt=θt−1−η∑i=0t−1gi2gt−1\r \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{\\sum_{i=0}^{t-1} g_i^2 }} g_{t-1}\r θ​t​​=θ​t−1​​−​√​∑​i=0​t−1​​g​i​2​​​​​​​η​​g​t−1​​ RMSPro：朝着当前批次的梯度方向移动，但是大小要考虑过去的梯度均方值递减 v1=g0\r v_1 = g_0\r v​1​​=g​0​​ vt=αvt−1+(1−α)gt−12\r v_t =\\alpha v_{t-1} + (1- \\alpha) g_{t-1}^2\r v​t​​=αv​t−1​​+(1−α)g​t−1​2​​ θt=θt−1−ηvtgt−1\r \\theta_t = \\theta_{t-1} - \\frac{\\eta}{\\sqrt{v_t}} g_{t-1}\r θ​t​​=θ​t−1​​−​√​v​t​​​​​​​η​​g​t−1​​ （和Adagrad比较更好，因为过去的梯度会累积到很大，会导致后面梯度非常小） Adam：SGDM + RMSPro Tacotron\\Bert\\Transformer\\Big-gan\\MEMO：Adam YOLO\\Mask RNN\\Resnet\\Mask RNN：SGDM 比较：Adam和SGDM Adam：训练较快，但是泛化性不好 SGDM：训练较慢，但是泛化性好 SWATS：Adam->SGDM 解决Adam问题： （1）小的梯度累积会影响突然出现的大梯度：很有可能只有少部分批次会提供大的梯度，但是大的梯度在小的梯度累积下只会走很小的距离 AMSGrad AdaBound 提升SGDM： CNN 卷积神经网络的成功之处在与卷积和池化 卷积可以认为是简化了的全连接层 （1）没有偏差 （2）参数共享 多个输出的卷积可以认为是识别不同特征的通道 池化在于可以通过全局的视角搜寻特征 卷积 首先你明白卷积多基本含义，然后理解卷积不仅仅是在通道内卷积，而且是是跨越多通道的 池化 池化只是在通道内池化，并不跨越不同通道 最大池化、平均池化、注意力池化 RNN 标准神经网络中的所有输入和输出都是相互独立的，但是在某些情况下，例如在预测短语的下一个单词时，前面的单词是必要的，因此必须记住前面的单词。结果，RNN 应运而生，它使用隐藏层来克服这个问题。RNN 最重要的组成部分是隐藏状态，它记住有关序列的特定信息。 RNN 有一个内存，用于存储有关计算的所有信息。它对每个输入采用相同的设置，因为它通过在所有输入或隐藏层上执行相同的任务来产生相同的结果。 RNN通常会用来一对多、多对多、多对一对任务。 Simple RNN 本节点的输出同时取决于当前的输入和隐藏状态。 ElmanRNN将上一次的隐藏层状态作为下一次的隐藏状态，JordanRNN将上一次的输出作为下一次的隐藏状态,下面以Elman为例说明隐藏状态如何起作用 这样的RNN会面临两个问题： （1）梯度消失：LSTM可以解决梯度消失的问题（记忆不会因为一次输出为0就被洗掉） （2）梯度爆炸：因为某一个状态可能累计在隐藏状态中导致不断累积，可以通过Clipping解决 LSTM LSTM的核心就是记忆单元和输入门、输出门、遗忘门，主要步骤如下： （1）记忆单元遗忘： （2）记忆如何更新： （3）记忆如何输出： GRU GRU只有重置门、更新门，没有隐藏记忆单元，会生成隐藏状态 （1）产生候选隐藏状态： （2）输出当前隐藏状态 Bidrectional RNN 拓展 Sequence to Sequence AutoDecoder Pytorch 关于RNN的函数 Pytorch中关于RNN的函数有下面四个，其中nn.RNNBase只是三者共同的祖先，没有forward函数 nn.RNNBase nn.RNN nn.LSTM nn.GRU Transformer Transformer完全是基于Attention和Seq to Seq的模型,论文原文如下Attention Is All You Need,有关Transformer的讲解我不再重复造轮子，请参考Transformer精讲，The Illustrated Transformer Pytorch中关于Transformer的函数 nn.Transformer nn.TransformerEncoder nn.TransformerDecoder nn.TransformerEncoderLayer nn.TransformerDecoderLayer 参考资料 动手学深度学习v2 李宏毅ML2023 "},"课程记录/Python/":{"url":"课程记录/Python/","title":"Python","keywords":"","body":"类与对象 Python中类和对象的所有属性可以通过dir函数查看，dir() 函数用于列出对象的所有属性和方法。当你调用 dir(obj) 时，它会返回对象 obj 所有可以访问的属性、方法和特殊属性的列表，包括类属性 ['__class__', '__delattr__', '__dict__', '__dir__', '__doc__', '__format__', '__ge__', '__getattribute__', '__getstate__', '__gt__', '__hash__', '__init__', '__init_subclass__', '__le__', '__lt__', '__module__', '__ne__', '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__setattr__', '__sizeof__', '__str__', '__subclasshook__', '__weakref__'] 值得一提的是 · dict 用于管理 slot属性 slot = [ 'a'] 类方法和静态方法 @classmethod def func(cls): print(cls) 类的表示 str repr str的代偿是repr，反之不是 切片、索引、迭代 切片、索引迭代实际上是调用slice函数，slice函数最终调用getitem和setitem函数 a = [1,2,3,4,5,6,7,8] a[1:4] = a[slice(1,4,None)]或者a[slice(1,4)] a[1:6:2] = a[slice(1,6,2)] 当你定义了下面的函数后就支持索引了 getitem(self,index) setitem(self,index,value) 类的属性访问 getattribute(self,name) getattr(self,name) setattr(self,name,value) delattr(self,name) 访问属性调用的首先调用getattribute,grattr是getattribute的代偿 类的对象访问 get(self,instance,owner) set(self,instance,value) delete(self,instance) [info] 注意 get和__getattrbute的区别是，前者访问整个对象或者类，后者访问对象或者类的属性 描述符 定义了getattr、setattr、delattr三个函数之一的类被称为描述符，描述符的作用是拦截类的属性的访问、修改、删除，但是对实例对象的访问无效 property描述符 一个简单的property的定义如下 class MyProperty: def __init__(self,fget=None,fset=None,fdel=None): self.fget = fget self.fset = fset self.fdel = fdel def __get__(self,instance,owner): return self.fget(instance) def __set__(self,instance,value): return self.fset(instance,value) def __delete__(self,instance): return self.fdel(instance) def __setter(self,fset): self.fset = fset def __deleter(self,fdel): self.fdel = fdel 用法如下 class c: def __init__(self): self._x = 1 def fget(self): return self._x def fset(self,value): self._x = value def fdel(slef): del self._x x = MyProperty(fget,fset,fdel) class c: def __init__(self): self._x = 1 @MyProperty def x(self): return self._x @x.setter def x(self,value): self._x = value @x.deleter def x(self): del self._x 其中 @MyProperty def x(self): return self._x 等同于 def fget(self): return self._x x = MyProperty(fget) 数据描述符与非数据描述符 当访问一个的属性时，访问的顺序是:数据描述符、对象属性(dict)、非数据描述符、类属性(MRO原则查找继承关系属性) 只定义getattr被称为，非数据描述符 定义了getattr与后两者的其中至少一个被称为数据描述符 class A: def __get__(self,instance,owner): print(\"get\") class B: b = A() B.b get B.b = 1 B.b 1 class A: def __get__(self,instance,owner): print(\"get\") def __set__(self,instance,value): print(\"set) class B: b = A() B.b get B.b = 1 B.b set set_name(self,owner,name):可以解决绑定属性名的传递问题,比如下面的函数中x=c(),执行init后会自动执行set_name并且将x作为name，d作为owner传递进去，实现类和实例名字的绑定 class c: def __set_name__(self,owner,name): self.name = name self.owner = owner class d: x = c() "},"课程记录/C++/":{"url":"课程记录/C++/","title":"C++","keywords":"","body":"Hello world 本课程记录根据CS106B/L 2024系列课程，前者比后者简单，推荐有其他语言基础的直接从CS106L入手，课程主页. 主要内容 CH2：类型与机构 C++简介 C++ = Basic sytax + STL(Standard Template Libary) C++ 具有命名空间，支持函数重载 C++ 是一门\"静态类型的“、\"编译的\" C++ 支持auto Pair和Tuple pair是STL的结构体，定义如下 struct Pair { fill_in_type first; fill_in_type second; }; pair实例 auto info = std::make_pair(\"WangFang\",27); std::couttuple与pair类似，但是获取元素需要通过get函数 std::tuple test= std::make_tuple(1,2,\"2\"); std::cout(test); Structured Binding (C++ 17) 通过Auto和Pair/Tuple用于返回多个值 std:: tuplegetClassInfo(){ std::string className = \"Cs106L\"; std::string buildingName= \"Turing Auditorium\" ;std: :string language =\"C++\"; return {className, buildingName, language}; } int main(){ auto [className, buildingName, language ] = getClassInfo(); std: :cout CH3:Initialization and References 初始化参考参考 Initialization 复制初始化: int a = 5,调用operater=函数 直接初始化: int a(5),调用构造函数，比如 MyClass(int a) : data(a) {} 复制初始化和列表初始化不会检查类型，支持narrow-convert，下面都会被转化为int,值为12int a = 12.5; int a(12.5); 列表初始化: int a{5},调用列表构造函数，比如Myclass(std::initializer_list values) 聚合初始化: int a = {5},不调用构造函数，进行成员的逐个初始化 列表初始化初始和聚合初始化不允许发生narrow-convert，int a{5.0}会报错 Reference 引用只能引用左值 L Value and R Value 左值是程序向系统申请了地址空间的值，存储在内存当中，可以取地址的，右值是临时产生的值，存放在寄存器中，不可以取地址 CH4:Contianer vector实际上是数组，包含有_size和_capcity两个隐藏属性 push_back back insert erase deque双端队列实际上是数组链表，每个链接指向能够容纳8（通常）个元素的数组 有序的集合需要定义元素的比较操作符，无序的需要定义元素的哈希函数，通常后者更快 set insert erase find CH5:Stream 基本概念 流的本质是一个streambuf std::streambuf rdbuf()可以获取streambuf的指针，streambuf支持sputc/sputn函数来输入，或者sgetc/sgetn函数来读取 ofstream, ifstream 和fstream是对前者的高级封装 通过good,fail,eof'bad四个状态来管理流 通过位置指针std::streampos来管理读写位置 通过std::ios::openmode来管理读写行为 通过std::ios::fmtflgas来管理流的行为 封装、>>操作符和函数write、read 提供操作标志 状态管理 good:正常读写 fail:某次读写失败，未来读写都会失败 eof:到达末尾，未来读写都会失败 bad:遇到未知错误，未来读写都会失败 可以通过fail函数查看状态，下面的操作符实际上返回的就是的标字位good的值stringstream ss(\"13 14 Hello world\\n 23\") int num; while(ss>>num){ cout Openmode 默认的openmode如下 fstream f(\"a.txt\", ios_base::in | ios_base::out); ifstream g(\"a.txt\", ios_base::in); ofstream h(\"a.txt\", ios_base::out); openmode如下，并不互相矛盾 std::ios::in，提供写封装 std::ios::out，提供读封装 std::ios::ate，可以修改写指针，指针开始处于结尾，但是默认为Trunc的模式，会覆盖掉打开的文件内容 std::ios::app，写指针无法被修改，始终处于末尾 std::ios::trunc，截断原文件 std::ios::binary，将内容是为二进制而非文本 注意初始化的时候默认写指针处于开始，下面的情况需要使用ate或者app stringstream ss(\"Hello world\\n\"); ssfmtflgas #include int main() { const int num = 150; // using fmtflags as class member constants: std::cout.setf(std::ios_base::hex, std::ios_base::basefield); std::cout.setf(std::ios_base::showbase); std::cout >和getline() >>操作符会跳过输入流中的空白字符（包括空格、制表符、换行符等），直到遇到非空白字符为止。这意味着，当使用 >>操作符读取数据时，如果输入流中存在空白字符，则会被自动跳过，直到找到下一个非空白字符，不会消耗空白符号、 getline的默认行为等同于getline(ofs,buff,'\\n'),读取数据直到遇见分割符号，会消耗掉分割符 \\n和std::endl std::end =\\n+std::flush(),通常而言我们不主动刷新性能会好很多，刷新是昂贵的 CH6 Iterators and Pointers iterators有五个层次 input:支持auto elem = *it output:支持*it = elem forward:支持it增加，比如++; bidirection:支持it减少，比如-- Ramdom:支持随机访问，比如it += 5 本质上迭代器就是指向目标元素的指针，支持解引用 std::map map; for(auto iter = map.begin(); iter != map.end(); iter++) { const auto& [key, value] = *iter; // structured binding! } CH7 Classes 重载与继承 子类和父类之间的同名函数（不同参数）不会发生重载，子类的函数会直接覆盖父类 对象切片 C++类似Java，一个类对象有静态类型和动态类型，动态类型主要用于实现多态性，而静态类型则在编译时用于类型检查和确定可调用的方法 Class Base{}; Class Derived:public Base{}; Base obj = Derived(); Base *ptr = new Derived(); 在C++中，obj对象的动态类型和静态类型均为Base，ptr对象的静态类型为Base*,动态类型为Derived*，obj对象之所以动态类型还是Base的原因是发生了对象切片，Derived对象被隐式强制转化为了Base对象，这样的转化会导致Derived对象丢失新添加的属性和方法，同名的方法也以Base为准 虚函数 编译器为所有含有或者继承了虚函数的类生成一个虚函数表，调用函数时通过指针来确定运行时的函数(如果不是虚函数，那么会直接指向代码段中静态类型编译的某个确定函数) 如果类包含虚函数，每一个该类的每个对象需要一个额外的指针; 每个指针都指向额外分配的虚函数表，虚函数可以解决对象切片的问题 纯虚函数与接口 定义了纯虚函数的类被称为接口，纯虚函数没有地址，继承的子类必须实现纯虚函数 CH8:Template Classes and Const Correctness 模板可以用于函数或者类,class和typename相同,支持默认参数 template class Myclass{...} template void func(T t); template func(T t); 注意定义具有模板的类的函数时， template class Myclass{...} template void Myclass::func(){...} [!NOTE] 模板类无法在只是包含头文件的情况下编译，必须在头文件结尾加上#include \"xx.cpp\" const_cast int& findItem(int value) { for (auto& elem: arr) { if (elem == value) return elem; } throw std::out_of_range(“value not found”) } const int& findItem(int value) const { return const_cast((*this).findItem(value)) } Constrains and concept concept是constraint的集合，可以包含一个或者多个constraint 最常见的constraint是requires，编译器对requires进行语义检查 template concept Addable = requires(T a,T b){ a + b; }; 下面两种都是使用concept的方式，都可以 template requires Addable class Myclass{...} template class Myclass{...} 模版还会进行隐式推导concept template concept Derived = std::is_base_of::value; template T> void f(T); // T is constrained by Derived 模版可以用于传递任何东西，包括常量，函数指针，会进行auto推导 template int func(){ return n; } func(); 注意C++内置了很多concept 下面是一些常见的concept 可哈希约束 template concept Hashable = requires(T a) { { std::hash{}(a) } -> std::convertible_to; }; 子类约束 template concept Derived = std::is_base_of::value; 数字类型 #include #include // 约束为整数类型的concept template concept Integral = std::is_integral; // 约束为浮点类型的concept template concept FloatingPoint = std::is_floating_point; // 约束为数字类型的concept（整数或浮点） template concept Numeric = Integral || FloatingPoint; 内置的Concept参考，Requires参考 模版元编程 template metaprogramming 模版会在编译的时候进行替换，因此我们可以通过模版来进行加速 template struct Factorial{ enum {value =n*Factorial::value }; }; template<>//template class \"specializationstruct Factorialfenumfvalue=1}; struct Factorial{ enum { value = 1 }; }; std::cout ::value constexpr 常量表达式 常量表达式是的一种属性，必须在编译的时候就可以确定值，因此必须为const或者常量 constexpr double fib(int n) { // function declared as constexpr if (n == 1) return 1; return fib(n-l) * n; } int main() { const long long bigval = fib(20); std: : cout CH10:Functions and Lambdas 模版函数指针 #include #include using namespace std; bool isVow(char c){ string vowel = \"aioue\"; return vowel.find(c) != string::npos; } template int countOccurrences(InputIt begin,InputIt end,BinPred isTure){ int count=0; for (auto iter =begin;iter !=end;++iter) { if(isTure(*iter)) count++; } return count; } int main(){ std::string test = \"jsfldfjaf\"; std::coutlambdas lambdas由capture-clause、param、Function body组成 capture-clause用于捕获匿名函数外围参数用在匿名函数里面，值捕获相当于副本， [] :不捕获 [limit] :值捕获 [&limit]:引用捕获 [&limit, upper]:引用捕获limit,:值捕获upper [&,limit]:引用捕获所有，除了limit值捕获 [&]:引用捕获所有 [=]:值捕获所有 Functor 重载了()操作符的称为Functor 标准函数转换 lambda、函数指针、functors都能够被转换为标准函数 std::function func; 虚函数 virtual function algorithm any_of all_of none_of for_each find search copy CH11:Operator Overloading 重载操作符由两种方式，成员函数重载，友元函数重载，前者可以使用this，后者不可以 class student { public: friend bool operator 友元函数和普通的全局操作符重载的区别是，友元函数可以访问类的私有变量 //友元函数重载 class student { public: friend bool operator 下面的操作符不可以重载 :: ? . .* sizeof() typeid() cast() 甚至连new都可以重载,注意会影响全局的变量 void * operator new(size_t size); CH12:Special member functions 一个类默认会生成六个特色的成员函数SMF class PasswordManager{ public : PasswordManager(); //默认构造函数 ~PasswordManager(); //默认析构函数 PasswordManager(const PasswordManager& pm); //默认复制构造函数 PasswordManager(PasswordManager&& rhs); //默认移动构造函数 PasswordManager& operator=(const PasswordManager& rhs); //默认复制函数 PasswordManager& operator=(PasswordManager&& rhs); //默认移动复制函数 } 默认函数的构造或者复制是浅copy，可以通过删除SMF来禁止复制或者重写来实现深copy PasswordManager(const PasswordManager& pm) = delete; 当发生如下情况时不会自动生成默认的复制、移动函数 声明了非默认的构造、析构函数 声明了非默认的复制、移动函数 类具有虚函数 类具有独占变量 类有fininal或者overide?? 下面的语句调用的函数如下： 默认构造函数 复制构造函数 初始化列表构造函数 函数声明 复制构造函数 默认构造函数 复制构造函数 复制构造函数 复制函数 继承与析构、构造 派生类的析构和构造函数会覆盖基类的析构和构造函数，但是会隐式默认调用构造和默认析构函数(无论是否派生类调用的构造函数是否参数) #include using namespace std; class base{ public: base(){ cout不过令我惊讶的是，输出如下,即使派生类附带参数，默认调用的基类构造函数仍然是不带参数的Base init，并且调用顺序很有意识 Base init Derived init Derived del Base del Base init Derived init with int params Derived del Base del 移动函数 move 强制使用移动函数 使用const &的地方都可以用move替代 explicit C++存在隐式转化，比如复制函数->复制构造函数：Myclass obj = otherobj; class MyClass { public: MyClass(int value) { /* ... */ } }; void function(MyClass obj) { /* ... */ } int main() { MyClass obj = 10; // 隐式转换，使用 MyClass 的构造函数 function(20); // 同样是隐式转换 return 0; } CH14:Type Safety 当你想要从某个容器中取值的时候，有可能容器为空（或者越界），这时候你可以选择抛出异常，当然也可以通过pair来表示成功与否 int& vector::back(){ return *(begin() + size() - 1); } monadic就是为了处理这种情况下不抛出异常的机制，Monad 这个术语最初来自 Haskell 语言，在C++中有optional来实现,optional可以存放type类型还有nullopt std::optional a; a = std::nullopt; a = 4 if(a.value == std::nullopt) optional还提供三个函数 value():如果有值返回，否则为nullopt抛出异常 value_or(type defalut)：如果有值返回，否则为返回default has_value(): CH15 RAII RAII是\"Resource access is initial\"的缩写,意思是资源获取即初始化（同时及时释放） 下面的资源需要我们获取后及时释放 下面的代码在持有锁的过程中，如果发生异常，锁永远不会被释放 void cleanDatabase(mutex&databaseLock，map&db){ databaseLock.lock(); // no other thread or machine can change database // modify the database // if any exception is thrown,the lock never unlocks! database.unlock(); } lock_guard lock_guard会自动获取锁，并且在离开当前代码段时自动释放锁 void cleanDatabase(mutex&databaseLock，map&db){ lock_guard lg(databaseLock); // } smart pointer 智能指针就是针对内存的锁，可以自动获取释放内存，锁分为三种 std::unique_ptr:不可复制 std::shared_ptr:可以复制 std::weak_ptr unique_ptr独享内存，离开代码范围后自动释放内存，shared_ptr会记录共享内存的指针数量，当没有人持有时才会释放内存，weak_ptr可以访问shared_ptr，但是不会增加共享内存的指针数量 下面时一些实例 void rawPtrFn(){ Node*n=new Node; // do smth with n delete n;} void rawPtrFn(){ std::unique ptr n(new Node); //do something with n //n automatically freed } 还可以这样初始化 std::unique_ptr uniquePtr{new T}; std::shared_ptr sharedPtr{new T}; std::unique_ptr uniquePtr = std::make_unique(); std::shared_ptr sharedPtr = std::make_shared(); std::weak ptrwp=sharedPtr; CH16:My practice std::minmax_element std::mean /std::accumulate std::for_each std::copy std::ostream_iterator "},"课程记录/数字语音处理/":{"url":"课程记录/数字语音处理/","title":"数字语音处理","keywords":"","body":"简介 这是台大的李琳山老师的课程，课程前八节是基础，后八节课是拓展。 PartI: Fundamental Topics 1.0 Introduction to Digital Speech Processing Acoustic Models ：声学模型，语音波形->语音单位（比如音素） Lexicon：词典，语音单位->语言单位（比如字，或者单词或者词语） Language Model：语言模型，比如预测在前一个语言单位下后一个语言单位的概率 2.0 Fundamentals of Speech Recognition HMM (1)Evaluation Problem: Given O =(o1, o2, …ot…oT) and = (A, B,$\\pi$ ),find Prob [ O | $\\pi$ ] (2)Decoding Problem: Given O = (o1, o2, …ot…oT) and = (A, B, $\\pi$),find a best state sequence q = (q1,q2,…qt,…qT) (3)Learning Problem: Given O, find best values for parameters in such that Prob [ O | $\\pi$ ] = max N-dim Guassion Feature Extraction (Front-end Signal Processing) Pre-emphasis Endpoint Detection (Speech/Silence Discrimination) Windowing Rectangular window Hamming window MFCC N-gram MAP(最大后验概率) 3.0 Map of Subject Areas 4.0 More about Hidden Markov Models 5.0 Acoustic Modeling 6.0 Language Modeling 7.0 Speech Signals and Front-end Processing 8.0 Search Algorithms for Speech Recognition Part II: Advanced Topics 9.0 Speech Recognition Updates 10.0 Speech-based Information Retrieval 11.0 Spoken Document Understanding and Organization for User-content Interaction 12.0 Computer-assisted Language Learning(Call) 13.0 Speaker Variabilities: Adaption and Recognition 14.0 Latent Topic Analysis 15.0 Robustness for Acoustic Environment 16.0 Some Fundamental Problem-solving Approaches 17.0 Spoken Dialogues 18.0 Conclusion 语者识别与适应 SI 语者独立 SD 语者相关 SA 语者适应 MAP 最大后验概率 MLLR 最大概率线性压缩 PCA 主成分分析 EigenVoice (PAC) SAT CAT "},"课程记录/Kaldi/":{"url":"课程记录/Kaldi/","title":"Kaldi","keywords":"","body":"# 语音框架：HTK、Kaldi、wenet Prerequisites C++ LDC:LDC93S3A the math library ATLAS;root jieba分词 博客：https://blog.csdn.net/Ephemeroptera/article/details/106634471 ASRT语音识别文档:https://wiki.ailemon.net/docs/asrt-doc/asrt-doc-1deoef82nv83e "},"博客日志/":{"url":"博客日志/","title":"博客日志","keywords":"","body":""},"博客日志/Gitbook/":{"url":"博客日志/Gitbook/","title":"Gitbook","keywords":"","body":""},"博客日志/Gitbook/Gitbook Explore in Mac/":{"url":"博客日志/Gitbook/Gitbook Explore in Mac/","title":"Gitbook的Mac开发环境搭建","keywords":"","body":"[Mac] Gitbook in Mac 最近一直在思考如何学习 ，其中很重要的一环是输出。我曾经使用过语雀、思云等等，尽管它们功能丰富并且支持云端，但是对于像一本书一样阅读，这样的要求是达不到的，因此我选择了Gitbook + Githubpages 一、简单使用 Gitbook有网页版和本地版两种，网页版的功能感觉和语雀等类似，因此我选择本地版。你可以将本地版Gitbook（以下简称Gitbook）认为是一个工具链，这个工具链依赖于Node.js和npm。在mac的教程如下，windos看这个链接 1.安装 brew 在mac下需要先安装开发者工具brew,brew是一个类似apt、yum的包管理工具 /bin/bash -c \"$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/HEAD/install.sh)\" 安装完后命令行输入brew检查是否成功安装 npm 安装完brew后利用brew安装npm，npm是一个Node.js的包管理工具。我们需要用它来安装gitbook。 brew install npm 输入npm -v检查是否安装成功 nvm nvm也是Node.js的版本管理工具，类似Python里面的conda。我们需要用它来管理Node.js的版本。 brew install nvm 输入nvm -v检查是否安装成功 gitbook 使用brew安装gitbook.-g选项的意思安装在全局，否则默认为安装在用户下。 brew install gitbook-cli -g 2.使用 初始化 选择一个你希望的空文件夹，初始化工作目录 # 初始化工作目录会生成 README.md 和 SUMMARY.md gitbook init # 构建工作会默认在 _book 下生成文件 gitbook build # 服务器会构建本地端口映射 gitbook serve 执行gitbook init可能会出现的报错，如下 Installing GitBook 3.2.3 /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287 if (cb) cb.apply(this, arguments) ^ TypeError: cb.apply is not a function at /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/graceful-fs/polyfills.js:287:18 at FSReqCallback.oncomplete (node:fs:200:5) Node.js v21.0.0 这是因为 Node.js 的版本不符合 gitbook 的依赖，下面有三个可能的解决方法（推荐三） 注释polyfills.js文件中的这三行 fs.stat = statFix(fs.stat) fs.fstat = statFix(fs.fstat) fs.lstat = statFix(fs.lstat) 升级graceful-fs # 下面的路径换成你的，--save 的意思是安装在当前的本地，即为更新当前的 graceful-fs cd /opt/homebrew/lib/node_modules/gitbook-cli/node_modules/npm/node_modules/ npm install graceful-fs@latest --save 通过nvm来暂时降低Node.js版本 nvm -v 可能输出如下,箭头为当前的使用版本 $:nvm ls v21.0.0 -> system default -> node (-> v21.0.0) iojs -> N/A (default) unstable -> N/A (default) node -> stable (-> v21.0.0) (default) stable -> 21.0 (-> v21.0.0) (default) lts/* -> lts/hydrogen (-> N/A) lts/argon -> v4.9.1 (-> N/A) lts/boron -> v6.17.1 (-> N/A) lts/carbon -> v8.17.0 (-> N/A) lts/dubnium -> v10.24.1 lts/erbium -> v12.22.12 (-> N/A) lts/fermium -> v14.21.3 (-> N/A) lts/gallium -> v16.20.2 (-> N/A) lts/hydrogen -> v18.18.2 (-> N/A) 我们需要安装10.24.1的版本,注意该段命令会只是会将当前的shell下的Node.js切换成10.24.1。 #Install a specific version number nvm install 10.24.1 #Use the latest available 8.0.x nvm use 10.21.1 二、入门进阶 1.配置文件 SUMMERY.md 一份参考文件如下，这个文件的内容会被用来生成大纲。 []()的超链接用来表示标题， ----会生成分隔符 # Summary的不是必要的，也不会被显示 ## Chapter1会被显示，但是不如超链接好用，一般只用超链接 # Summary ## Chapter1 * [Part I](part1/README.md) * [Writing is nice](part1/README.md#writing) * [GitBook is nice](part1/README.md#gitbook) * [Part II](part2/README.md) * [We love feedback](part2/README.md#feedback) * [Better tools for authors](part2/README.md#tools) ---- * [Last part without title](part3/title.md) book.json 你可以新建一个book.json的配置文件，参考内容如下 { \"title\": \"title\", \"description\": \"description\", \"isbn\": \"isbn\", \"author\": \"author\", \"lang\": \"zh-cn\", \"plugins\": [], \"variables\": { } } 你可以修改plugins来加入插件,search插件支持中文搜索，code插件支持复制,-的意思是不使用该插件，需要使用可以去掉前面的- plugins\": ['code','-seacrh'] 然后利用gitbook install来安装上面的插件 gitbook install 插件可以配置属性 pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } 2.插件推荐 菜单折叠插件 { plugins: ['expandable-chapters']; } 返回顶部插件 { plugins: ['back-to-top-button']; } 引用插件 这里有个教程 { plugins: ['flexible-alerts']; pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat } } } 引用插件语法 > [!NOTE] > Information the user should notice even if skimming. > [!TIP] > Optional information to help a user be more successful. （这个似乎无效） > [!IMPORTANT] > Essential information required for user success. （这个似乎无效） > [!CAUTION] > Negative potential consequences of an action. > [!WARNING] > Dangerous certain consequences of an action. [!NOTE] Information the user should notice even if skimming. 分隔符 [!TIP] Optional information to help a user be more successful. 分隔符 [!WARNING] Dangerous certain consequences of an action. 拓展玩法：自定义引用 有关图标可以在这里寻找 //自定义类型，className可能有info,warning,tip,note pluginsConfig: { \"flexible-alerts\": { style: \"flat\" // callout 或 flat \"comment\": { \"label\": \"Comment\", \"icon\": \"fa fa-comments\", \"className\": \"info\" } } } [!Comment] Dangerous certain consequences of an action. [引用插件] { plugins: ['alerts']; } 效果如下，支持info，waring，danger，successs > **[info] For info** > > Use this for infomation messages. [info] For info Use this for infomation messages. > **[warning] For warning** > > Use this for warning messages. [warning] For warning Use this for warning messages. > **[danger] For danger** > > Use this for danger messages. [danger] For danger Use this for infomation messages > **[success] For success** > > Use this for success messages. [success] For success Use this for success messages. 数学插件 mathjax有问题，总是安装不了，无意间发现了katex可以直接安装 { \"plugins\": [\"katex\"] } 三、深入探索 Github Pages 在github上新建一个仓库，新建个gh-page分支，在github设置支持静态网页的pages。然后我们可以将这个仓库克隆下来，初始化gitbook。不过值得注意的是github只是支持选择/和/docs这两个路径作为网页根目录。因此我们选择/docs，这样的话适合gitbook. 调整gitbook仓库的目录如下,根路径下的README.md作为仓库的说明，book下的README.md作为书籍首页的说明。book可以修改为你喜欢的名字。 . ├── README.md ├── book │ ├── README.md │ ├── SUMMARY.md │ ├── book.json └── docs 同时我们需要修改gitbook命令参数，可以尝试执行如下命令 # 安装book下book.json的插件 gitbook install book # gitbook build src dest gitbook build book docs # gitbook serve src dest gitbook serve book docs 执行后的示例目录 . ├── README.md ├── bash.sh ├── book │ ├── Gitbook Explore in Mac │ ├── How to write markdown elegantly │ ├── README.md │ ├── SUMMARY.md │ ├── book.json │ └── node_modules └── docs ├── Gitbook Explore in Mac ├── How to write markdown elegantly ├── gitbook ├── index.html ├── search_index.json └── search_plus_index.json 自动化脚本 我构建的一份自动更新上传脚本如下，前两行是为了在bash中使用nvm export NVM_DIR=\"$HOME/.nvm\" [ -s \"$NVM_DIR/nvm.sh\" ] && \\. \"$NVM_DIR/nvm.sh\" # 加载 nvm nvm use 10 gitbook install book gitbook build book docs git add . git commit -m \"Update\" git push gitbook serve book docs 输出文档 问题合集 gitbook install 出问题 使用下面的替代 npm install gitbook-plugin-* gitbook install 参考链接 官方下载和安装文档 官方Github仓库 Gitbook操作指南 Gitbook详解 Gitbook攻略（推荐） 插件集合 GitBook CookBook(优秀) "},"博客日志/Gitbook/Markdown语法/":{"url":"博客日志/Gitbook/Markdown语法/","title":"Markdown语法","keywords":"","body":"how to write markdown elegantly 首先你必须明白mardown是有不同的解析器，不同的解析器对于基础的语法都同时支持，但是对于高级的语法就不一定兼容了。比如Github的README.md，Typora，NWeb这些不同的编译器的解析不同，但是本文主要讲解的是基于Gitbook的markdown语法。 基本入门 参考教程 文本样式 粗体：** ** 或者__ __,快捷键CTRL_b 斜线：* * 或者 _ _,快捷键CTRL_i 删除线：~ ~ 下标： 上标： 特殊块 引用文本： > 代码块：``` ``` [!TIP] 如果想在代码块中使用``` ,可以使用```` 代替``` 包裹） 花体：`` `` 行内代码：`` 无序列表：* + - 有序列表：1. (支持嵌套) 任务列表 - [ ] task1 - [x] task2 - [ ] task3 表格 | Heading 1 | Heading 2 | Heading 3 | | --------- | --------- | --------- | | cell 1 | cell 2 | cell 3 | | cell 4 | cell 5 | cell 6 | 折叠表格 My top languages | Rank | Languages | |-----:|-----------| | 1| Javascript| | 2| Python | | 3| SQL | mergaid关系图 graph TD; A-->B; A-->C; B-->D; C-->D; 数学 \\left( \\sum_{k=1}^n a_k b_k \\right)^2 \\leq \\left( \\sum_{k=1}^n a_k^2 \\right) \\left( \\sum_{k=1}^n b_k^2 \\right) 链接 超链接：[]() 图片：或者![](src) 视频： 网页： 转义符号 半方大的空白&ensp;或&#8194; 全方大的空白&emsp;或&#8195; 不断行的空白格&nbsp;或&#160; 如何优雅的插入视频 markdown语法 开始我只是想插入Bilibili的jyy的视频，找到了和markdwon相关的两种方法 视频嵌入 网页嵌入 第一方法markdown会识别有问题，markdown阅读器和gitbook都是 第二个markdown阅读器会整个跳转到Bililibi，不过gitbook还是可以正常编译显示 插件 插件有local、youtuber的，我都没试，但是video-player有问题 安装的时候下面这个不行，得用videoplayer,然后他的语法编译也不成功 { \"plugins\": [\"video-player\"] } 教程见此处， "},"博客日志/Tutorial/":{"url":"博客日志/Tutorial/","title":"Tutorial","keywords":"","body":""},"博客日志/Tutorial/Dian/Linux/":{"url":"博客日志/Tutorial/Dian/Linux/","title":"Linux/ssh","keywords":"","body":"Linux基础 Linux的环境选择 服务器 Windows 虚拟机（推荐） WSL Mac 安装开发者工具brew Linux特点 多用户多任务 大家都知道在计算机发展的早期是非常昂贵的，一个学校通常只有一台计算机，但是一个人的任务不可能完全的消耗掉计算机的计算资源，于是就有人突发奇想，能不能同时几个人同时用计算机执行多个任务，于是多用户的管理系统原型就诞生了，而Linux的诞生延续的这样一种思想。 权限管理 Linux有这么多的用户，如何管理是个大麻烦，万一有人偷偷删掉了我的文件怎么办？Linux通过一套读写执行权限系统和用户分组来限制不合法的行为。首先用户分为root用户和普通用户，普通用户无法更改系统的文件，也无法更改属于他人的文件。 文件系统 对Linux而言，任何事物都是一堆0和1组成的文件，包括显卡、处理器、内存等等。甚至以后的脑机接口，对计算机而言，你的大脑只不过是能够输入和输出01的文件摆了 Linux 假设你是一名魔法师，你需要沟通异世界的魔物，来产生无所不能的威力，那么你显然不能正常的对魔物说“快给我变出一堆黄金来”，你必须使用特定的咒语，一个字都不能错，任何微小的错误都会导致模法的失效。在计算机世界也是如此，你需要和机器沟通，这种咒语在Linux上就是命令行。       魔法师 -> 咒语 -> 魔物     你 -> Linux命令行 -> 机器 命令展示 ls pwd cd 找个男人 你已经知道了三个命令，但是突然有一天你忘记了怎么使用ls了，怎么办？你可以找个男人解决这个问题。 man ls 当然身为新时代的独立的他/她/它，怎么可以随随便便就找这个男人呢？况且这个男人太啰嗦了，随随便便就会说一大堆,别急你还有备胎。 tldr ls 安装命令 当你兴冲冲的准备找你的备胎tldr的时候，你发现了一件悲催的事情，报错了，你悲催发现你没有备胎。都别急，让我先急。实际上命令就像windows的软件一样，有些是自带的，有些需要你安装，显然man是自带的，而备胎tldr需要安装。 在windows世界里，有windows xp、windows 10、windows 11等等，Linux世界也一样，有很多Linux的发行版，比如ubantu、centos等等。在这些不同的发行版里，是使用不同的命令行安装工具，比如yum、apt等等，不过都大同小异。 以apt为例，你可以通过以下命令安装 sudo apt install tldr 权限管理 也许有人试过下面的命令，但是报错显示不允许，为什么？因为你不是高贵的root用户，你无法更改系统的设置，但是你可以通过加入sudo权限组来间接的拥有root权限。 apt install tldr Linux的权限分为读/写/执行，可以通过以下命令查看,开头信息分别为：文件类型-拥有者权限-所在组权限-其他用户权限 拥有者 创建者 文件名。 ls -l ll 这个权限状态可以通过三位的二进制码来表示,100表示读，010表示写，001表示执行。然后你知道5代表什么权限吗？ 肯定要有人问如何修改权限，如何修改拥有者？当然就是chmod和chown了。什么你不会？找那个男人或者备胎，也可以上网搜索答案。 用户管理 鲁迅曾经说过世界上只有两种人,一种是root,一种就是普通用户,事实上在linux的世界就是如此。每个用户都有一个ID，root用户为1,普通用户为1000以上,使用命令可以查看信息 cat /etc/passwd 输出格式->用户名：口令：用户标识号:组标识号：注释性描述;主目录:登录Shell 查看有没有sudo权限 cat /etc/sudoers 当然还有很多关于用户管理的命令,大家自行学习（不是管理员一般用不到） useradd groupadd usermod passwd 文件系统 万物的起源是什么？我今天就来告诉你是/.在根目录下面是 / ├── bin # 所有⽤⼾可执⾏的⽂件 ├── boot # 引导器和内核 ├── dev # 设备⽂件 ├── etc # 配置⽂件 ├── home # ⽤⼾主⽬录 ├── libxx # 动态库 .so ├── media # 可移出设备的挂载点 ├── mnt # 临时挂载点 ├── opt # ⾃带依赖的软件 ├── proc # 包含内核和进程信息的虚拟⽂件系统 ├── root # root ⽤⼾的主⽬录 ├── run # 运⾏时⽂件⽬录，如进程 pid ⽂件，套接字⽂件 ├── sbin # 只有 root ⽤⼾可执⾏的⽂件 ├── sys # 包含内核和系统信息的虚拟⽂件系统 ├── tmp # 临时⽂件系统 ├── usr # Unix System Resources 的缩写，存放软件 └── var # 存放经常变化的⽂件，如⽇志 进程和内存管理 每一个任务都有标号 等待你开发的宝藏 文件管理 - cd, pwd, mkdir, rmdir, ls, cp, rm, mv, tar 文件检索 - cat, more, less, head, tail, file, find 输入输出控制 - 重定向, 管道, tee, xargs 文本处理 - vim, grep, awk, sed, sort, wc, uniq, cut, tr 网络相关: wget curl 系统监控 - jobs, ps, top, kill, free, demsg, lsof 勇者大战史莱姆 你已经成为一名合格的勇者了，是时候开始屠龙了!,你要面临的第一个问题是如何编辑文本。有很多编辑命令，比如Emacs、vim。我推荐Vim.(vimtutor，在linux下安装了vim的话可以输入vimtutor来看教程) 中级魔法师 初级的魔法师只会一次使用一种咒语，但是中级的魔法师可以一次使用多种咒语，这种神奇的操作就是管道pipe。什么是管道呢？是一边送水一边接水的铜管？事实上的确如此。 find . -name \"*.c\" -o -name \"*.h\" | cat | wc -l 除此之外，中级魔法师还会调动和存储环境当中的魔法元素，而不是所有的魔力都必须要自己输入,这就是重镜像. ls > test.txt ls >> test.txt tr a b 中级魔法师还会控制魔力的流向黑洞 flsj 2& > /dev/null` 成熟的中级魔法师还会偷懒,使用脚本。 #!/bin/bash ... SSH 登陆 ssh fyg@192.168.0.11 ssh -p fyg 免密登陆-密钥 ssh-keygen ssh-copy-id -i Vscode配置ssh Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 跳板机 Host Dian11 HostName 192.168.0.11 User fyg IdentityFile ~/.ssh/dian11 ProxyCommand ssh -q -W %h:%p Dian_Public Host Dian_Public HostName 192.168.0.XX User fyg IdentityFile ~/.ssh/dian_public 计算级网络相关 网址——ip 主机-DHCP-域名解析器 NAT-桥接-主机 最后 这是一次很简单的培训，目的是为了让大家认识Linux，而不是将Linux的全部灌输给大家，这样效果也会很不好，因此本文的任务主要是引导大家学习，让大家认识到Linux有哪些东西。 如果有问题：RTFW 下面推荐学习资料： 《Linux就该这么学》 MIT-Missing-Semester 作业 大家做作业的时候肯定会遇到很多的困难，这是非常正常的，因为这对于你们来说是一个陌生领域的任务。而学会在陌生领域摸爬打滚的能力是你们需要解决的，不会怎么办？到处问，上网搜，问AI都可以。 以下的作业大家自觉做，不会检查。 命令实践 给定文本 （1）提取/etc/passwd下的用户名和组别，以下面的格式输出 name group root 1 ... （2）给定一个工程找到main函数所在的目录 apt (1) 使用apt或者yum安装tree，tldr，vim,python (2) 学会apt换源 ssh （1）直连接：在自己的windows上用ssh连接服务器或者自己的虚拟机/WSL （2）跳转：在寝室用跳板机连接服务器（暂时不做，有问题） 服务器公共服务器信息 IP：dian.group.org user：public port：2222 passwd：ljzzy@beibei 用户管理 （1）创建一个新用户 （2）加入sudo权限 网络 （1） 下载一个文件 （2） 打包成tar或者zip格式 （3） 解压缩 进程 （1）后台执行一个命令 （2） 替换到前台 （3） 建立一个忽视ssh断开信号的进程 更多的作业参考上面MIT的课程 "},"博客日志/Tutorial/Dian/Git/":{"url":"博客日志/Tutorial/Dian/Git/","title":"Git","keywords":"","body":"Git 从版本控制开始说起 版本管理一直以来都是挺烦人的事情，比如看下面的图 这还只是一个文件，当涉及到网络和多人协作的大型项目时，那简直是恐怖的灾难。不过很显然，在计算机的世界，有需要就会有轮子，如果没有，那就造一个 版本管理的思想 中心化管理 SVN 版本库放在中心服务器，所有人必须获得最新的版本，在最新的版本上提交他们的修改 分布式管理 Git Git 基于差异和分支的管理 存储目录 文件状态： U、M、A 安装Git Linux sudo apt install git Windows:下载Git bash 开始实战 初始化 git init 配置 git config --global user.name \"John Doe\" git config --global user.email johndoe@example.com git config --list 使用 git clone git status git add . git commit -m \"\" git commit git commit -a -m git push git pull 远程 git remote git remote add pb https://github.com/paulboone/ticgit git push origin master 分支 git branch testing git checkout testing git merge hotfix 实践 本地的版本管理 工作区、暂存区、本地仓库 文件、分支、提交 git init git config --global git add . git commit git branch git branch 和别人联网使用 远程仓库 remote "},"速查笔记/":{"url":"速查笔记/","title":"速查笔记","keywords":"","body":""},"速查笔记/Linux/":{"url":"速查笔记/Linux/","title":"Linux","keywords":"","body":"Linux 剪切板 基于X11的系统通常有两个剪切板 PRIMARY - 鼠标选择复制和粘贴(鼠标中键或右键菜单可复制） SECOND (几乎废弃） CLIPBOARD - CRTL-c/v 选择复制和粘贴 不过似乎我的电脑键盘和鼠标共用一个剪切板，当然你也可以编辑设置 你可以通过xclip或则Xsel和剪切板通信 xclip xclip的用法很简单，支持复制文件,支持选择剪切板,支持管道 xclip filename xclip -sel clipboard xclip -select primary echo \"fs\" | xclip "},"速查笔记/Linux/Vim/":{"url":"速查笔记/Linux/Vim/","title":"Vim","keywords":"","body":"Vim 在命令行中输入vimtutor可以进入教程(目前进度user_10) 模式 vim有下面几种模式 普通模式:默认的模式面板，可以使用一些快捷命令 命令模式:在普通模式输入:进入，按下Esc退出 编辑模式:在普通模式中输入i、o、c、a均可进入,按下Esc退出 块/列块模式:在普通模式输入v/CTRL-v进入块/列块模式,按下Esc退出 普通模式 普通模式下可以使用这些命令 编辑命令 d:删除命令，命令格式为d+位置（dw，de，dd，d2w) y:复制命令，命令格式为y+位置(yw,ye,yy) p:粘贴命令 u:撤销命令，撤销上次修改 C-R:恢复命令，恢复上次的撤销 x:字母剪切命令 r:字母替换命令 R:持续替换命令 位置跳转 w:单词头 e:单词尾 $:句子结尾 ^:句子开头 gg:文章开头 G:文章结尾 %:配对符号跳转 [[:按照C语言特性跳转到当前函数开头 ]]:按照C语言特性跳转到当前函数结尾 ]c/[c:跳转到上次修改的地方 :行内位置跳转 Ctrl-f/b:跳转一页 编辑模式: i:直接输入 c:纠删输入 o:下新行输入 O:上新行输入 a:前输入 A:后输入 查找命令 按下/全文查找，按下？下文查找，回车确认，n跳转到下一个查找，N跳转到上一个,下面是查找相关的配置 :set ic # 忽略大小写 :set noic # :set hls is # 设置high light search :nohlsearch :hls :set incsearch # 不知道有什么用 命令模式 文件命令 :edit:编辑命令 :edit *.txt:编辑命令 :write one.txt:写入命令 :file main.c:重命名命令 :saveas :编辑命令 :w保存命令 :q退出命令 :!执行外部命令 :read file.txt:读取文件 :0read file.txt:读取第一行 编辑命令 substitute/s 替换命令，命令格式如下 [位置]s/旧字符/新字符/[gc]`:g表示所有项，c表示询问每一项 位置：绝对位置(4，6)，相对位置(.-3,&-4),标记位置(',.m,$,%,^,) :4,6s/old/new/g # 替换4-6行的内容 :%s/ld*c/ld/g #替换全文内容 :'s// #配合块模式使用 :.write file.txt:.表示当前光标位置 :.,$s/yes/no/ :45s :4,5s :.+3,$-5s 可以用加号+、等号= 替换/ :s+one/two+one or two+ 中，or :?^Chapter?,/^Chapter/s=grey=gray=g help 帮助命令 :help vimrc-intro :help user-manual 列块模式(TODO) I列编辑 A列添加 ~切换大小写 U小写变大写 u大写变小写 >右移动 :set shiftwidth=4 多文件编辑 你可以同时编辑多个文件，这些文件形成文件列表 vim one.c two.c three.c,编辑两个文件 或者使用下面的命令 :args 查看当前文件列表 :args five.c six.c seven.h 形成新的文件列表 :argadd 添加文件到文件列表 :argdel :next 下一个文件 :previous 上一个文件 :last 最后一个文件 :first 第一个文件 寄存器(TODO) A会追加内容到寄存器a中，a表示覆盖,Y等于y$ \"aY \"AY 标记mark 你可以使用标记来跳转，甚至包括跨越文件跳转 匿名mark 当你使用位置跳转时下面会自动记录你的位置，形成一条有序队列 CTLR-I：标记往前 CTLR-O：标记往后 下面是固定记录的匿名mark ':跳转前光标位置 \":上一次编辑位置 [:Start of the last change ]:End of the last change 记名mark :marks 查看所有记命mark ma:标记名为a的mark `a:跳转到名为a的mark 'a:跳转到名为a的mark 窗口管理(TODO) 新建立 vim -o/O 1.txt 2.txt vimdiff main.c~ main.c CTLR-w:在窗口间跳转 4CTLR-w +/-:改变大小 CTRL-h/i/j/k: CTRL-t/b: :split :split two.c :vsplit :close :only :new :vertical new :qall :wall 配置文件 :edit ~/.vimrc 这是 Unix 系统所使用的命令 :edit ~/_vimrc 这是 MS-Windows 系统所使用的命令 :r $VIMRUNTIME/vimrc_example.vim :write 查看配置 :options :set nowarp 自动折叠 :set sidescroll=10 设置边框滚动条？ :set list 查看tabs :syntax enable 语法检查 :syntax off :set background=dark 设置背景 :colorscheme evening :set autowrite 自动保存 :set noautowrite :set backup 备份文件 :set backupext=.bak 包 mkdir -p ~/.vim/pack/fancy在.vimrc中加入 packadd! matchit 插件 插件位置 system plugin directory Unix ~/.vim/plugin/ PC $HOME/vimfiles/plugin or $VIM/vimfiles/plugin Amiga s:vimfiles/plugin Macintosh $VIM:vimfiles:plugin Mac OS X ~/.vim/plugin/ 拓展 如何让Vim和Linux共用剪切板+clipboard 参考教程 Vim 需要+clipboard功能标志才能使这些功能发挥作用,你可以通过在 Vim 中使用:echo has('clipboard')来检查你的 Vim 是否有这个功能，返回1表示有，如果没有，请安装 Debian 和 Ubuntu:安装vim-gtk3. Fedora:安装vim-X11并运行vimx（vim更多信息）。 Arch Linux:安装gvim（这也将+clipboard正常启用） 基于X11的系统通常有两个剪切板(比如Linux) PRIMARY - 鼠标选择复制和粘贴 CLIPBOARD - CRTL-c/v 选择复制和粘贴 Vim同样有两个特殊的寄存器和这两个剪切板相关联 * - PRIMARY + - CLIPBOARD 对于Windows和OS X系统而言只有一个剪切板,所以这两个没有区别 你可以直接使用这两个寄存器 \"*yy \"*p 你可以重新设置匿名寄存器set clipboard=unnamed set clipboard=unnamedplus 当然你也可以重新映射快捷键noremap y \"*y noremap p \"*p noremap Y \"+y noremap P \"+p vim -R 1.txtvim -M 1.txt :set modifiable :set write c语言跳转-ctags自动建立记名跳转 (TODO) "},"速查笔记/Linux/Git/":{"url":"速查笔记/Linux/Git/","title":"Git","keywords":"","body":"Git 这里有一份官方教程 基本概念 工作区、暂存区、仓库 提交的名字 一次提交有三种类型的名字：哈希名(真名)、分支名、Tag名 基础用法 修改提交git add . git commit -m \" \" git push 覆盖上一次提交 git add . git commit --amend -m \"\" git push --force git log 拉取并解决冲突 git fetch git merge orgin/main git merge abort //合并失败，恢复原状 设置 git config --global core.editor emacs git config --global --list git config --list --show-origin git config --global https.proxy https://localhost:7890 git config --global http.proxy http://localhost:7890 查看状态git status -s git status git log --oneline --decorate --graph --all 切换分支git checkout git checkout - //返回上一次分支 撤销文件修改git checkout -- //修改工作区 git checkout -- //修改工作区 git restore //修改工作区 git restore --source=HEAD //修改工作区 git reset //撤销暂存区修改 移动HEAD指针git reset --soft //不修改工作区、暂存区 git reset --mixed //不修改工作区，修改暂存区 git reset --hard //修改工作区，修改暂存区 taggit tag git tag -l \"1.8.5\" git tag -a v1.4 -m \"my version 1.4\" git tag -a v1.2 9fceb02 git tag -d v1.4 git push origin --tags // tag必须主动push 分支管理 ```bash git checkout -b - 修改原程 ```bash git remote set-head origin branchA git remote set-head origin -d 使用技巧 .gitignore .gitignore 的格式规范如下： 所有空行或者以 # 开头的行都会被 Git 忽略。 可以使用标准的 glob 模式匹配，它会递归地应用在整个工作区中。 匹配模式可以以（/）开头防止递归。 匹配模式可以以（/）结尾指定目录。 要忽略指定模式以外的文件或目录，可以在模式前加上叹号（!）取反 glob 模式是指 shell 所使用的简化了的正则表达式。 支持*，？，[abc],[a-z]星号。 使用两个星号**表示匹配任意中间目录。 分支指代 HEAD～ resotre git restore --sourece --staged --worktree file 分支合并(TODO) --continue --abort 分支合并有merge和rebase方法,git pull时会自动调用git merge,git merge首次要求设定ff或者rebase的配置值。 git stash git pull git stash pop "},"速查笔记/Linux/Tmux/":{"url":"速查笔记/Linux/Tmux/","title":"Tmux","keywords":"","body":"Tmux 这里是一份教程,可以参考。 基本概念 从服务的角度：server - client tmux有一个server管理多个client，每个client和一个session连接,用户启动tmux的时候实际上是启动一个client连接到server。client是伪终端，进程实际由server管理,当用户断开连接后，运行在client中的进程不会被中断。 从显示的角度：session - windows - pane(terminal) 每个session可以与零个或者多个client相连接，每个session的命名必须唯一。每个session管理多个windos,windows的命名可以重复，可以连接一个或者多个session，windows内有多个pane,其中有一个为活跃的pane 当所有的session中的所有进程终止的时候server终止 命令模式 PREFIX 默认为CTRL-b,按下PREFIX b :进入命令模式，按下PREFIX b ?查看所有命令,按下PREFIX b /查看单个命令 rename-windows [name] rename-session [name] Tree 模式 session Tmux有一个模式叫树模式，在Tmux中按下PREFIX b s或者PREFIX b w进入，前者显示当前附着的session的情况，后者显示所有session的情况，还可以通过:choose-tree进入。进入后屏幕分为上部分树和下部分预览。 树模式下可以按下t标记，T取消所有标记，x删除当前项，X删除所有标记项目，也可以用:使用命令对所有的标记项操作。r可以反向排序,v可以取消预览。 client Tmux也有关于client的树模式，按下PREFIX b D进入，可以看到当前活跃的client以及和哪一个session相连接。 基本使用 创建client tmux ls: 列出所有的session tmux: 默认会创建一个client和一个session,等同于tmux new tmux -t session_name: 创建一个client同时连接session 创建session tmux new：创建一个默认的名为index的session（即为名字就是序号) tmux new -syourname: 指定名字为yourname 创建windows :neww: 创建默认窗口，名字为通常为bash :neww -nyourname: 创建窗口同时命名 :neww -t999: 创建窗口同时指定序号为999 :neww top: 创建窗口同时命名和执行改命令top 切换windows PREFIX b [0-9]: 切换窗口为序号[0-9] PREFIX b ': 输入序号然后切换到序号窗口 PREFIX b p: 切换到前窗口 PREFIX b n: 切换到后窗口 创建panes PREFIX b %： 垂直分割 PREFIX b \": 水平分割 切换panes PREFIX b {: 当前pane和上边pane交换位置 PREFIX b }: 当前pane‵和下边pane`交换位置 PREFIX b up/down/right/left: 切换当前聚焦的pane 修改pane的大小 PREFIX b PREFIX up/down/right/left：上下左右微调 PREFIX b M-up/down/right/left： 上下左右大调 PREFIX b M-1/2/3/4/5: 调整布局格式 删除 PREFIX b &: 删除当前session PREFIX b x: 删除当前panes 复制和粘贴 PREFIX b [: 进入复制模式/滚轮模式，复制模式下会冻结输出   PREFIX space:开始选取复制   PREFIX w:结束复制   q: 退出复制 PREFIX b ]: 粘贴上一次复制的文本 PREFIX b =: 选择要粘贴的文本 其他 :set -g mouse on: 支持鼠标 Tmux配置文件（TODO） Tmux插件 可以安装tpm来管理和安装插件 git clone https://github.com/tmux-plugins/tpm ~/.tmux/plugins/tpm 在配置文件内写入~/.tmux.conf # List of plugins set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-sensible' # Other examples: # set -g @plugin 'github_username/plugin_name' # set -g @plugin 'github_username/plugin_name#branch' # set -g @plugin 'git@github.com:user/plugin' # set -g @plugin 'git@bitbucket.com:user/plugin' # Initialize TMUX plugin manager (keep this line at the very bottom of tmux.conf) run '~/.tmux/plugins/tpm/tpm' 在tmux中使用PREFIX b I即可安装 tmux-resurrect 自动保存会话 教程 配置文件 set -g @plugin 'tmux-plugins/tpm' set -g @plugin 'tmux-plugins/tmux-resurrect' set -g @plugin 'tmux-plugins/tmux-continuum' set -g @continuum-save-interval '15' set -g @continuum-restore 'on' set -g @resurrect-capture-pane-contents 'on' ​ # Other config ... ​ run -b '~/.tmux/plugins/tpm/tpm' 快捷键 PREFIX + CTRL s：保存会话 PREFIX + CTRL r：加载会话 tmux-yank 和系统剪切板共用 必须装有xsel或者xclip set -g @plugin 'tmux-plugins/tmux-yank' 普通模式： PREFIX-y复制当前光标后内容到剪切板 复制模式：按下PREFIX-[进入 PREFIX-space选中内容后，按下y复制,按下Y复制并且粘贴到当前命令行 当然你也可以在tmux.conf中设置默认交互的剪切板 # ~/.tmux.conf set -g @yank_selection 'primary' # or 'secondary' or 'clipboard' "},"速查笔记/Linux/Make/":{"url":"速查笔记/Linux/Make/","title":"Make","keywords":"","body":"Makefile 这里是一份教程 基本概念 Makefile主要由目标、依赖、命令构成 targets: prerequisites command command command 规则 隐式规则 当缺乏所需要的文件的编译规则或者链接规则时时会自动 $(CC) -c $(CPPFLAGS) $(CFLAGS) $^ -o $@ $(CXX) -c $(CPPFLAGS) $(CXXFLAGS) $^ -o $@ $(CC) $(LDFLAGS) $^ $(LOADLIBES) $(LDLIBS) -o $@ 模式规则 %.o:%.c 静态模式规则 $(objects):%.o:%.c 变量 自动变量 $@:target $?:prerequisite newer than target $^: all prerequisite $变量赋值 := 直接赋值 = 间接赋值 ?= 判空赋值（便量不存在,变量存在为空也不会赋值） += 追加赋值 通配符 *在命令中表现为通配符 $(wildcard *.c) $(filter *.o,$(objects):%.o:%.c) %在规则和变量赋值中表现为通配符 $(objects):%.o:%.c two := $(foo:%.o=%.c) 函数变量 函数 make有大量的内置函数 # subst （字符替换） $(subst old,new,str) # patsubst （正则表达式替换） $(patsubst pattern,replace,strs) two := $(foo:%.o=%.c) three := $(foo:.o=.c) # if （condition为空或者不存在为假） $(if condition,value1,value2) # call $(call func,arg1,arg2,...) # addprefix （当INC_PATH存在-I开头时不会重复添加） $(addprefix -I,INC_PATH) # fileter $(filter *.o,objects):%.o:*.c 指令 目标 .PHONY: .DEFAULT_GOAL: include|-include|sinclude make命令会在-I指定的目录和系统的include目录下查找include所包含的文件，当为查找到文件且没有构建该文件的规则时，如果是include，make会报错退出，-include忽视会继续执行，sinclude是GNU make下为了和其他make兼容的-inlcude Kconfig kconfig是一种帮助复杂工程配置相互关联的选项的配置文件，Linux内核和嵌入式操作系统zephyr就是用kconfig管理的 Kconfig解析 这里是一份教程 Kconfig可以用C语言相关的库解析，也可以通过Python的包解析，这里我演示如何使用Python的kconfiglib解析 from kconfiglib import Kconfig from menuconfig import menuconfig kconf = Kconfig(filename=\"./Kconfig\") menuconfig(Kconf) kconf.write_autoconf() Kconfig语法 这里是一份教程 通常一份配置文件如下 mainmenu \"Kconfig Demo\" menu \"Test Params setting\" config TEST_ENABLE bool \"Enable test work\" default n help Will print debug information if enable. ... endmenu Kconfig文件有以下内容 config menuconfig:设置标题 choice/endchoice：设置bool和tristate的值 comment：设置评论信息 menu/endmenu：设置菜单 if/endif：设置隐藏块 source：设置config 通常的配置项目如下，config name，然后下面是属性 config name ... 必须配置属性值：\"bool\"/\"tristate\"/\"string\"/\"hex\"/\"int\" bool \"Networking support\" (注：tristate为y/n/m三态，y表选择，n不是不选择，m表示编译到内核) 可以配置提示符: 最多一个 \"prompt\" [\"if\" ] bool promt \"Networking support\" 可以配置默认值： 不限数量，取第一个，如果有if，当if为真时该默认值才起作用 \"default\" [\"if\" ] 可以配置依赖项： 只有当依赖项为真的时候该配置项才可见 bool \"foo\" if BAR default y if BAR depends on BAR bool \"foo\" default y 可以配置关联项： 选中了BAR会导致FOO也变为选中(Y)，使得满足依赖关系 config FOO bool \"Foo Option\" config BAR bool \"Bar Option\" select FOO if BAR 可以配置弱依赖： 当FOO被选择后会自动配置BAZ为选中状态 （如果为int，设置为默认值，如果为bool，设置为y,如果为tristate，设置为y） config FOO tristate \"foo\" imply BAZ config BAZ tristate \"baz\" 可以设置范围： 数值类型可以设置范围 \"range\" [\"if\" ] 可以设置提示词： \"help\" menuconfig (1): menuconfig M if M config C1 config C2 endif (2): menuconfig M config C1 depends on M config C2 depends on M choice \"choice\" [symbol] \"endchoice\" choice prompt \"Fruit options\" config APPLE bool \"Apple\" help Select this option if you like apples. config ORANGE bool \"Orange\" help Select this option if you like oranges. config BANANA bool \"Banana\" help Select this option if you like bananas. endchoice "},"速查笔记/Linux/正则表达式/":{"url":"速查笔记/Linux/正则表达式/","title":"正则表达式","keywords":"","body":"正则表达式的流派 POSIX流派 POSIX 是一系列规范，定义了 UNIX 操作系统应当支持的功能，其中也包括正则表达式的规范 BRE(Basic Regular Expression 基本正则表达式) ERE(Extended Regular Express 扩展正则表达式) 后来随着 BRE 与 ERE 逐渐相互融合，现在的 BRE 和 ERE（包括 GNU 改进的 GNU BRE 和 GNU ERE）在功能特性上并没有太大区别，主要的差异是在元字符的转义上,现在的支持更高基本的正则表达式被称为 MRE(Modern Regular Expressions, MRE) PCRE流派 1988 年 6 月，Larry Wall 开发的 Perl 语言发布第 2 版，其中所引入的正则表达式引擎大放异彩。Perl 2 的正则表达式引擎源于 Henry Spencer 编写的 regex 的增强版。之后不断改进，影响越来越大。于是在此基础上，1997 年又诞生了 pcre ——Perl 兼容正则表达式 (Perl Compatible Regular Expressions)。 Perl 系、Java 系、.Net 系、Python 系、JavaScript 系(另外还有Ruby、C++Builder、Delphi 等) 均属于PCRE 流派，但与Perl 的兼容性(即兼容程度) 各有不同 # 正则表达式是用状态机实现的，通常而言都是贪婪匹配 通配符 次数控制 任意次数 一次以上 {m} m次 {m,n} m-n次数 Bash正则表达式(PAttrn Match) *：匹配任意字符 ？：匹配单个字符 [...]：匹配任意包含的字符，如果第一个字符是^或者!,取反 [:class:] 支持下面的类 alnum alpha ascii blank cntrl digit graph lower print punct space upper word xdigit 在默认的C语言环境中，'[a-dx-z]' 相当于 '[abcdxyz]',许多语言环境按字典顺序对字符进行排序，并且在这些语言环境中 '[a-dx-z]' 通常不等于 '[abcdxyz]';它可能相当于'[aBbCcDdxYyZz]' 想要获得C的风格，可以设置LC_COLLATE或者LC_ALL为'c',或者使能globasciiranges这个shell选项. 如果extglob选择被打开,可以支持 ?(pattern-list)：匹配零个或一个出现的给定模式列表中的模式。 示例：假设你想匹配文件名中包含或不包含数字的文件。你可以使用 ?(pattern-list) 操作符。ls file?(1).txt 这将匹配 file.txt 或 file1.txt。 *(pattern-list)：匹配零个或多个出现的给定模式列表中的模式。 示例：假设你有一组文件，它们的文件名以 image 开头，然后可能跟着一个或多个数字，最后以 .png 结尾。你可以使用 *(pattern-list) 操作符来匹配这些文件名。ls image*.png 这将匹配 image.png，image1.png，image123.png 等文件。 +(pattern-list)：匹配一个或多个出现的给定模式列表中的模式。 示例：假设你有一组文件，它们的文件名以 data 开头，然后跟着一个或多个字母。你可以使用 +(pattern-list) 操作符来匹配这些文件名。ls data+([a-z]).txt 这将匹配 data.txt，dataA.txt，dataABC.txt 等文件。 @(pattern-list)：匹配给定模式列表中的一个模式。 示例：假设你有两个文件，一个是 file1.txt，另一个是 file2.txt。你可以使用 @(pattern-list) 操作符来匹配其中一个文件。ls file@(1|2).txt 这将匹配 file1.txt 或 file2.txt。 !(pattern-list)：匹配除了给定模式列表中的模式之外的任何内容。 示例：假设你有一组文件，其中有一些以数字开头，你想匹配除了以数字开头的文件之外的所有文件。ls !(file[0-9]*) 这将匹配除了以数字开头的文件之外的所有文件。 ${parameter^pattern}： 这个操作符将匹配 pattern 的第一个字符的大小写进行转换：将匹配的小写字母转换为大写字母。 示例：${var^} 将会将 var 中第一个字母转换为大写字母。 ${parameter^^pattern}： 这个操作符将匹配 pattern 的所有字符的大小写进行转换：将匹配的小写字母转换为大写字母。 示例：${var^^} 将会将 var 中所有字母转换为大写字母。 ${parameter,pattern}： 这个操作符将匹配 pattern 的第一个字符的大小写进行转换：将匹配的大写字母转换为小写字母。 示例：${var,} 将会将 var 中第一个字母转换为小写字母。 ${parameter,,pattern}： 这个操作符将匹配 pattern 的所有字符的大小写进行转换：将匹配的大写字母转换为小写字母。 示例：${var,,} 将会将 var 中所有字母转换为小写字母。 在这些操作符中，pattern 是一个用于匹配字符的模式，类似于通配符或正则表达式。如果省略了 pattern，则会默认匹配每个字符，类似于通配符 ? 的行为。 "},"速查笔记/Linux/Bash/":{"url":"速查笔记/Linux/Bash/","title":"Bash","keywords":"","body":"参考资料 GNU官网 阮一峰 Bash 脚本教程 Bash基础语法 变量赋值 greeting=Hello （不可以有空格） 读取变量 $greeting 数学表达 $((express)) 等同于 expr express 设置shell变量 set -- params1 params2 获得输入 read variable 提示输入 read -p \"please input\" variable Bash逻辑控制 函数 定义函数的两种方式,重定向是可选的 fname () compound-command [ redirections ] function fname [()] compound-command [ redirections ] 条件控制 if [ conditions ] then commands elif [ conditions ] then commands else do commands fi 遍历控制 for i in {1..5} do echo $i done for x in string1 string2 string3 do echo $x done 循环控制 i=1 while [[ $i -le 10 ]] ; do echo \"$i\" (( i += 1 )) done Bash条件表达式 数字比较 -eq -ge -gt -le -lt -ne 字符串比较 = == != -z(检查是否为空) -n(检查是否为非空) 逻辑拓展 -a(与) -o(或) 拓展条件表达式[[]] Bash 变量 变量名可以由字母、数字和下画线组成，但是不能以数字开头，不能使用程序中的关键字（保留字），默认类型都是字符串型 local name=value export name=value unset name readonly name 变量按类型分为数字类型、字符串类型，按照作用域分为本地变量、环境变量 数字类型支持的运算符号如下 id++ id-- ++id --id - + ! ~:logical and bitwise negation ** * / % >:left and right bitwise shifts = == != & ^ | && || expr ? expr : expr = *= /= %= += -= >= &= ^= |= expr1 , expr2 变量引用 $var：引用变量 \"$var\"：在字符串内替换变量 ${var}：引用变量，拓展引用提供更多的功能 '$var'：视为普通字符串 $((var))：数学表达式 拓展引用 ${var}:变量替换 ${var-substring}:变量替换,如果var未设置或者为空，替换为给定substring ${var:=substring},变量替换,如果var未设置或者为空，替换并同时设置var为给定substring ${var:?error_info}:变量替换,如果var未设置或者为空,在脚本执行时退出并且在错误输出error_info ${var:+substring}:变量替换,如果var设置且不为空，替换未给定字符串(注意不要看反了) ${patams:offset}:变量索引,从索引处开始到结尾 ${patams:offset:length}，变量索引,从索引处开始长度 [!NOTE] 如果params为普通变量，length支持负数，解释为到末尾的字符偏移量位置，注意负偏移量必须与冒号分隔至少一个空格，以避免混淆'-' ${!prefix*}:拓展为所以以prefex开头的变量，形成单个字符串 ${!prefix@}:拓展为所以以prefex开头的变量，形成多个字符串 $(#var):获取变量长度 ${var#word}：从开头匹配word开头的最短匹配，如果存在则删除 ${var##word}：从开头匹配word开头的最长匹配，如果存在则删除 ${var%word}：从结尾匹配word开头的最短匹配，如果存在则删除 ${var%%word}：从结尾匹配word开头的最长匹配，如果存在则删除 ${parameter/#pattern/string}：从开头匹配pattern开头的最短匹配，如果存在则替换 ${parameter/%pattern/string}：从结尾匹配pattern开头的最短匹配，如果存在则替换 ${parameter/pattern/string}:匹配pattern的第一个，如果存在则替换 ${parameter//pattern/string}：匹配pattern的所有匹配，如果存在则替换 [!NOTE] Pattern Match 注意Bash的通配符不同于正则表达式 支持*，？，[...] shell变量 位置变量 $1 $2, ... ${10} 特殊变量 $# 传递到脚本的参数个数 $* 显示所有向脚本传递的参数 #与位置变量不同，此选项参数可超过9个 $$ 获取当前shell的进程号 $! 执行上一个指令的进程号 $? 获取执行的上一个指令的返回值 #0为执行成功，非零为执行失败 $- 显示shell使用的当前选项，与set命令功能相同 $@ 与$*相同，但是使用时加引号，并在引号中返回每个参数 [info] declare Use this for infomation messages. # 声明一个字符串变量 declare my_var=\"Hello, world!\" # 声明一个只读变量 declare -r readonly_var=\"This variable is read-only\" # 声明一个整数变量 declare -i num=10 num=num+5 # 这里的值将会是 15，因为 num 被声明为整数类型，所以会进行数学运算 # 声明一个数组变量 declare -a my_array=(1 2 3 4 5) # 声明一个环境变量 declare -x ENV_VAR=\"Environment variable\" Array变量 array变量可以通过@和*引用 array=(0 1 2 3 4 5 6 7 8 9 0 a b c d e f g h) $ echo ${array[@]:7} 7 8 9 0 a b c d e f g h $ echo ${array[*]:7} 7 8 9 0 a b c d e f g h $ echo array 0 $ echo ${array[2]} 2 拓展 括号拓展Brace Expansion bash$ echo a{d,c,b}e ade ace abe mkdir /usr/local/src/bash/{old,new,dist,bugs} 命令拓展 命令 cmd 被执行，其输出结果被赋值给一个不可见的变量,然后插入到这个字符串中 $(cmd) `cmd` 波浪拓展 Tilde Expansion ~：这表示当前用户的家目录路径，等同于 $HOME 变量的值。 ~/foo：这表示当前用户的家目录下的 foo 子目录。 ~fred/foo：这表示用户 fred 的家目录下的 foo 子目录。 ~+/foo：这表示当前工作目录下的 foo 子目录，等同于当前目录的路径加上 foo。 ~-/foo：这表示之前的工作目录（由 $OLDPWD 环境变量保存）下的 foo 子目录。如果 $OLDPWD 不存在，就使用 ~- 代替。 ~N：这表示 dirs +N 命令中第 N 个目录路径。 ~+N：这表示 dirs +N 命令中第 N 个目录路径。 ~-N：这表示 dirs -N 命令中第 N 个目录路径。 注意和dirs,popd,pushd这几个参数联系起来 进程 Process Expansion sort -n sorted_numbers.txt 单词拓展Word Splitting Bash通过IFS变量来分词 # 定义一个包含逗号的变量 IFS=',' var=\"apple,banana,cherry\" # 对变量进行扩展，并输出结果 for word in $var; do echo \"$word\" done 文件名拓展 如果变量名包含了*、?、[]三个参数，这个变量会被视为模式，会被用来匹配文件 默认匹配失败默认保持原值 可以设置GLOBIGNORE忽略匹配. ..项# 将模式 ‘.*’ 添加到 GLOBIGNORE 变量中 GLOBIGNORE=.* # 创建一些以 '.' 开头的文件和其他文件 touch .hidden_file .normal_file # 使用通配符匹配文件名 files=* # 对变量进行扩展，并输出结果 for file in $files; do echo \"$file\" done 字符串拓展 cat 重镜像 4:描述符4是1的副本 2>&1:描述符2被定向到1 <>:读写交互 修改shell的行为 set -a：标记用于导出的被修改或创建的变量。 -b：立即通知后台作业的完成。 -e：如果命令以非零状态退出，则立即退出。 -f：禁用文件名生成（通配符扩展）。 -h：为 type 命令查找并记住函数名。 -k：将所有关键字参数放置在命令的环境中。 -m：监视模式。启用作业控制。 -n：读取命令但不执行它们。用于语法检查。 -p：打开特权模式。 -t：读取并执行一个命令后退出。 -u：在替换时将未设置的变量视为错误。 -v：按照它们被读取的顺序打印 shell 输入行。 -x：在执行时打印命令及其参数。 -B：启用花括号扩展。 -C：启用扩展模式匹配。 -E：禁用反斜杠解释。 -H：启用哈希机制。 -P：禁用物理目录跟踪。 -T：启用扩展属性处理。 +：禁用指定的选项。 # 显示所有 shell 变量和函数 set # 设置 shell 选项，如果命令以非零状态退出，则立即退出 set -e # 禁用文件名生成（通配符扩展） set +f shotp shopt -s nullglob：匹配失败移除 shopt -s failglob:打印错误消息并且不执行命令 shopt -s nocaseglob:忽略大小写# 设置 nullglob 选项 shopt -s nullglob # 假设没有匹配的文件 files=file*.txt # files=\"file*.txt\" 作用等同 # files='\"file*.txt\"' 无匹配 # 对变量进行扩展，并输出结果 for file in $files; do echo \"$file\" done 进程调度 bg fg jobs suspend & kill wait 命令行的艺术 CTRL-a:调到结束 CTRL-e:调到结尾 CTRL-u：删除到开头 CTRL-k：删除到结尾 CTRL-w；删除到上一个单词开头 CTRL-x：选中上一次修该 CTRL-b:后退一个单词 CTRL-f:前进一个单词 CTRL-y:回退修改 命令行默认可以转换为vi和emas的编辑模式 set -o emacs set -o vi Corprocess 协程 "},"速查笔记/Linux/Gdb/":{"url":"速查笔记/Linux/Gdb/","title":"Gdb","keywords":"","body":""},"速查笔记/Linux/Gcc/":{"url":"速查笔记/Linux/Gcc/","title":"Gcc","keywords":"","body":"-o ：指定输出的可执行文件名。例如，-o my_program会生成名为my_program的可执行文件。 -c：只编译源代码，不进行链接。这将生成对象文件（.o文件）。 -Wall：开启所有标准的警告信息，帮助发现代码中的潜在问题。 -Wextra：开启额外的警告信息，提供比-Wall更多的警告。 -Wpedantic：严格遵循C/C++标准，对于任何非标准的行为给出警告。 -O0、-O1、-O2、-O3：设置优化级别。-O0表示没有优化（默认），-O1为级别1的优化，-O2为级别2的优化，-O3为级别3的优化。优化可以提高代码的运行效率。 -Os：开启尺寸优化，旨在生成更小的可执行文件。 -g：生成调试信息，这对于调试程序非常有用。 -std=c99、-std=c11：指定C语言的标准版本。类似地，-std=c++98、-std=c++03、-std=c++11、-std=c++14、-std=c++17等用于指定C++的标准版本。 -I：添加头文件搜索路径。例如，-I/usr/local/include会告诉编译器在/usr/local/include目录下搜索头文件。 -L：添加库搜索路径。例如，-L/usr/local/lib会告诉编译器在/usr/local/lib目录下搜索库文件。 -l：链接时使用指定的库。例如，-lmylib会链接名为libmylib.so（Linux）或libmylib.a（静态库）的库。 -pthread：在Linux系统上，如果你的程序使用了POSIX线程（pthreads），需要使用这个选项来链接pthread库。 -fPIC：生成位置无关代码（Position Independent Code），这对于创建共享库是必要的。 -shared：创建共享库（动态库）。 -static：创建静态库或静态链接程序，不使用任何动态库。 "},"速查笔记/Linux/SSh/":{"url":"速查笔记/Linux/SSh/","title":"SSh","keywords":"","body":"ssh-agent 在.bashrc中添加下面的命令就可以启动ssh-agent,用eval的原因是需要设置环境变量 eval \"ssh-agent -s\" ## ssh-agent bash 如果echo $SSH_AGENT_SOCK有值就说明启动成功,可以通过下面的命令查看所有添加的密钥 ssh-add l 如果报错,用ssh-agent bash解决 Could not open a connection to your authentication agent. sshd sudo apt install openssh-server sudo systemctl status openssh-server sudo systemctl start openssh-server 配置文件/etc/ssh/sshd_config "},"速查笔记/Python/":{"url":"速查笔记/Python/","title":"Python","keywords":"","body":""},"速查笔记/Python/DeepLearning/":{"url":"速查笔记/Python/DeepLearning/","title":"DeepLearning","keywords":"","body":""},"速查笔记/Python/DeepLearning/Pandas/":{"url":"速查笔记/Python/DeepLearning/Pandas/","title":"Pandas","keywords":"","body":"Pands库的使用 这里是一份官方教程 基本概念 Pandas的数据由series和DataFrame组成，通常这两个数据结构的值是可以改变的，但是大小不可改变 series是具有index和name的同类dtype的values数据序列,使用numpy.ndarray来存储数据，pandas只有三种数据类型int (int64)、float (float64)、str(object) ages = pd.Series(index=[0,1,2],value=[22, 35, 58],name=\"Age\",dtype=int) DataFrame是一系列series的集合,每个series具有相同的index和相同的长度，name在dataFrame中组成colunms,DataFrame的index和colunms属性实际上是Series,具有单个类型series的dataFrame同一类型，具备多种类型series的dataFrame为object类型。 df = pd.DataFrame(np.arange(9).reshape(3, 3), index = ['TJ', 'BJ', 'SH'], columns=['q', 'w', 'e']) 基本操作 读取与转化 可以通过字典创建dataFrame,通过列表创建series，也可以通过read_* 类函数和to_*函数进行读取和存储,支持csv、excel、json等等流行文件。 pd.read_excel(\"titanic.xlsx\", sheet_name=\"passengers\") df.to_excel(\"titanic.xlsx\", sheet_name=\"passengers\", index=False) pd.read_csv( \"data/air_quality_long.csv\", index_col=\"date.utc\", parse_dates=True ) 查看信息 df.tail df.head df.info df.dtypes df.shape 数据索引 注意你的到的数据通常和原数据是同一份，修改会改变两者 df[\"age\"] df[[\"age\",\"sex\"]] df[df[\"age\"]>35] df[\"age\"]>35 df[df[\"Pclass\"].isin([2, 3])] df[(df[\"Pclass\"] == 2) | (df[\"Pclass\"] == 3)] df[df[\"Age\"].notna()] df.loc[df[\"Age\"] > 35, \"Name\"] df.iloc[9:25, 2:5] df.iloc[0:3, 3] = \"anonymous\" 统计操作 对series可以求max、mean、median，对于dataFrame可以求corr,也可以通过describe查看多个统计值列表，还可以通过value_counts统计出现的次数 agg函数可以选择多个统计量聚类分析 In [7]: titanic.agg( ...: { ...: \"Age\": [\"min\", \"max\", \"median\", \"skew\"], ...: \"Fare\": [\"min\", \"max\", \"median\", \"mean\"], ...: } ...: ) ...: Out[7]: Age Fare min 0.420000 0.000000 max 80.000000 512.329200 median 28.000000 14.454200 skew 0.389108 NaN mean NaN 32.204208 groupby可以选择将某列值作为分类依据,将原数据分为多组,然后计算某个统计值 In [9]: titanic.groupby(\"Sex\").mean() Out[9]: Sex PassengerId Survived Pclass ... SibSp Parch Fare ... female 431.028662 0.742038 2.159236 ... 0.694268 0.649682 44.479818 male 454.147314 0.188908 2.389948 ... 0.429809 0.235702 25.523893 groupby也可以选择多个列,会对这多个列进行排列组合 In [11]: titanic.groupby([\"Sex\", \"Pclass\"])[\"Fare\"].mean() Out[11]: Sex Pclass female 1 106.125798 2 21.970121 3 16.118810 male 1 67.226127 2 19.741782 3 12.661633 Name: Fare, dtype: float64 value_counts可以统计每一种元素出现的次数 In [12]: titanic[\"Pclass\"].value_counts() Out[12]: Pclass 3 491 1 216 2 184 Name: count, dtype: int64 数据重组 sort_values可以按值排序，sort_index可以按照序列排序 In [7]: titanic.sort_values(by=['Pclass', 'Age'], ascending=False).head() Out[7]: PassengerId Survived Pclass ... Fare Cabin Embarked 851 852 0 3 ... 7.7750 NaN S 116 117 0 3 ... 7.7500 NaN Q 280 281 0 3 ... 7.7500 NaN Q 483 484 1 3 ... 9.5875 NaN S 326 327 0 3 ... 6.2375 NaN S [5 rows x 12 columns] pivot可以从原数据中抽取数据，有两种使用方式 pivot(columns=\"location\", values=\"value\") pivot_table同时可以指定index,但是需要指定聚合方法 air_quality.pivot_table( values=\"value\", index=\"location\", columns=\"parameter\", aggfunc=\"mean\" )_counts melt函数创建透视表 pd.melt(df, id_vars =['Name'], value_vars =['Course'],var_name = \"\",value_name = \"\") 合并表格 concat pd.concat([air_quality_pm25, air_quality_no2], axis=0) pd.concat([air_quality_pm25, air_quality_no2], keys=[\"PM25\", \"NO2\"]) merge 见这篇文章 import pandas as pd left = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'A': ['A0', 'A1', 'A2', 'A3'], 'B': ['B0', 'B1', 'B2', 'B3']}) right = pd.DataFrame({'key': ['K0', 'K1', 'K2', 'K3'], 'C': ['C0', 'C1', 'C2', 'C3'], 'D': ['D0', 'D1', 'D2', 'D3']}) result = pd.merge(left, right, on='key') # on参数传递的key作为连接键 result Out[4]: A B key C D 0 A0 B0 K0 C0 D0 1 A1 B1 K1 C1 D1 2 A2 B2 K2 C2 D2 3 A3 B3 K3 C3 D3 绘制 ['area', 'bar', 'barh', 'box', 'density', 'hexbin', 'hist', 'kde', 'line', 'pie', 'scatter'] df.plot() plt.show() 映射操作 参考这篇文章 series.map:支持字典，函数 series.apply:支持带参数的函数 dataFrame.apply:函数 dataFrame.applymap:函数 data[\"gender\"].map({\"男\":1, \"女\":0}) data[\"gender\"].map(lambda x:\"%.2f\" % x) addition = lambda x, y: x + y data[\"age\"].apply(addtion,args=(-3,)) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=0) data[[\"height\",\"weight\",\"age\"]].apply(np.sum, axis=1) df.applymap(lambda x:\"%.2f\" % x) 还可以对index和name进行映射，这个函数叫rename air_quality_renamed = air_quality.rename( columns={ \"station_antwerp\": \"BETR801\", \"station_paris\": \"FR04014\", \"station_london\": \"London Westminster\", } ) 时间序列处理和文本处理（TODO） 操作实例 "},"速查笔记/Python/DeepLearning/matplotlib/":{"url":"速查笔记/Python/DeepLearning/matplotlib/","title":"Matplotlib","keywords":"","body":"从零开始学Matplotlib绘图 Matplotlib是绘制图片的利器,支持多种类型的绘制样式,甚至还可以绘制动画,快和我一起来学习吧,本文参考,关于各种样例 你好世界 下面是第一个实例 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_axes(rect = [0,0,1,1]) ax.plot(x) ax.set_title(\"Hello world!\") plt.show() 这段实例的主要任务如下,后面所有绘制流程基本相似 创建一个画布Figure:plt.figure 添加一个画区Axes:fig.add_axes,[左,下,宽,高]=[0,0,1,1] 添加一个画件Artist-Line2D:ax.plot 添加一个画件Artist-Text:ax.set_title 展示绘制图形:plt.show 无限可分 使用figure画图的最重要的功能之一是绘制多个图形在一个画布上,即在一张画布上画多个图形 fig.subfigures() fig.subfigures的参数如下 nrows, ncols : int,指定划分子图的网格行列数 wspace, hspace : float, 指定子图的水平间距和垂直间距 width_ratios : array-like of length *ncols,指定子图的宽度比,数组长度等同与列数 height_ratios : array-like of length *nrows,指定子图的高度比,数组长度等同与行数 实例如下,你可以看到的确划分成功了,但是不同画区的显示好像重叠了诶？ import numpy as np import matplotlib.pyplot as plt fig = plt.figure() sub_figs = fig.subfigures(2,3,wspace=0.1,hspace=0.2,width_ratios=[0.1,0.6,0.1],height_ratios=[0.5,0.5]) for i in sub_figs: for j in i: j.add_axes([0,0,0.8,0.8,]) plt.show() 我们在划分子区的时候的确将不同子区对应到了不重叠的子画布上,但是子区默认的[左,下,宽,高]=[0,0,0.8,0.8],左和底的开始位置恰好位于边界,自动在当前添加的刻度会超出边界被下一个子图覆盖,修改为这样就好了 j.add_axes([0.2,0.2,0.8,0.8,]) 另一个方法是使用自动布局,layout支持constrained、compressed、tight三种布局,它会帮我们自动的调整被覆盖的位置 fig = plt.figure(layout = \"constrained\") fig.add_axes() fig.add_axes的参数如下,较为简单不做演示 rect:(left,bottom,width,height),表示新 Axes的尺寸。所有值都是相对于图形宽度和高度的分数。 projection:str,投影类型的名称,用于指定 Axes 的投影方式。可以是预定义的投影类型,如 'aitoff'、'hammer'、'lambert'、'mollweide'、'polar'、'rectilinear',也可以是自定义投影的名称。默认值为 None,表示使用默认的 'rectilinear' 投影。 polar:bool,表示是否使用极坐标投影。如果设置为True,则等效于 projection='polar'。 sharex、sharey:matplotlib.axes.Axes 对象,用于共享 x 轴或 y 轴。共享轴将具有与共享轴的原始轴相同的限制、刻度和刻度尺度。fig.add_subplot() fig.subplot具有的参数如下 projection,polar,sharex,sharey,label:见上 args:(row, col, index)或者 .SubplotSpec, 默认为 (1, 1, 1),按照指定的行列划分在指定序号的位置创建Axes,.SubplotSpec见下fig.add_gridspec()fig.subplots() fig.subplots具有的参数如下,实际上该函数就是调用的fig.add_subplot nrows, ncols,sharex,sharey width_ratios,height_ratios:list of array,长度和行列对齐,指定宽度和长度比 squeeze:bool控制返回的 Axes 对象的维度,指定后返回一个压缩一维数组(2,3)->(6) subplot_kw:dict,传递给 Figure.add_subplot 方法的关键字参数字典。 gridspec_kw:dict,传递给 gridspec.GridSpec 构造函数的关键字参数字典。 fig.subplot_mosaic() fig.subplot_mosaic的参数如下 sharex,sharey,width_ratios,height_ratios,subplot_kw,,gridspec_kw mosaic:str或者list,指定划分分区的方式,比较灵活,见下面的示例 per_subplot_kw:dict,传递给每个子区的参数 empty_sentinel : str,指定无效占位符,默认为. 当mosaic为str时,.表示无效占位符,两个AA表示名称为A的Axes占用两个位置, import numpy as np import matplotlib.pyplot as plt fig = plt.figure() sub_figs = fig.subplot_mosaic(\"AAC;.BC\") sub_figs['A'].plot(x) 当mosaic为list时 import numpy as np import matplotlib.pyplot as plt inner = [ [\"inner A\"], [\"inner B\"], ] outer_nested_mosaic = [ [\"main\", inner], [\"bottom\", \"bottom\"], ] axd = plt.figure(layout=\"constrained\").subplot_mosaic( outer_nested_mosaic ) plt.show() fig.add_gridspec() 实际上该函数是调用了GridSpec,GridSpec的参数如下 nrows, ncols,wspace,hspace,width_ratios,height_ratios left, bottom right, top : float,指定位置信息,默认为(0.125,0.1,0.9,0.9) 该函数生成的参数可以直接给fig.add_subplot使用 import numpy as np import matplotlib.pyplot as plt fig = plt.figure(layout, facecolor='lightblue') gs = fig.add_gridspec(nrows=3, ncols=3, left=0.05, right=1, hspace=0.5, wspace=0.5) ax0 = fig.add_subplot(gs[:-1, :]) ax1 = fig.add_subplot(gs[-1, :-1]) ax2 = fig.add_subplot(gs[-1, -1]) fig.suptitle('Manual gridspec with right=0.75') 也可以直接在该返回值上绘制subgridspec,然后使用subplots def squiggle_xy(a, b, c, d, i=np.arange(0.0, 2*np.pi, 0.05)): return np.sin(i*a)*np.cos(i*b), np.sin(i*c)*np.cos(i*d) fig = plt.figure(figsize=(8, 8), layout='constrained') outer_grid = fig.add_gridspec(4, 4, wspace=0, hspace=0) for a in range(4): for b in range(4): # gridspec inside gridspec inner_grid = outer_grid[a, b].subgridspec(3, 3, wspace=0, hspace=0) axs = inner_grid.subplots() # Create all subplots for the inner grid. for (c, d), ax in np.ndenumerate(axs): ax.plot(*squiggle_xy(a + 1, b + 1, c + 1, d + 1)) ax.set(xticks=[], yticks=[]) # show only the outside spines for ax in fig.get_axes(): ss = ax.get_subplotspec() ax.spines.top.set_visible(ss.is_first_row()) ax.spines.bottom.set_visible(ss.is_last_row()) ax.spines.left.set_visible(ss.is_first_col()) ax.spines.right.set_visible(ss.is_last_col()) plt.show() 设置样式 本文的一大特点就是通过类-对象的方式来学习Matplotlib,当你明白了各个类别和子类之间的属性关系后,你就会发现繁复的属性和函数其实有很多是共通的,你可以不用记忆,在使用中熟悉下面的类属关系。 Figure:matplotlib.figure.Figure画布 Axes:matplotlib.axes._axes.Axes画区 super-_AxesBae: dataLim : .Bbox数据范围 viewLim : .Bbox显示范围 xaxis/yaxis:XAxis/YAxis坐标轴 super-Axis:坐标轴基类 XTick/YTick:刻度 super-Tick 刻度基类 spines:list of matplotlib.spines.Spines封闭线 super-Patch:基本形状 transAxes: BboxTransformTo:坐标变换 transData: Transform:坐标变换 fmt_xdata: None | Formatter = ... fmt_ydata: None | Formatter = ... _AxesBase - 画布 _AxesBase具有的基本属性如下 _AxesBase facecolor:color属性,设置背景颜色 frameon:bool,设置边缘是否可见 label:str,设置添加的标题 xscale:str,表示 x 轴的缩放类型。可以是以下字符串之一:'linear'（线性缩放）、'log'（对数缩放）、'symlog'（对称对数缩放）或 'logit'（逻辑刻度缩放）。默认为 'linear' yscale:str,同yscale box_aspect:float,表示图形的盒子宽高比 fmt_xdata:Formatter fmt_ydata:Formatter 设置空白边缘,Axes有一个隐藏属性ax._xmargin,支持负数表示覆盖 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xmargin(-0.1) ax.plot(x) plt.show() spines - 封闭线 你注意到上文的实例中有这么一段话,实际上这是在修改Axes.spines属性,spines属性表示四周的封闭线,包含top,bottom,left,right。你可以采用ax.spines.top或者ax.spines['top']等方式来访问,下面的语句为设置可见性 ax.spines.top.set_visible() spines的父类是matplotlib.patches.Patch,它是 matplotlib 中所有二维可视元素的基类,是一个带有面部颜色和边缘颜色的二维可视元素。这个父类包含这些基本属性 edgecolor: color属性边缘颜色。 facecolor: color属性面部颜色。 color: color属性。该参数用于同时设置边缘颜色和面部颜色。如果同时指定了 color、edgecolor 和 facecolor,则 color 的优先级最高。 linewidth:float,线条宽度。 linestyle: linestyle属性。指定图形对象的边缘线条的样式, antialiased:bool 抗锯齿效果。 hatch:str 填充图案。指定图形对象的填充图案,可以是字符串(例如 '/'、'\\\\'、'x'、'+')。默认值为 None,表示不使用填充图案。 fill: bool填充。指定是否填充图形对象的面部。默认值为 True,表示填充面部。 capstyle: capstyle属性线条端点样式。 joinstyle: joinstyle属性,线条连接方式 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_title(\"Hello world!\") ax.spines['top'].set_color('C0') fig.set_frameon(False) plt.show() [info] linestle属性 指定线形的方式可以是'solod'或者`'-' '-' solid '--' dashed '-.' dash-dot ':' dotted xaxis/yaxis - 坐标轴 xaxis/yaxis是XAxis/YAxis的实例,XAxis/YAxis继承Axis类,同时还具有一个继承了Tick类的XTick/YTick的属性. Axis是 matplotlib 中用于表示坐标轴的类 Axis: major : matplotlib.axis.Ticker,表示主刻度 minor : matplotlib.axis.Ticker,表示副刻度 callbacks : matplotlib.cbook.CallbackRegistry label : .Text,坐标轴标签 labelpad : float,坐标轴标签和坐标轴的距离 offsetText : .Text majorTicks : list of .Tick,主刻度列表 minorTicks : list of .Tick,副刻度列表 你可以通过下面的函数修改坐标轴label和labelpad,实际上调用的函数均为ax.xaxis.label.set_text和ax.xaxis.label.update的封装 ax.set_xlabel(xlabel:str,fontdict=None:str,labelpad=None:float,*,loc=None:str, **kwargs) ax.xaxis.set_label_text(label:str,fontdict:dict,**kwargs) [info] loc loc =['center','left','right]' [info] fontdict import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xlabel(\"nihao\",labelpad=10,loc=\"right\") plt.show() Ticker 刻度 设置刻度线边界set_xbound实际上调用的就是`set_xlim ax.set_xlim ax.set_xbound left : float, right : float, emit : bool, default: True,是否通知observers界限的改变 auto : bool or None, default: False,是否打开axis的autoscaling xmin, xmax : float, optional,等同与left和right但是不能同时传递 示例 import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.set_xlim(1,2) ax.plot(x) plt.show() 设置主要刻度线的位置和显示文本 ax.set_xticks ax.set_xticklabels import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.plot(x) ax.xaxis.offsetText.set_text(\"Custom Text\") ax.set_xticks([1,2,3,4]) ax.set_xticklabels(['a','b','c','d']) plt.show() 设置刻度线的尺度,支持'log','linear','logit','symlog' ax.set_xscale('log') 设置刻度线 ax.set_tick_params() ax.xaxis.set_tick_params() axis:指定要设置的坐标轴,可以是 'x'、'y' 或 'both'(xaxis无）。 which:指定要设置的刻度线,可以是 'major'、'minor' 或 'both'。 direction:指定刻度线的方向,可以是 'in'、'out' 或 'inout'。 length:指定刻度线的长度。 width:指定刻度线的宽度。 color:指定刻度线的颜色。 pad:指定刻度标签与刻度线之间的间距。 labelsize:指定刻度标签的字体大小。 labelcolor:指定刻度标签的颜色。 bottom、top、left、right:指定是否显示底部、顶部、左侧、右侧的刻度线。 labelbottom、labeltop、labelleft、labelright import numpy as np import matplotlib.pyplot as plt x = np.random.random(10) fig = plt.figure() ax = fig.add_subplot(2,2,1) ax.plot(x) ax.xaxis.set_tick_params(which='major', width=2, length=10) plt.show() Ticker有两个属性,当然通常情况下我们不需要操作底层的这两个属性,要详细的设置可以参考下面的例子 _locator : matplotlib.ticker.Locator 决定刻度的位置 _formatter : matplotlib.ticker.Formatter 决定刻度的格式 axis中包含两个Ticker,major和minor,分别表示主刻度和副刻度,你可以通过下面的函数获取这些属性 ax.xaxis.get_major_locator ax.xaxis.set_major_locator ax.xaxis.get_major_formatter ax.xaxis.set_major_locator ... 简单的使用formatter ax0.xaxis.set_major_formatter('{x} km') ax1.xaxis.set_major_formatter(lambda x, pos: str(x-5)) locator 坐标位置控制器 Locator 支持下面这些类（注:默认情况下小刻度处于关闭状态（使用NullLocator和NullFormatter）） FixedLocator:根据固定位置列表生成刻度。 AutoLocator:根据数据范围和轴长度自动计算刻度位置。 MultipleLocator:在指定基准刻度间隔的倍数上生成刻度。 MaxNLocator:根据指定的最大刻度数量自动计算刻度位置。 LogLocator:在对数刻度上生成刻度。 IndexLocator:根据指定的索引间隔生成刻度。 DateLocator:在日期轴上生成刻度。 比如下面的例子 def setup(ax, title): \"\"\"Set up common parameters for the Axes in the example.\"\"\" # only show the bottom spine ax.yaxis.set_major_locator(ticker.NullLocator()) ax.spines[['left', 'right', 'top']].set_visible(False) ax.xaxis.set_ticks_position('bottom') ax.tick_params(which='major', width=1.00, length=5) ax.tick_params(which='minor', width=0.75, length=2.5) ax.set_xlim(0, 5) ax.set_ylim(0, 1) ax.text(0.0, 0.2, title, transform=ax.transAxes, fontsize=14, fontname='Monospace', color='tab:blue') fig, axs = plt.subplots(8, 1, layout='constrained') # Null Locator setup(axs[0], title=\"NullLocator()\") axs[0].xaxis.set_major_locator(ticker.NullLocator()) axs[0].xaxis.set_minor_locator(ticker.NullLocator()) # Multiple Locator setup(axs[1], title=\"MultipleLocator(0.5)\") axs[1].xaxis.set_major_locator(ticker.MultipleLocator(0.5)) axs[1].xaxis.set_minor_locator(ticker.MultipleLocator(0.1)) # Fixed Locator setup(axs[2], title=\"FixedLocator([0, 1, 5])\") axs[2].xaxis.set_major_locator(ticker.FixedLocator([0, 1, 5])) axs[2].xaxis.set_minor_locator(ticker.FixedLocator(np.linspace(0.2, 0.8, 4))) # Linear Locator setup(axs[3], title=\"LinearLocator(numticks=3)\") axs[3].xaxis.set_major_locator(ticker.LinearLocator(3)) axs[3].xaxis.set_minor_locator(ticker.LinearLocator(31)) # Index Locator setup(axs[4], title=\"IndexLocator(base=0.5, offset=0.25)\") axs[4].plot(range(0, 5), [0]*5, color='white') axs[4].xaxis.set_major_locator(ticker.IndexLocator(base=0.5, offset=0.25)) # Auto Locator setup(axs[5], title=\"AutoLocator()\") axs[5].xaxis.set_major_locator(ticker.AutoLocator()) axs[5].xaxis.set_minor_locator(ticker.AutoMinorLocator()) # MaxN Locator setup(axs[6], title=\"MaxNLocator(n=4)\") axs[6].xaxis.set_major_locator(ticker.MaxNLocator(4)) axs[6].xaxis.set_minor_locator(ticker.MaxNLocator(40)) # Log Locator setup(axs[7], title=\"LogLocator(base=10, numticks=15)\") axs[7].set_xlim(10**3, 10**10) axs[7].set_xscale('log') axs[7].xaxis.set_major_locator(ticker.LogLocator(base=10, numticks=15)) plt.show() formatter 坐标格式控制器 Formatter支持下面这些类 StrMethodFormatter:使用字符串的格式方法进行格式化,可以使用类似于 '{}'.format 的格式字符串。 FuncFormatter:使用用户定义的函数进行格式化,函数接受刻度值为参数,返回格式化后的字符串。 ScalarFormatter:对刻度值进行标量格式化,可以指定刻度值的精度、科学计数法等。 FormatStrFormatter:使用格式字符串进行格式化,可以使用类似于 '%.2f' 的格式字符串。 LogFormatter:对对数刻度的刻度标签进行格式化。 PercentFormatter:将刻度值转换为百分比格式。 def setup(ax, title): \"\"\"Set up common parameters for the Axes in the example.\"\"\" # only show the bottom spine ax.yaxis.set_major_locator(ticker.NullLocator()) ax.spines[['left', 'right', 'top']].set_visible(False) # define tick positions ax.xaxis.set_major_locator(ticker.MultipleLocator(1.00)) ax.xaxis.set_minor_locator(ticker.MultipleLocator(0.25)) ax.xaxis.set_ticks_position('bottom') ax.tick_params(which='major', width=1.00, length=5) ax.tick_params(which='minor', width=0.75, length=2.5, labelsize=10) ax.set_xlim(0, 5) ax.set_ylim(0, 1) ax.text(0.0, 0.2, title, transform=ax.transAxes, fontsize=14, fontname='Monospace', color='tab:blue') fig = plt.figure(figsize=(8, 8), layout='constrained') fig0, fig1, fig2 = fig.subfigures(3, height_ratios=[1.5, 1.5, 7.5]) fig0.suptitle('String Formatting', fontsize=16, x=0, ha='left') ax0 = fig0.subplots() setup(ax0, title=\"'{x} km'\") ax0.xaxis.set_major_formatter('{x} km') fig1.suptitle('Function Formatting', fontsize=16, x=0, ha='left') ax1 = fig1.subplots() setup(ax1, title=\"def(x, pos): return str(x-5)\") ax1.xaxis.set_major_formatter(lambda x, pos: str(x-5)) fig2.suptitle('Formatter Object Formatting', fontsize=16, x=0, ha='left') axs2 = fig2.subplots(7, 1) setup(axs2[0], title=\"NullFormatter()\") axs2[0].xaxis.set_major_formatter(ticker.NullFormatter()) setup(axs2[1], title=\"StrMethodFormatter('{x:.3f}')\") axs2[1].xaxis.set_major_formatter(ticker.StrMethodFormatter(\"{x:.3f}\")) setup(axs2[2], title=\"FormatStrFormatter('#%d')\") axs2[2].xaxis.set_major_formatter(ticker.FormatStrFormatter(\"#%d\")) def fmt_two_digits(x, pos): return f'[{x:.2f}]' setup(axs2[3], title='FuncFormatter(\"[{:.2f}]\".format)') axs2[3].xaxis.set_major_formatter(ticker.FuncFormatter(fmt_two_digits)) setup(axs2[4], title=\"FixedFormatter(['A', 'B', 'C', 'D', 'E', 'F'])\") # FixedFormatter should only be used together with FixedLocator. # Otherwise, one cannot be sure where the labels will end up. positions = [0, 1, 2, 3, 4, 5] labels = ['A', 'B', 'C', 'D', 'E', 'F'] axs2[4].xaxis.set_major_locator(ticker.FixedLocator(positions)) axs2[4].xaxis.set_major_formatter(ticker.FixedFormatter(labels)) setup(axs2[5], title=\"ScalarFormatter()\") axs2[5].xaxis.set_major_formatter(ticker.ScalarFormatter(useMathText=True)) setup(axs2[6], title=\"PercentFormatter(xmax=5)\") axs2[6].xaxis.set_major_formatter(ticker.PercentFormatter(xmax=5)) 添加画件 正如前文所描述的那样,matplotlib通过画布-画区-画件的方式管理绘制内容,当你手动添加画区到画布上时,画区已经自带了Spines和Xaxis/Yaxis、Ticker这些基本画件,你还可以自由的添加其他的画件Artist,常见的添加函数见下方。(注:Artist是任意画件包括Figure、Axes的基类） add_artist() 可以添加任意类型的可绘制对象到图形容器中（Artist） add_patch() 用于添加基本的图形元素。(Pathc,Rectangle) add_line(): 向 Axes 对象添加线条对象 (Line2D)。 add_collection(): 向 Axes 对象添加集合对象 (Collection),如散点图 (Scatter)、柱状图 (Bar) 等。 add_table(): 向 Axes 对象添加表格对象 (Table)。 add_text(): 向 Axes 对象添加文本对象 (Text)。 add_image(): 向 Axes 对象添加图像对象 (AxesImage)。 add_axes(): 向 Figure 对象添加新的坐标系 (Axes)。 add_colorbar(): 向 Figure 或 Axes 对象添加颜色条 add_collection3d(): 向 Axes3D 对象添加集合对象 同时你也可以用getp函数获取任意画件可以设置的属性 import matplotlib.artist as martist line_properties = martist.getp(line) print(line_properties) 画件属性与基类 在详细的介绍画件之前,我想先介绍一下通用的属性的设定方式和基本类别属性。 color - 颜色色 属性 [info] color属性 指定颜色的方式有三种 str:g或者green或者C0 'b'/C0 blue 'g'/C1 green 'r'/C2 red 'c'/C3 cyan 'm'/C4 magenta 'y'/C5 yellow 'k'/C6 black 'w'/C7 white tuple: (R,G,B)/(R,G,B,A)元祖,比如(2,34,44),(2,34,44,0.5) str:十六进制字符串,'#008000' marker - 点形 属性 [info]Markers ============= =============================== character description ============= =============================== ``'.'`` point marker ``','`` pixel marker ``'o'`` circle marker ``'v'`` triangle_down marker ``'^'`` triangle_up marker ``''`` triangle_right marker ``'1'`` tri_down marker ``'2'`` tri_up marker ``'3'`` tri_left marker ``'4'`` tri_right marker ``'8'`` octagon marker ``'s'`` square marker ``'p'`` pentagon marker ``'P'`` plus (filled) marker ``'*'`` star marker ``'h'`` hexagon1 marker ``'H'`` hexagon2 marker ``'+'`` plus marker ``'x'`` x marker ``'X'`` x (filled) marker ``'D'`` diamond marker ``'d'`` thin_diamond marker ``'|'`` vline marker ``'_'`` hline marker ============= =============================== linestyle - 线形 属性 Line Styles ============= =============================== character description ============= =============================== ``None``. 关闭绘制线 ``'-'`` solid line style ``'--'`` dashed line style ``'-.'`` dash-dot line style ``':'`` dotted line style ============= =============================== Hatch - 填充 属性 hatch属性接受以下常见的填充样式： '/'：斜线填充 '\\'：反斜线填充 '|'：垂直线填充 '-'：水平线填充 '+'：十字线填充 'x'：X字线填充 'o'：圆圈填充 'O'：大圆圈填充 '.'：点填充 import matplotlib.pyplot as plt # 创建一个简单的条形图 x = ['A', 'B', 'C', 'D'] y = [3, 7, 2, 5] plt.bar(x, y, hatch='///') # 显示图形 plt.show() .Text - 文本 基类 .Text 对象的属性 fontfamily/family/fontname:str,字体,内置有{'serif', 'sans-serif', 'cursive', 'fantasy', 'monospace'} fontvariant/variant :{'normal', 'small-caps'} fontstretch/stretch: 宽度，0-1000/{'ultra-condensed'：超窄，'extra-condensed'：非常窄，'condensed'：窄，'semi-condensed'：半窄，'normal'：正常，'semi-expanded'：半宽，'expanded'：宽，'extra-expanded'：非常宽，'ultra-expanded'：超宽} fontstyle :正常（normal）、斜体（italic）、粗体（bold） fontweight/weight：字体粗细，0-1000/{'ultralight', 'light','normal','regular','book','medium','roman', 'semibold','demibold','demi','bold','heavy','extra 'bold', 'black'} fontsize or size:float or {'xx-small', 'x-small', 'small', 'medium', 'large', 'x-large', 'xx-large'} backgroundcolor:背景色 color:颜色 verticalalignment/va:str垂直对齐方式,可选值包括 'top'、'bottom'、'center'、'baseline' 等。 horizontalalignment/ha:str水平对齐方式,可选值包括 'left'、'right'、'center' 等。 multialignment:str多行文本的对齐方式,可选值包括 'left'、'right'、'center' 等。 wrap:bool,是否在文本过长时自动换行。 linespacing:float,多行文本的行距。 usetex:bool,是否使用 TeX 渲染文本。 rotation:float,文本的旋转角度。 rotation_mode:str,旋转模式,可选值包括 'default'、'anchor'。 transform_rotates_text:bool,是否根据坐标轴的变换来旋转文本。 parse_math:bool是否解析数学表达式。 url:超链接Line2D - 点线 Line2D必须需要输入的数据 xdata:绘制线条的 x 坐标数据,一个float序列。 ydata:绘制线条的 y 坐标数据,一个float序列。 Line2D对象由点marker和线line组成,支持的属性值如下:linewidth,linestyle,color,marker,markersize,markeredgewidth,markeredgecolor,markerfacecolor,markerfacecoloralt dash_capstyle/solid_capstyle:设置虚线/实线CapStyle dash_joinstyle/solid_joinstyle:设置虚线/实线Joinstyle antialiased:线条是否进行抗锯齿渲染,一个bool,默认为 None。 fillstyle:线条上数据点标记的填充样式,一个字符串,默认为 None。通常情况下marker为None,因此不会绘制数据点,设置绘制数据点后可以起作用 import matplotlib.pyplot as plt import numpy as np # 创建一个简单的图形 fig, ax = plt.subplots() # 创建示例数据 x = np.linspace(0, 2*np.pi, 10) y = np.sin(x) # 绘制线条 ax.plot(x, y,'o' ,fillstyle='none', label='none') ax.plot(x, y-0.5, 'o', fillstyle='full', label='full') ax.plot(x, y-1, 'o', fillstyle='left', label='left') ax.plot(x, y-1.5, 'o', fillstyle='right', label='right') ax.plot(x, y-2, 'o', fillstyle='bottom', label='bottom') ax.plot(x, y-2.5, 'o', fillstyle='top', label='top') # 添加图例 ax.legend() plt.show() [info] CapStyle 'butt:线条端点为平直的方形,不延伸过线条的末端。 'round:线条端点为圆形。 'projecting':线条端点为方形,延伸过线条的末端。 [info] JoinStyle miter:连接点为尖角。 round:连接点为圆角。 bevel:连接点为平直的斜角 drawstyle [info] drawstyle \"default\":默认绘制方式,线条将按照给定的坐标点顺序进行插值和绘制 \"steps\":绘制阶梯线条,线条会在每个坐标点之间垂直或水平连接,形成阶梯状的线条。 \"steps-pre\":与 \"steps\" 类似,但是线条是从前一个坐标点开始绘制的。 \"steps-mid\":与 \"steps\" 类似,但是线条是从当前坐标点的中间位置开始绘制的。 \"steps-post\":与 \"steps\" 类似,但是线条是从当前坐标点结束位置开始绘制的。 Text - 文本 Text的属性，其他属性见.Text x/y:float,文本的位置坐标,分别表示 x 和 y 轴上的值。 text:str文本内容。 bbox:dict,外框属性，是一个Rectangle import matplotlib.pyplot as plt # 创建一个文本框并设置样式 text = plt.text(0.5, 0.5, 'Hello, World!', bbox=dict(facecolor='white', edgecolor='black', boxstyle='round,pad=0.5')) # 显示图形 plt.show() 下面是一个简单的示例 import matplotlib.pyplot as plt from matplotlib.pyplot import Text # 创建图表和坐标轴 fig, ax = plt.subplots() # 添加文本标签 text1 = Text(0.4, 0.4, 'Hello, World!', fontsize=12, color='red') text2 = plt.Text(0.1, 0.4, 'Hello, World!') ax.add_artist(text1) ax.add_artist(text2) plt.show() Annotation - 带箭头文本 Annotation继承了Text,是一个带有箭头的Text - `text:注释的文本内容。 - xy:注释目标点的坐标。可以是一个二元元组 (x, y),表示数据坐标,或者是一个字符串,表示坐标轴上的特殊位置,如 'center'、'top'、'bottom' 等。 - xytext:注释文本的位置坐标。如果为 None,则默认与 xy 相同。 - xycoords:注释目标点的坐标系。可选值包括 'data'、'axes fraction'、'figure fraction' 等。 - textcoords:注释文本的坐标系。如果为 None,则默认与 xycoords 相同。 - arrowprops:一个字典,包含箭头的属性设置,用于在注释目标点和注释文本之间绘制箭头。常用的属性包括 'arrowstyle'（箭头样式）、'arrowcolor'（箭头颜色）、'connectionstyle'（连接线样式）等。 - annotation_clip:是否将注释裁剪到图表区域。如果为 None,则默认使用 rcParams['annotation.clip'] 的值。 基本示例如下 import matplotlib.pyplot as plt from matplotlib.text import Annotation # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建Annotation实例 annotation = Annotation(\"Important Point\", xy=(0.5, 0.5), xytext=(0.2, 0.8), arrowprops=dict(arrowstyle='->')) # 将Annotation添加到Axes实例 ax.add_artist(annotation) # 设置坐标轴范围 ax.set_xlim(0, 1) ax.set_ylim(0, 1) # 显示图表 plt.show() Patch - 边 Patch是一个基类,不能够直接使用,可以使用它的子类,具有的基本属性有edgecolor,facecolor,antialiased,hatch,fill,capstyle,joinstyle Rectangle - 矩形 指定的参数有 xy : (float, float) width : float height : float angle : float rotation_point : {'xy', 'center', (number, number)} args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建矩形对象 rect = patches.Rectangle((0.2, 0.3), 0.5, 0.4, edgecolor='red', facecolor='blue', linewidth=2) # 添加矩形对象到图表 ax.add_patch(rect) plt.show() Circle - 圆形 支持的参数如下 xy:圆心坐标 radius:圆半径 args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建圆形对象 circle = patches.Circle((0.5, 0.5), radius=0.2, edgecolor='red', facecolor='blue', linewidth=2) # 添加圆形对象到图表 ax.add_patch(circle) plt.axis('equal') plt.show() Polygon - 多边形 *(x,y):提供顶点 close:bool args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建多边形对象 polygon = patches.Polygon([(0.2, 0.2), (0.5, 0.7), (0.8, 0.2)], edgecolor='red', facecolor='blue', linewidth=2) # 添加多边形对象到图表 ax.add_patch(polygon) plt.axis('equal') plt.show() Ellipse - 椭圆 xy:圆心坐标 width:横轴长 height:纵轴长 angle:角度 args:Patch支持的参数 Wedge - 扇形 center:扇形的中心点坐标。 r:扇形的半径。 theta1:起始角度（以度为单位）。 theta2:结束角度（以度为单位）。 args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建扇形对象 wedge = patches.Wedge((0.5, 0.5), 0.4, 30, 180, edgecolor='red', facecolor='blue', linewidth=2) # 添加扇形对象到图表 ax.add_patch(wedge) plt.axis('equal') plt.show() Arrow - 箭头 x : float,尾部坐标 y : float,尾部坐标 dx : float,箭头x方向长度 dy : float,箭头y方向长度 width : float, default: 1 args:Patch支持的参数 import matplotlib.pyplot as plt import matplotlib.patches as patches # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建箭头对象 arrow = patches.Arrow(0.2, 0.2, 0.4, 0.4, width=0.1, edgecolor='red', facecolor='blue') # 添加箭头对象到图表 ax.add_patch(arrow) plt.axis('equal') plt.show() FancyArror - 装饰性箭头 和Arrow类似,但是多了一些可以控制的参数 length_includes_head:bool,如果为 True,则在计算长度时包括箭头的长度。如果为 False,则仅计算箭头起点到箭头尖端的长度,默认为 False。 head_width:float或 None,默认值为 3 * width,其中 width 是箭头主干的宽度。箭头头部的总宽度。如果未指定,将根据主干宽度自动计算。 head_length:float或 None,默认值为 1.5 * head_width。箭头头部的长度。如果未指定,将根据头部宽度自动计算。 shape:字符串,可选值为 'full'、'left' 或 'right',默认为 'full'。指定箭头的形状。'full' 表示完整箭头,'left' 表示左半箭头,'right' 表示右半箭头。 overhang:folat,表示箭头的倾斜程度。取值范围可以是负数（表示箭头向后倾斜）或大于 1（表示箭头向前倾斜）。默认值为 0,表示箭头为三角形形状。 head_starts_at_zero:bool,如果为 True,则箭头从坐标 0 开始绘制,而不是在坐标 0 结束。默认为 False。Legend - 小标题 几乎每一个Artist（包括Figure、Axes、Line2D等等）都有一个属性叫label（注意和title区分，title是标题，后者为标记文本），当你启动legend时，lable才会起作用 ax.legend参数如下 handles : sequence of .Artist, labels : list of str, optional 有四种使用方式legend():自动检测每个Artist的label legend(handles, labels):绘制给定handles所代表的Artist为对应给定labels legend(handles=handles):绘制给定handles所代表的Artist设定的label legend(labels):按照Artist添加的顺序绘制labels import matplotlib.pyplot as plt import matplotlib.patches as mpatches fig, ax = plt.subplots() red_patch = mpatches.Patch(color='red', label='The red data') ax.legend(handles=[red_patch]) plt.show() Path - 路径 所有matplotlib.patches对象是采用Path绘制的,Path移动方式为位置点-动作方式,支持的动作方式如下 STOP:路径段落类型,表示路径的结束。 MOVETO:路径段落类型,表示移动到一个新的位置,只有一个顶点。 LINETO:路径段落类型,表示绘制一条直线,只有一个顶点。 CURVE3:路径段落类型,表示绘制一个三次贝塞尔曲线,需要两个顶点（起点和终点）。 CURVE4:路径段落类型,表示绘制一个四次贝塞尔曲线,需要三个顶点（起点、控制点和终点）。 CLOSEPOLY:路径段落类型,表示闭合路径,只有一个顶点（起点和终点重合） import matplotlib.pyplot as plt import matplotlib.patches as patches from matplotlib.path import Path # 创建图表和坐标轴 fig, ax = plt.subplots() # 创建路径对象 path_data = [ (Path.MOVETO, [0.2, 0.2]), (Path.LINETO, [0.4, 0.5]), (Path.CURVE3, [0.6, 0.4]), (Path.CURVE3, [0.8, 0.8]), (Path.CLOSEPOLY, [0.2, 0.2]) ] path_codes, path_verts = zip(*path_data) path = Path(path_verts, path_codes) # 创建路径补丁对象 path_patch = patches.PathPatch(path, edgecolor='red', facecolor='blue', linewidth=2) # 添加路径补丁对象到图表 ax.add_patch(path_patch) plt.axis('equal') plt.show() Collection Scatter - 散点图 Scatter必须输入 `x, y` :两个一维数组 支持输入单个下面的属性或者同x，y形状相同的数组 alpha,linewidths,marker,s,c ,linestyle,edgecolors edgecolors : 支持'face', 'none',本别表示同face或者不绘制 支持和点相关的所有参数 import numpy as np import matplotlib.pyplot as plt # 创建网格数据 x = np.linspace(0, 1, 10) y = np.linspace(0, 3, 10) plt.scatter(x,y,s = x*100,c = y,edgecolors='r',marker='p') plt.show() pcolormesh - 伪色彩图 X:二维数组,表示网格数据的 x 坐标。 Y:二维数组,表示网格数据的 y 坐标。 C:二维数组,表示网格数据的颜色值。 cmap:str,颜色映射,用于确定颜色值与颜色的映射关系。默认为 None,使用默认的颜色映射。 vmin 和 vmax:指定颜色值的范围,用于控制颜色填充的范围。默认为 None,自动根据数据的最小值和最大值确定范围。 import numpy as np import matplotlib.pyplot as plt # 创建网格数据 x = np.linspace(0, 1, 10) y = np.linspace(0, 1, 10) X, Y = np.meshgrid(x, y) Z = np.random.rand(10, 10) # 随机生成一个 10x10 的颜色值数组 # 绘制伪彩色图 a = plt.pcolormesh(X, Y, Z, cmap='viridis') # 添加颜色刻度条 plt.colorbar() # 显示图表 plt.show() 封装函数 下面是一些常用的针对添加画件的封装函数 annotate - Annotation bar - Rectangle errorbar - Line2D and Rectangle fill - Polygon hist - Rectangle imshow - AxesImage legend - Legend plot - Line2D scatter - PathCollection text - Text 实际上ax.plot(x,y)等同于 from matplotlib.lines import Line2D line = Line2D(x,y) ax.add_artist(line) 当你手动添加画件后Figure和Axes并不会自动的调整显示,而上面的封装函数包含了对显示的调整当然你也可以主动启动调整函数 fig.tight_layout(): 调整图形中的子图、标签和边界的布局,以确保它们适合图形区域。 fig.subplots_adjust(): 手动调整子图的位置和间距 ax.relim(): 重新计算坐标轴限制,以适应添加的 Artist 对象。 ax.autoscale_view(): 自动调整坐标轴的视图,以适应添加的 Artist 对象。 ax.autoscale(): plot - Line2D plot的封装还支持更多的功能,比如fmt,data,或者同时绘制两个Line2D plot([x], y, [fmt], *, data=None, **kwargs) plot([x], y, [fmt], [x2], y2, [fmt2], ..., **kwargs) format = '[marker][line][color]' plot(x, y, 'bo') #绘制蓝色线条圆圈标记 x/y是类型数组的数据,可以·和data联合起来支持dict、pandas.DataFrame np.random.seed(19680801) # seed the random number generator. data = {'a': np.arange(50), 'c': np.random.randint(0, 50, 50), 'd': np.random.randn(50)} data['b'] = data['a'] + 10 * np.random.randn(50) data['d'] = np.abs(data['d']) * 100 ax.scatter('a', 'b', c='c', s='d', data=data) imshow - AxesImage import matplotlib.pyplot as plt import matplotlib.image as mpimg # 读取图像文件 image = mpimg.imread('path/to/image.jpg') # 创建图形和坐标轴 fig, ax = plt.subplots() # 在坐标轴上显示图像 img = ax.imshow(image) # 显示图形界面 plt.show() 进阶玩法 Cycler - 颜色循环器 matplotlib会自动使用Cycler为你绘制的画件赋予颜色 default_cycler = plt.rcParams['axes.prop_cycle'] # 输出默认样式属性 print(default_cycler) 你也可以创建你自己的Cycler import matplotlib.pyplot as plt from cycler import cycler x = [0, 1, 2, 3, 4] y1 = [0, 1, 0, 2, 1] y2 = [1, 2, 1, 0, 1] # 定义循环器 styles = cycler('color', ['red', 'green', 'blue']) + cycler('linestyle', ['-', '--', ':']) fig, ax = plt.subplots() # 应用循环器样式到线条 ax.plot(x, y1, label='Line 1', **next(styles)) ax.plot(x, y2, label='Line 2', **next(styles)) ax.legend() plt.show() 或者修改配置 plt.rc('axes', prop_cycle=default_cycler) Simplyfy - 简化 patheffects - 路径效果 前文提到,所有对象的底层对象matplotlib.patches是Path,那么他们都可以使用path_effects这个属性来调整显示效果。 import matplotlib.patheffects as path_effects text = plt.text(0.5, 0.5, 'Hello path effects world!', path_effects=[path_effects.withSimplePatchShadow()]) plt.plot([0, 3, 2, 5], linewidth=5, color='blue', path_effects=[path_effects.SimpleLineShadow(), path_effects.Normal(),path_effects.withTickedStroke()]) plt.show() AbstractPathEffect是所有PathEffect的基类唯一的属性是 offset:(x,y)表示偏移 PathPatchEffect - 基础样式 基础样式,可以任意设定,并且可以叠加 import numpy as np import matplotlib.pyplot as plt fig = plt.figure(figsize=(8.5, 1)) t = fig.text(0.02, 0.5, 'Hatch shadow', fontsize=75, weight=1000, va='center') t.set_path_effects([ path_effects.PathPatchEffect( offset=(4, -4), hatch='xxxx', facecolor='gray'), path_effects.PathPatchEffect( edgecolor='white', linewidth=1.1, facecolor='black')]) plt.show() SimpleLineShadow - 阴影样式 适用于Line2D,如直线、曲线等 offset:(x,y)表示偏移 shadow_color:阴影颜色 alpha:float,透明度 rho:float,shadow_color 为 None 时,rho 参数可以用于调整 rgbFace 颜色的亮度或饱和度SimplePatchShadow - 阴影样式 适用于路径对象,如矩形、圆形等,参数同SimpleLineShadowStroke - 重绘样式 接受gc_kw参数,相当于重新指定样式Normal - 原始样式 绘制原始样式TickedStroke - 刻度样式 添加刻度线 offset angle:刻度线的角度,以度为单位。默认值为 45.0。 length:刻度线的长度。默认值为 3。 spacing:刻度线之间的间距。默认值为 5。 length : 长度,默认为1.414transform 坐标变化 在matplotlib中有四种基本坐标,你可以使用前三者,使用转化函数转化为实际显示的像素坐标,转化函数还有一个invert的反向转化 | | | | 转化函数 | |----------|------------------|-----------------------------|:-------------| | 数据坐标 | 按照x,y轴定位 | （12,12） | ax.transData | | 相对坐标 | 按照相对大小定位 | （0.1,0.2） | ax.transAxes,subfigure.transSubfigure,fig.transFigure | | 物理坐标 | 按照实际尺寸定位 | （2/72,2/72）默认单位为（inch） | fig.dpi_scale_trans | | 显示坐标 | 按照像素点定位 | （368,459） | | In [15]: ax.transData.transform((5, 0)) Out[15]: array([ 335.175, 247. ]) In [16]: ax.transData.transform([(5, 0), (1, 2)]) Out[16]: array([[ 335.175, 247. ], [ 132.435, 642.2 ]]) In [41]: inv = ax.transData.inverted() In [43]: inv.transform((335.175, 247.)) Out[43]: array([ 5., 0.]) x = np.arange(0, 10, 0.005) y = np.exp(-x/2.) * np.sin(2*np.pi*x) fig, ax = plt.subplots() ax.plot(x, y) ax.set_xlim(0, 10) ax.set_ylim(-1, 1) xdata, ydata = 5, 0 # This computing the transform now, if anything # (figure size, dpi, axes placement, data limits, scales..) # changes re-calling transform will get a different value. xdisplay, ydisplay = ax.transData.transform((xdata, ydata)) bbox = dict(boxstyle=\"round\", fc=\"0.8\") arrowprops = dict( arrowstyle=\"->\", connectionstyle=\"angle,angleA=0,angleB=90,rad=10\") offset = 72 ax.annotate(f'data = ({xdata:.1f}, {ydata:.1f})', (xdata, ydata), xytext=(-2*offset, offset), textcoords='offset points', bbox=bbox, arrowprops=arrowprops) disp = ax.annotate(f'display = ({xdisplay:.1f}, {ydisplay:.1f})', (xdisplay, ydisplay), xytext=(0.5*offset, -offset), xycoords='figure pixels', textcoords='offset points', bbox=bbox, arrowprops=arrowprops) plt.show() Blended transformations - 混合坐标变化 通过transforms.blended_transform_factory创建混合变化,x坐标被解析为ax.transData,y坐标被解析为ax.transAxes,比如起点（1,0）即为x坐标为1,y位于0%处,x宽为坐标轴长1,y为整个区域100% import matplotlib.transforms as transforms import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() trans = transforms.blended_transform_factory( ax.transData, ax.transAxes) rect = mpatches.Rectangle((1, 0), width=1, height=1, transform=trans, color='yellow', alpha=0.5) ax.add_patch(rect) ax.set_ylim(2,800) ax.set_xlim(0,3) plt.show() 实际上x,y坐标的解析就是混合坐标变化 ax.get_xaxis_transform(), ax.get_yaxis_transform() ScaledTranslation - 偏移坐标变换 class matplotlib.transforms.ScaledTranslation(xt, yt, scale_trans,...) 下面的圆首先被fig.dpi_scale_trans转化,圆心在（0,0）,然后偏移到（0.2,0.7）,注意顺序很重要 import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() xdata, ydata = (0.2, 0.7), (0.5, 0.5) ax.plot(xdata, ydata, \"o\") ax.set_xlim((0, 1)) trans = (fig.dpi_scale_trans + transforms.ScaledTranslation(xdata[0], ydata[0], ax.transData)) # plot an ellipse around the point that is 150 x 130 points in diameter... circle = mpatches.Ellipse((0, 0), 150/72, 130/72, angle=40, fill=None, transform=trans) ax.add_patch(circle) plt.show() 还可以创建阴影 import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() # make a simple sine wave x = np.arange(0., 2., 0.01) y = np.sin(2*np.pi*x) line, = ax.plot(x, y, lw=3, color='blue') # shift the object over 2 points, and down 2 points dx, dy = 2/72., -2/72. offset = transforms.ScaledTranslation(dx, dy, fig.dpi_scale_trans) shadow_transform = ax.transData + offset # now plot the same data with our offset transform; # use the zorder to make sure we are below the line ax.plot(x, y, lw=3, color='gray', transform=shadow_transform, zorder=0.5*line.get_zorder()) ax.set_title('creating a shadow effect with an offset transform') plt.show() 后端配置 后端分为内置后端、拓展后端，静态后端、交互式后端。拓展后端的名称为 类似'module://matplotlib_inline.backend_inline' #查看后端 plt.get_backend() #修改后端 plt.rcParams[\"backend\"] = 'agg1 matplotlib.use('qtagg') 修改配置文件 默认支持的静态后端 ['agg', 'cairo', 'pdf', 'pgf', 'ps', 'svg', 'template'] 默认支持的交互式后端 ['GTK3Agg', 'GTK3Cairo', 'GTK4Agg', 'GTK4Cairo', 'MacOSX', 'nbAgg', 'QtAgg', 'QtCairo', 'Qt5Agg', 'Qt5Cairo', 'TkAgg', 'TkCairo', 'WebAgg', 'WX', 'WXAgg', 'WXCairo'] jupyter拓展后端 jupyter有三个拓展后端，第一个默认，为静态后端，后两个交互式后端需要安装ipympl %matplotlib inline(默认）-'module://matplotlib_inline.backend_inline' %matplotlib ipympl-'module://ipympl.backend_nbagg' %matplotlib widget-'module://ipympl.backend_nbagg' 如果想在ipynb中使用交互式后端，安装ipympl pip install ipympl conda install ipympl -c conda-forge 动态绘图 Animation - 动画 Animation提供两个函数FuncAnimation和ArtistAnimation，前者按照给定函数不断改变Artist的数据，后者按照给定的Artist列表进行迭代。 FuncAnimation FuncAnimation必须指定的参数如下 fig：画布 func：更新函数 frames：总帧数 interval：帧间隔 支持的参数如下：repeat：bool，repeat_delay:int import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() t = np.linspace(0, 3, 40) g = -9.81 v0 = 12 z = g * t**2 / 2 + v0 * t v02 = 5 z2 = g * t**2 / 2 + v02 * t scat = ax.scatter(t[0], z[0], c=\"b\", s=5, label=f'v0 = {v0} m/s') line2 = ax.plot(t[0], z2[0], label=f'v0 = {v02} m/s')[0] ax.set(xlim=[0, 3], ylim=[-4, 10], xlabel='Time [s]', ylabel='Z [m]') ax.legend() def update(frame): # for each frame, update the data stored on each artist. x = t[:frame] y = z[:frame] # update the scatter plot: data = np.stack([x, y]).T scat.set_offsets(data) # update the line plot: line2.set_xdata(t[:frame]) line2.set_ydata(z2[:frame]) return (scat, line2) ani = animation.FuncAnimation(fig=fig, func=update, frames=40, interval=30) plt.show() ArtistAnimation import numpy as np import matplotlib.pyplot as plt fig, ax = plt.subplots() rng = np.random.default_rng(19680801) data = np.array([20, 20, 20, 20]) x = np.array([1, 2, 3, 4]) artists = [] colors = ['tab:blue', 'tab:red', 'tab:green', 'tab:purple'] for i in range(20): data += rng.integers(low=0, high=10, size=data.shape) container = ax.barh(x, data, color=colors) artists.append(container) ani = animation.ArtistAnimation(fig=fig, artists=artists, interval=400) plt.show() writer 支持图片、HTML、视频、Gif等等 Pillow writers: ani.save(filename=\"/tmp/pillow_example.gif\", writer=\"pillow\") ani.save(filename=\"/tmp/pillow_example.apng\", writer=\"pillow\") HTML writers: ani.save(filename=\"/tmp/html_example.html\", writer=\"html\") ani.save(filename=\"/tmp/html_example.htm\", writer=\"html\") ani.save(filename=\"/tmp/html_example.png\", writer=\"html\") FFMpegWriter: ani.save(filename=\"/tmp/ffmpeg_example.mkv\", writer=\"ffmpeg\") ani.save(filename=\"/tmp/ffmpeg_example.mp4\", writer=\"ffmpeg\") ani.save(filename=\"/tmp/ffmpeg_example.mjpeg\", writer=\"ffmpeg\") Imagemagick writers: ani.save(filename=\"/tmp/imagemagick_example.gif\", writer=\"imagemagick\") ani.save(filename=\"/tmp/imagemagick_example.webp\", writer=\"imagemagick\") ani.save(filename=\"apng:/tmp/imagemagick_example.apng\", writer=\"imagemagick\", extra_args=[\"-quality\", \"100\"]) 首先先建立一个基本概念,交互模式与非交互模式 pyplot.ion:打开交互模式 pyplot.ioff:关闭交换模式 pyplot.isinteractive:查看是否为交互模式 pyplot.show:显示所有绘图 pyplot.pause:显示一段时间 事件管理 见文章 ax.cla() fig.clf() ax.cla() fig.canvas.draw_idle() fig.canvas.flush_events() "}}